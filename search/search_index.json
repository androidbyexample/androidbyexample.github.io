{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome! Welcome to https://androidbyexample.com. This is the content site for Johns Hopkins University Whiting School of Engineering's 605.686 Mobile Development for the Android Platform . All code and content is open source and free for use. Please see the LICENSE-code.md and LICENSE-content.md files for license details. Using this site I recommend viewing this site on a desktop or laptop, full screen (or in a reasonably-wide window). It will likely not be terribly useful on a phone screen or tablet in portrait display. Navigation links will be visible on the left if there is enough screen space. Otherwise, a navigation button will appear in the upper left corner of the site; click on it and you can navigate. This site is currently under development. Each week of the course starts on Wednesday, and content and sample code for that week will be released prior to Wednesday. I updated a good bit of the material in the first half of the course while teaching it live this summer, and am converting it into a new format that I think will make it More easily searchable. Allow self pacing vs video content where I control the pace. Be more accessible than trying to read closed captions while also watching the video content. Ensure all changes at each step of an example are displayed. Easier to find and review previous sections while writing your assignment code. I will continue using much of the content from last fall's refresh for the later half of the course. This content is primarily in video form. I'd like to know your thoughts on how the new textual format works for you. Please think about it while reading the new content and watching the older videos. Everyone learns differently, and I'm hoping the new format will help, especially when you need to review a past section.","title":"About This Site"},{"location":"index.html#welcome","text":"Welcome to https://androidbyexample.com. This is the content site for Johns Hopkins University Whiting School of Engineering's 605.686 Mobile Development for the Android Platform . All code and content is open source and free for use. Please see the LICENSE-code.md and LICENSE-content.md files for license details.","title":"Welcome!"},{"location":"index.html#using-this-site","text":"I recommend viewing this site on a desktop or laptop, full screen (or in a reasonably-wide window). It will likely not be terribly useful on a phone screen or tablet in portrait display. Navigation links will be visible on the left if there is enough screen space. Otherwise, a navigation button will appear in the upper left corner of the site; click on it and you can navigate. This site is currently under development. Each week of the course starts on Wednesday, and content and sample code for that week will be released prior to Wednesday. I updated a good bit of the material in the first half of the course while teaching it live this summer, and am converting it into a new format that I think will make it More easily searchable. Allow self pacing vs video content where I control the pace. Be more accessible than trying to read closed captions while also watching the video content. Ensure all changes at each step of an example are displayed. Easier to find and review previous sections while writing your assignment code. I will continue using much of the content from last fall's refresh for the later half of the course. This content is primarily in video form. I'd like to know your thoughts on how the new textual format works for you. Please think about it while reading the new content and watching the older videos. Everyone learns differently, and I'm hoping the new format will help, especially when you need to review a past section.","title":"Using this site"},{"location":"LICENSE-Code.html","text":"Overview This is the LICENSE for all source code in this repository This does not include written content such as README.md files - see Content License for those files All source code examples hosted at https://gitlab.com/android-development-2022-refresh/605.686-2022-fall-term is licensed under the Apache License, version 2.0. Full details of this license appear below. See https://tldrlegal.com/license/apache-license-2.0-(apache-2.0) for a quick summary of this license. Full License Text Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright 2021 Android Development 2021 Refresh Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Source Code License"},{"location":"LICENSE-Code.html#overview","text":"This is the LICENSE for all source code in this repository This does not include written content such as README.md files - see Content License for those files All source code examples hosted at https://gitlab.com/android-development-2022-refresh/605.686-2022-fall-term is licensed under the Apache License, version 2.0. Full details of this license appear below. See https://tldrlegal.com/license/apache-license-2.0-(apache-2.0) for a quick summary of this license.","title":"Overview"},{"location":"LICENSE-Code.html#full-license-text","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright 2021 Android Development 2021 Refresh Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Full License Text"},{"location":"LICENSE-Content.html","text":"Overview This is the LICENSE for all non-code content in this repository. This covers all markdown files, such as README.md, as well as linked course videos hosted on youtube) See Source Code License for the license for source code in this repository The gist of the license: https://creativecommons.org/licenses/by-sa/2.0/ You can share with attribution as long as you include this license AND license any modifications with the same license Full License Text This text is also available at https://creativecommons.org/licenses/by-sa/2.0/legalcode Creative Commons Creative Commons Legal Code Attribution-ShareAlike 2.0 CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE LEGAL SERVICES. DISTRIBUTION OF THIS LICENSE DOES NOT CREATE AN ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS INFORMATION ON AN \"AS-IS\" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES REGARDING THE INFORMATION PROVIDED, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM ITS USE. License THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS PUBLIC LICENSE (\"CCPL\" OR \"LICENSE\"). THE WORK IS PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions \"Collective Work\" means a work, such as a periodical issue, anthology or encyclopedia, in which the Work in its entirety in unmodified form, along with a number of other contributions, constituting separate and independent works in themselves, are assembled into a collective whole. A work that constitutes a Collective Work will not be considered a Derivative Work (as defined below) for the purposes of this License. \"Derivative Work\" means a work based upon the Work or upon the Work and other pre-existing works, such as a translation, musical arrangement, dramatization, fictionalization, motion picture version, sound recording, art reproduction, abridgment, condensation, or any other form in which the Work may be recast, transformed, or adapted, except that a work that constitutes a Collective Work will not be considered a Derivative Work for the purpose of this License. For the avoidance of doubt, where the Work is a musical composition or sound recording, the synchronization of the Work in timed-relation with a moving image (\"synching\") will be considered a Derivative Work for the purpose of this License. \"Licensor\" means the individual or entity that offers the Work under the terms of this License. \"Original Author\" means the individual or entity who created the Work. \"Work\" means the copyrightable work of authorship offered under the terms of this License. \"You\" means an individual or entity exercising rights under this License who has not previously violated the terms of this License with respect to the Work, or who has received express permission from the Licensor to exercise rights under this License despite a previous violation. \"License Elements\" means the following high-level license attributes as selected by Licensor and indicated in the title of this License: Attribution, ShareAlike. 2. Fair Use Rights. Nothing in this license is intended to reduce, limit, or restrict any rights arising from fair use, first sale or other limitations on the exclusive rights of the copyright owner under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for the duration of the applicable copyright) license to exercise the rights in the Work as stated below: to reproduce the Work, to incorporate the Work into one or more Collective Works, and to reproduce the Work as incorporated in the Collective Works; to create and reproduce Derivative Works; to distribute copies or phonorecords of, display publicly, perform publicly, and perform publicly by means of a digital audio transmission the Work including as incorporated in Collective Works; to distribute copies or phonorecords of, display publicly, perform publicly, and perform publicly by means of a digital audio transmission Derivative Works. For the avoidance of doubt, where the work is a musical composition: Performance Royalties Under Blanket Licenses. Licensor waives the exclusive right to collect, whether individually or via a performance rights society (e.g. ASCAP, BMI, SESAC), royalties for the public performance or public digital performance (e.g. webcast) of the Work. Mechanical Rights and Statutory Royalties. Licensor waives the exclusive right to collect, whether individually or via a music rights society or designated agent (e.g. Harry Fox Agency), royalties for any phonorecord You create from the Work (\"cover version\") and distribute, subject to the compulsory license created by 17 USC Section 115 of the US Copyright Act (or the equivalent in other jurisdictions). Webcasting Rights and Statutory Royalties. For the avoidance of doubt, where the Work is a sound recording, Licensor waives the exclusive right to collect, whether individually or via a performance-rights society (e.g. SoundExchange), royalties for the public digital performance (e.g. webcast) of the Work, subject to the compulsory license created by 17 USC Section 114 of the US Copyright Act (or the equivalent in other jurisdictions). The above rights may be exercised in all media and formats whether now known or hereafter devised. The above rights include the right to make such modifications as are technically necessary to exercise the rights in other media and formats. All rights not expressly granted by Licensor are hereby reserved. 4. Restrictions.The license granted in Section 3 above is expressly made subject to and limited by the following restrictions: You may distribute, publicly display, publicly perform, or publicly digitally perform the Work only under the terms of this License, and You must include a copy of, or the Uniform Resource Identifier for, this License with every copy or phonorecord of the Work You distribute, publicly display, publicly perform, or publicly digitally perform. You may not offer or impose any terms on the Work that alter or restrict the terms of this License or the recipients' exercise of the rights granted hereunder. You may not sublicense the Work. You must keep intact all notices that refer to this License and to the disclaimer of warranties. You may not distribute, publicly display, publicly perform, or publicly digitally perform the Work with any technological measures that control access or use of the Work in a manner inconsistent with the terms of this License Agreement. The above applies to the Work as incorporated in a Collective Work, but this does not require the Collective Work apart from the Work itself to be made subject to the terms of this License. If You create a Collective Work, upon notice from any Licensor You must, to the extent practicable, remove from the Collective Work any reference to such Licensor or the Original Author, as requested. If You create a Derivative Work, upon notice from any Licensor You must, to the extent practicable, remove from the Derivative Work any reference to such Licensor or the Original Author, as requested. You may distribute, publicly display, publicly perform, or publicly digitally perform a Derivative Work only under the terms of this License, a later version of this License with the same License Elements as this License, or a Creative Commons iCommons license that contains the same License Elements as this License (e.g. Attribution-ShareAlike 2.0 Japan). You must include a copy of, or the Uniform Resource Identifier for, this License or other license specified in the previous sentence with every copy or phonorecord of each Derivative Work You distribute, publicly display, publicly perform, or publicly digitally perform. You may not offer or impose any terms on the Derivative Works that alter or restrict the terms of this License or the recipients' exercise of the rights granted hereunder, and You must keep intact all notices that refer to this License and to the disclaimer of warranties. You may not distribute, publicly display, publicly perform, or publicly digitally perform the Derivative Work with any technological measures that control access or use of the Work in a manner inconsistent with the terms of this License Agreement. The above applies to the Derivative Work as incorporated in a Collective Work, but this does not require the Collective Work apart from the Derivative Work itself to be made subject to the terms of this License. If you distribute, publicly display, publicly perform, or publicly digitally perform the Work or any Derivative Works or Collective Works, You must keep intact all copyright notices for the Work and give the Original Author credit reasonable to the medium or means You are utilizing by conveying the name (or pseudonym if applicable) of the Original Author if supplied; the title of the Work if supplied; to the extent reasonably practicable, the Uniform Resource Identifier, if any, that Licensor specifies to be associated with the Work, unless such URI does not refer to the copyright notice or licensing information for the Work; and in the case of a Derivative Work, a credit identifying the use of the Work in the Derivative Work (e.g., \"French translation of the Work by Original Author,\" or \"Screenplay based on original Work by Original Author\"). Such credit may be implemented in any reasonable manner; provided, however, that in the case of a Derivative Work or Collective Work, at a minimum such credit will appear where any other comparable authorship credit appears and in a manner at least as prominent as such other comparable authorship credit. 5. Representations, Warranties and Disclaimer UNLESS OTHERWISE AGREED TO BY THE PARTIES IN WRITING, LICENSOR OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND CONCERNING THE MATERIALS, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY, FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU. 6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 7. Termination This License and the rights granted hereunder will terminate automatically upon any breach by You of the terms of this License. Individuals or entities who have received Derivative Works or Collective Works from You under this License, however, will not have their licenses terminated provided such individuals or entities remain in full compliance with those licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this License. Subject to the above terms and conditions, the license granted here is perpetual (for the duration of the applicable copyright in the Work). Notwithstanding the above, Licensor reserves the right to release the Work under different license terms or to stop distributing the Work at any time; provided, however that any such election will not serve to withdraw this License (or any other license that has been, or is required to be, granted under the terms of this License), and this License will continue in full force and effect unless terminated as stated above. 8. Miscellaneous Each time You distribute or publicly digitally perform the Work or a Collective Work, the Licensor offers to the recipient a license to the Work on the same terms and conditions as the license granted to You under this License. Each time You distribute or publicly digitally perform a Derivative Work, Licensor offers to the recipient a license to the original Work on the same terms and conditions as the license granted to You under this License. If any provision of this License is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the remainder of the terms of this License, and without further action by the parties to this agreement, such provision shall be reformed to the minimum extent necessary to make such provision valid and enforceable. No term or provision of this License shall be deemed waived and no breach consented to unless such waiver or consent shall be in writing and signed by the party to be charged with such waiver or consent. This License constitutes the entire agreement between the parties with respect to the Work licensed here. There are no understandings, agreements or representations with respect to the Work not specified here. Licensor shall not be bound by any additional provisions that may appear in any communication from You. This License may not be modified without the mutual written agreement of the Licensor and You. Creative Commons is not a party to this License, and makes no warranty whatsoever in connection with the Work. Creative Commons will not be liable to You or any party on any legal theory for any damages whatsoever, including without limitation any general, special, incidental or consequential damages arising in connection to this license. Notwithstanding the foregoing two (2) sentences, if Creative Commons has expressly identified itself as the Licensor hereunder, it shall have all rights and obligations of Licensor. Except for the limited purpose of indicating to the public that the Work is licensed under the CCPL, neither party will use the trademark \"Creative Commons\" or any related trademark or logo of Creative Commons without the prior written consent of Creative Commons. Any permitted use will be in compliance with Creative Commons' then-current trademark usage guidelines, as may be published on its website or otherwise made available upon request from time to time. Creative Commons may be contacted at https://creativecommons.org/.","title":"Content License"},{"location":"LICENSE-Content.html#overview","text":"This is the LICENSE for all non-code content in this repository. This covers all markdown files, such as README.md, as well as linked course videos hosted on youtube) See Source Code License for the license for source code in this repository The gist of the license: https://creativecommons.org/licenses/by-sa/2.0/ You can share with attribution as long as you include this license AND license any modifications with the same license","title":"Overview"},{"location":"LICENSE-Content.html#full-license-text","text":"This text is also available at https://creativecommons.org/licenses/by-sa/2.0/legalcode Creative Commons Creative Commons Legal Code Attribution-ShareAlike 2.0 CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE LEGAL SERVICES. DISTRIBUTION OF THIS LICENSE DOES NOT CREATE AN ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS INFORMATION ON AN \"AS-IS\" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES REGARDING THE INFORMATION PROVIDED, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM ITS USE. License THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS PUBLIC LICENSE (\"CCPL\" OR \"LICENSE\"). THE WORK IS PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED. BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. 1. Definitions \"Collective Work\" means a work, such as a periodical issue, anthology or encyclopedia, in which the Work in its entirety in unmodified form, along with a number of other contributions, constituting separate and independent works in themselves, are assembled into a collective whole. A work that constitutes a Collective Work will not be considered a Derivative Work (as defined below) for the purposes of this License. \"Derivative Work\" means a work based upon the Work or upon the Work and other pre-existing works, such as a translation, musical arrangement, dramatization, fictionalization, motion picture version, sound recording, art reproduction, abridgment, condensation, or any other form in which the Work may be recast, transformed, or adapted, except that a work that constitutes a Collective Work will not be considered a Derivative Work for the purpose of this License. For the avoidance of doubt, where the Work is a musical composition or sound recording, the synchronization of the Work in timed-relation with a moving image (\"synching\") will be considered a Derivative Work for the purpose of this License. \"Licensor\" means the individual or entity that offers the Work under the terms of this License. \"Original Author\" means the individual or entity who created the Work. \"Work\" means the copyrightable work of authorship offered under the terms of this License. \"You\" means an individual or entity exercising rights under this License who has not previously violated the terms of this License with respect to the Work, or who has received express permission from the Licensor to exercise rights under this License despite a previous violation. \"License Elements\" means the following high-level license attributes as selected by Licensor and indicated in the title of this License: Attribution, ShareAlike. 2. Fair Use Rights. Nothing in this license is intended to reduce, limit, or restrict any rights arising from fair use, first sale or other limitations on the exclusive rights of the copyright owner under copyright law or other applicable laws. 3. License Grant. Subject to the terms and conditions of this License, Licensor hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for the duration of the applicable copyright) license to exercise the rights in the Work as stated below: to reproduce the Work, to incorporate the Work into one or more Collective Works, and to reproduce the Work as incorporated in the Collective Works; to create and reproduce Derivative Works; to distribute copies or phonorecords of, display publicly, perform publicly, and perform publicly by means of a digital audio transmission the Work including as incorporated in Collective Works; to distribute copies or phonorecords of, display publicly, perform publicly, and perform publicly by means of a digital audio transmission Derivative Works. For the avoidance of doubt, where the work is a musical composition: Performance Royalties Under Blanket Licenses. Licensor waives the exclusive right to collect, whether individually or via a performance rights society (e.g. ASCAP, BMI, SESAC), royalties for the public performance or public digital performance (e.g. webcast) of the Work. Mechanical Rights and Statutory Royalties. Licensor waives the exclusive right to collect, whether individually or via a music rights society or designated agent (e.g. Harry Fox Agency), royalties for any phonorecord You create from the Work (\"cover version\") and distribute, subject to the compulsory license created by 17 USC Section 115 of the US Copyright Act (or the equivalent in other jurisdictions). Webcasting Rights and Statutory Royalties. For the avoidance of doubt, where the Work is a sound recording, Licensor waives the exclusive right to collect, whether individually or via a performance-rights society (e.g. SoundExchange), royalties for the public digital performance (e.g. webcast) of the Work, subject to the compulsory license created by 17 USC Section 114 of the US Copyright Act (or the equivalent in other jurisdictions). The above rights may be exercised in all media and formats whether now known or hereafter devised. The above rights include the right to make such modifications as are technically necessary to exercise the rights in other media and formats. All rights not expressly granted by Licensor are hereby reserved. 4. Restrictions.The license granted in Section 3 above is expressly made subject to and limited by the following restrictions: You may distribute, publicly display, publicly perform, or publicly digitally perform the Work only under the terms of this License, and You must include a copy of, or the Uniform Resource Identifier for, this License with every copy or phonorecord of the Work You distribute, publicly display, publicly perform, or publicly digitally perform. You may not offer or impose any terms on the Work that alter or restrict the terms of this License or the recipients' exercise of the rights granted hereunder. You may not sublicense the Work. You must keep intact all notices that refer to this License and to the disclaimer of warranties. You may not distribute, publicly display, publicly perform, or publicly digitally perform the Work with any technological measures that control access or use of the Work in a manner inconsistent with the terms of this License Agreement. The above applies to the Work as incorporated in a Collective Work, but this does not require the Collective Work apart from the Work itself to be made subject to the terms of this License. If You create a Collective Work, upon notice from any Licensor You must, to the extent practicable, remove from the Collective Work any reference to such Licensor or the Original Author, as requested. If You create a Derivative Work, upon notice from any Licensor You must, to the extent practicable, remove from the Derivative Work any reference to such Licensor or the Original Author, as requested. You may distribute, publicly display, publicly perform, or publicly digitally perform a Derivative Work only under the terms of this License, a later version of this License with the same License Elements as this License, or a Creative Commons iCommons license that contains the same License Elements as this License (e.g. Attribution-ShareAlike 2.0 Japan). You must include a copy of, or the Uniform Resource Identifier for, this License or other license specified in the previous sentence with every copy or phonorecord of each Derivative Work You distribute, publicly display, publicly perform, or publicly digitally perform. You may not offer or impose any terms on the Derivative Works that alter or restrict the terms of this License or the recipients' exercise of the rights granted hereunder, and You must keep intact all notices that refer to this License and to the disclaimer of warranties. You may not distribute, publicly display, publicly perform, or publicly digitally perform the Derivative Work with any technological measures that control access or use of the Work in a manner inconsistent with the terms of this License Agreement. The above applies to the Derivative Work as incorporated in a Collective Work, but this does not require the Collective Work apart from the Derivative Work itself to be made subject to the terms of this License. If you distribute, publicly display, publicly perform, or publicly digitally perform the Work or any Derivative Works or Collective Works, You must keep intact all copyright notices for the Work and give the Original Author credit reasonable to the medium or means You are utilizing by conveying the name (or pseudonym if applicable) of the Original Author if supplied; the title of the Work if supplied; to the extent reasonably practicable, the Uniform Resource Identifier, if any, that Licensor specifies to be associated with the Work, unless such URI does not refer to the copyright notice or licensing information for the Work; and in the case of a Derivative Work, a credit identifying the use of the Work in the Derivative Work (e.g., \"French translation of the Work by Original Author,\" or \"Screenplay based on original Work by Original Author\"). Such credit may be implemented in any reasonable manner; provided, however, that in the case of a Derivative Work or Collective Work, at a minimum such credit will appear where any other comparable authorship credit appears and in a manner at least as prominent as such other comparable authorship credit. 5. Representations, Warranties and Disclaimer UNLESS OTHERWISE AGREED TO BY THE PARTIES IN WRITING, LICENSOR OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND CONCERNING THE MATERIALS, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY, FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU. 6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. 7. Termination This License and the rights granted hereunder will terminate automatically upon any breach by You of the terms of this License. Individuals or entities who have received Derivative Works or Collective Works from You under this License, however, will not have their licenses terminated provided such individuals or entities remain in full compliance with those licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this License. Subject to the above terms and conditions, the license granted here is perpetual (for the duration of the applicable copyright in the Work). Notwithstanding the above, Licensor reserves the right to release the Work under different license terms or to stop distributing the Work at any time; provided, however that any such election will not serve to withdraw this License (or any other license that has been, or is required to be, granted under the terms of this License), and this License will continue in full force and effect unless terminated as stated above. 8. Miscellaneous Each time You distribute or publicly digitally perform the Work or a Collective Work, the Licensor offers to the recipient a license to the Work on the same terms and conditions as the license granted to You under this License. Each time You distribute or publicly digitally perform a Derivative Work, Licensor offers to the recipient a license to the original Work on the same terms and conditions as the license granted to You under this License. If any provision of this License is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the remainder of the terms of this License, and without further action by the parties to this agreement, such provision shall be reformed to the minimum extent necessary to make such provision valid and enforceable. No term or provision of this License shall be deemed waived and no breach consented to unless such waiver or consent shall be in writing and signed by the party to be charged with such waiver or consent. This License constitutes the entire agreement between the parties with respect to the Work licensed here. There are no understandings, agreements or representations with respect to the Work not specified here. Licensor shall not be bound by any additional provisions that may appear in any communication from You. This License may not be modified without the mutual written agreement of the Licensor and You. Creative Commons is not a party to this License, and makes no warranty whatsoever in connection with the Work. Creative Commons will not be liable to You or any party on any legal theory for any damages whatsoever, including without limitation any general, special, incidental or consequential damages arising in connection to this license. Notwithstanding the foregoing two (2) sentences, if Creative Commons has expressly identified itself as the Licensor hereunder, it shall have all rights and obligations of Licensor. Except for the limited purpose of indicating to the public that the Work is licensed under the CCPL, neither party will use the trademark \"Creative Commons\" or any related trademark or logo of Creative Commons without the prior written consent of Creative Commons. Any permitted use will be in compliance with Creative Commons' then-current trademark usage guidelines, as may be published on its website or otherwise made available upon request from time to time. Creative Commons may be contacted at https://creativecommons.org/.","title":"Full License Text"},{"location":"contact.html","text":"Scott Stanchfield By day, Scott works at Google in Android Developer Relations. They usually tell him to go play with some (colorful) blocks in the corner (so everyone else can actually get some work done). By night, Scott can be found teaching Android Mobile Application Development and Kotlin programming for the JHU Whiting School. If it hadn\u2019t been for this pandemic, he\u2019d be swing dancing, singing Karaoke and attending musicals whenever they stop in Baltimore or DC. Scott's been a Software Developer/Architect for over 30 years. Some highlights: Worked for Tom McCabe, creator of the Cyclomatic Complexity metric. Worked for Frank DeRemer and Tom Penello, inventors of LALR parsing (the type of parsing used by the lex and yacc parser-generation tools) Worked for Terence Parr (creator of PCCS/ANTLR - which use LL parsing) Was on the ANSI C++ 1998 Standardization committee (don't blame him; he was only in the last two sessions and tried to stop it...) Spent four years as a Java corporate trainer throughout the world Wrote Effective VisualAge for Java, Version 3.5 in the late 90's Held the world record on Discs of Tron (arcade) in the mid 80's. Currently #3 at Twin Galaxies , and #2 on Arcade1Up's machine. A Few Pictures I'm a Noogler! Best. Glasses. Ever! (Part of my MC-3P0 costume) Wecome to the Hallcade. Had to do something with this awkward hall... Education History Bachelor of Arts Computer Science, The University of Michigan Master of Science Computer Science, The Johns Hopkins University Publications Please see http://www.javadude.com/publications/ Contact Information Website: https://javadude.com JHU Email: scott.stanchfield@jhu.edu (use for all class communication) Personal Email: scott@javadude.com (only use for non-class communication)","title":"About Your Instructor"},{"location":"contact.html#scott-stanchfield","text":"By day, Scott works at Google in Android Developer Relations. They usually tell him to go play with some (colorful) blocks in the corner (so everyone else can actually get some work done). By night, Scott can be found teaching Android Mobile Application Development and Kotlin programming for the JHU Whiting School. If it hadn\u2019t been for this pandemic, he\u2019d be swing dancing, singing Karaoke and attending musicals whenever they stop in Baltimore or DC. Scott's been a Software Developer/Architect for over 30 years. Some highlights: Worked for Tom McCabe, creator of the Cyclomatic Complexity metric. Worked for Frank DeRemer and Tom Penello, inventors of LALR parsing (the type of parsing used by the lex and yacc parser-generation tools) Worked for Terence Parr (creator of PCCS/ANTLR - which use LL parsing) Was on the ANSI C++ 1998 Standardization committee (don't blame him; he was only in the last two sessions and tried to stop it...) Spent four years as a Java corporate trainer throughout the world Wrote Effective VisualAge for Java, Version 3.5 in the late 90's Held the world record on Discs of Tron (arcade) in the mid 80's. Currently #3 at Twin Galaxies , and #2 on Arcade1Up's machine.","title":"Scott Stanchfield"},{"location":"contact.html#a-few-pictures","text":"I'm a Noogler! Best. Glasses. Ever! (Part of my MC-3P0 costume) Wecome to the Hallcade. Had to do something with this awkward hall...","title":"A Few Pictures"},{"location":"contact.html#education-history","text":"Bachelor of Arts Computer Science, The University of Michigan Master of Science Computer Science, The Johns Hopkins University","title":"Education History"},{"location":"contact.html#publications","text":"Please see http://www.javadude.com/publications/","title":"Publications"},{"location":"contact.html#contact-information","text":"Website: https://javadude.com JHU Email: scott.stanchfield@jhu.edu (use for all class communication) Personal Email: scott@javadude.com (only use for non-class communication)","title":"Contact Information"},{"location":"week-01/1.1-Introduction/index.html","text":"Note All of the content in this Introduction module is critical to your success in this class. I know it's not the most thrilling read, but please be sure to read it thoroughly. Course Content All course content (https://androidbyexample.com) and the course sample repository (https://gitlab.com/android-development-2022-refresh/605.686-2022-fall-term) are free for use to anyone. Feel free to pass these links to friends and co-workers. For those viewing the content who are not enrolled in 605.686, please ignore any references to the Canvas site, assignments or syllabus. Your Actions Please do the following Check that your email and phone numbers are correct in JHED and SIS. I'll use these to send announcements. If you saw this announcement in your email you should be ok. Please post in the \u201cIntroductions\u201d forum as described in the thread header. Note that there is only one thread; you cannot create separate threads for your introduction. Welcome! Hi there! I'm Scott Stanchfield. Welcome to 605.686, Mobile Application Development for the Android Platform! Let me give you an overview of what we will be doing this semester and where you should begin. We'll be exploring Android application development, covering all sorts of topics including creation of user interfaces, storing data, and communicating with other devices and servers. You can see the full list of topics on this course site. Be sure to pay close attention to the Course Outline. It'll tell you which modules are covered each week as well as start and due dates for the assignments. Please be sure to read this entire note, the syllabus (on the Canvas site), and all sections in the Introduction module. There are lots of very important things in there that I will hold you accountable for. In particular, please pay attention to the academic integrity (I'm good at catching cheaters!) and \"Holistic\" grading (so you understand what your grades actually mean) sections. The syllabus is available via the \"Syllabus\" link on the left menu in Canvas. Note that we've migrated to a common syllabus management tool to ensure all the common university-level information is consistent and up-to-date across all courses. There's an Export button when viewing the Syllabus if you'd like to download and print it. The Introduction module goes into more detail on assignment expectations and grading. Content Note This applies to online sections of the course. If you are taking the class face-to-face/virtual-live, you are responsible for material covered in class (which will be recorded and posted), and the https://androidbyexample.com site is provided only as additional information. I'm posting the course content that would normally appear in Canvas on https://androidbyexample.com. This allows a more custom experience. I'm trying out a new format that's less video-intensive, and hopefully will make it easier to locate information that you need. (Canvas currently doesn't allow custom CSS or Javascript and cannot support the features I'm trying to implement.) I'm not updating all of the material to this new format this term. When studying the content, text or video, please let me know which format works best for you. Sample Code Note This applies to online sections of the course. If you are taking the class face-to-face/virtual-live, you are responsible for material covered in class (which will be recorded and posted), and the course samples site is only provided as supplemental material. All sample code is available at https://gitlab.com/android-development-2022-refresh/605.686-2022-fall-term. Please install git and clone this repository. As I am currently updating the course, you'll need to pull changes when I announce that new content is available. If you haven\u2019t used git before... Download and install git from https://git-scm.com/ Create a directory to hold your git repositories. (I use c:\\users\\scott\\git on my windows machine, but you can put it anywhere you would like) Open a command prompt/terminal and change to that directory Run git clone https://gitlab.com/android-development-2022-refresh/605.686-2022-fall-term. (This will create a 605.686-2022-fall-term directory inside your git directory) Whenever I tell you to update the repository Open a command prompt/terminal and change to that android-development directory Run git pull Kotlin Note All assignments must be written in Kotlin. The text and videos in the course will talk through development environment setup and implementation using Kotlin and describe some of the concepts behind Kotlin along the way. I also teach a course in Kotlin (605.603) but it is not required for this course. It will, however, go into much more detail on the Kotlin language and I recommend everyone take it. Because, ya know, Kotlin is cool. Very, very cool Online Video Tips Some modules will link to video content. All videos are hosted on YouTube, and I\u2019ve enabled automatic closed captions/transcript. The transcript is useful for searching. To search videos: Click the \"...\" button under the video Choose \"Open Transcript\" Pause the video Press control-f (or whatever your browser\u2019s \"find\" command is) Type what you want to find Click on the transcript line you want to jump to and the video will jump there. Press play Note that the automatic transcripts are not perfect, but they can help you find what you\u2019re looking for (Eventually I\u2019ll be hand-editing them to improve accuracy). All videos were recorded and rendered at 1920x1080 (HD). That's the ideal size to watch them (if you\u2019re watching full screen. If you're watching non full-screen, with the transcript, you'll want to have your resolution set higher to reduce artifacts. Make sure the settings for the video playback are HD/1080p for the best image. I\u2019ve increased the font size in Android Studio when recording, but you\u2019ll want to be sure things are as clear as possible. Keep in mind that YouTube allows you to change the playback speed. Some students like to speed up or (more likely, as I talk quickly at times) slow down a bit. Office Hours Office Hours will be held each Monday from 7pm-8pm Eastern. Please use the \"Office Hours\" link from the Canvas site to enter the Zoom office hours session. Note that if no one shows up by 7:20p, I\u2019ll close the session (unless you have let me know in advance that you intend to come and will be late) Questions If you have questions during the course, please: Search using Google or StackOverflow for ideas. You can often find a response faster than I will see your question and respond. Check the forum and see if the question has been asked If the question isn't private (such as a question about your grades), please post it in the discussion forums If it's a private matter, please email me at scott.stanchfield@jhu.edu Please use the forums as much as possible for questions; many students often have the same questions and this makes it easy for everyone to learn. As you progress through the course, if you have comments about the content (things you really like, dislike, or how things can be done better ), please post in the Course Feedback forum or keep a log of your thoughts to send to me after the course is finished. (For those who are not enrolled in the course, please email me at scott@javadude.com with any comments or siggesti) If you have any questions or concerns while going through this course you may post them in the General Questions thread, located under Discussions on the left menu in Canvas or you may contact me directly at scott.stanchfield@jhu.edu. Additionally, you can refer to Help & Support on the left menu for a listing of all the student services and support available to you. Here's to a great term! -- Scott","title":"Welcome!"},{"location":"week-01/1.1-Introduction/index.html#course-content","text":"All course content (https://androidbyexample.com) and the course sample repository (https://gitlab.com/android-development-2022-refresh/605.686-2022-fall-term) are free for use to anyone. Feel free to pass these links to friends and co-workers. For those viewing the content who are not enrolled in 605.686, please ignore any references to the Canvas site, assignments or syllabus.","title":"Course Content"},{"location":"week-01/1.1-Introduction/index.html#your-actions","text":"Please do the following Check that your email and phone numbers are correct in JHED and SIS. I'll use these to send announcements. If you saw this announcement in your email you should be ok. Please post in the \u201cIntroductions\u201d forum as described in the thread header. Note that there is only one thread; you cannot create separate threads for your introduction.","title":"Your Actions"},{"location":"week-01/1.1-Introduction/index.html#welcome","text":"Hi there! I'm Scott Stanchfield. Welcome to 605.686, Mobile Application Development for the Android Platform! Let me give you an overview of what we will be doing this semester and where you should begin. We'll be exploring Android application development, covering all sorts of topics including creation of user interfaces, storing data, and communicating with other devices and servers. You can see the full list of topics on this course site. Be sure to pay close attention to the Course Outline. It'll tell you which modules are covered each week as well as start and due dates for the assignments. Please be sure to read this entire note, the syllabus (on the Canvas site), and all sections in the Introduction module. There are lots of very important things in there that I will hold you accountable for. In particular, please pay attention to the academic integrity (I'm good at catching cheaters!) and \"Holistic\" grading (so you understand what your grades actually mean) sections. The syllabus is available via the \"Syllabus\" link on the left menu in Canvas. Note that we've migrated to a common syllabus management tool to ensure all the common university-level information is consistent and up-to-date across all courses. There's an Export button when viewing the Syllabus if you'd like to download and print it. The Introduction module goes into more detail on assignment expectations and grading.","title":"Welcome!"},{"location":"week-01/1.1-Introduction/index.html#content","text":"Note This applies to online sections of the course. If you are taking the class face-to-face/virtual-live, you are responsible for material covered in class (which will be recorded and posted), and the https://androidbyexample.com site is provided only as additional information. I'm posting the course content that would normally appear in Canvas on https://androidbyexample.com. This allows a more custom experience. I'm trying out a new format that's less video-intensive, and hopefully will make it easier to locate information that you need. (Canvas currently doesn't allow custom CSS or Javascript and cannot support the features I'm trying to implement.) I'm not updating all of the material to this new format this term. When studying the content, text or video, please let me know which format works best for you.","title":"Content"},{"location":"week-01/1.1-Introduction/index.html#sample-code","text":"Note This applies to online sections of the course. If you are taking the class face-to-face/virtual-live, you are responsible for material covered in class (which will be recorded and posted), and the course samples site is only provided as supplemental material. All sample code is available at https://gitlab.com/android-development-2022-refresh/605.686-2022-fall-term. Please install git and clone this repository. As I am currently updating the course, you'll need to pull changes when I announce that new content is available.","title":"Sample Code"},{"location":"week-01/1.1-Introduction/index.html#if-you-havent-used-git-before","text":"Download and install git from https://git-scm.com/ Create a directory to hold your git repositories. (I use c:\\users\\scott\\git on my windows machine, but you can put it anywhere you would like) Open a command prompt/terminal and change to that directory Run git clone https://gitlab.com/android-development-2022-refresh/605.686-2022-fall-term. (This will create a 605.686-2022-fall-term directory inside your git directory) Whenever I tell you to update the repository Open a command prompt/terminal and change to that android-development directory Run git pull","title":"If you haven\u2019t used git before..."},{"location":"week-01/1.1-Introduction/index.html#kotlin-note","text":"All assignments must be written in Kotlin. The text and videos in the course will talk through development environment setup and implementation using Kotlin and describe some of the concepts behind Kotlin along the way. I also teach a course in Kotlin (605.603) but it is not required for this course. It will, however, go into much more detail on the Kotlin language and I recommend everyone take it. Because, ya know, Kotlin is cool. Very, very cool","title":"Kotlin Note"},{"location":"week-01/1.1-Introduction/index.html#online-video-tips","text":"Some modules will link to video content. All videos are hosted on YouTube, and I\u2019ve enabled automatic closed captions/transcript. The transcript is useful for searching. To search videos: Click the \"...\" button under the video Choose \"Open Transcript\" Pause the video Press control-f (or whatever your browser\u2019s \"find\" command is) Type what you want to find Click on the transcript line you want to jump to and the video will jump there. Press play Note that the automatic transcripts are not perfect, but they can help you find what you\u2019re looking for (Eventually I\u2019ll be hand-editing them to improve accuracy). All videos were recorded and rendered at 1920x1080 (HD). That's the ideal size to watch them (if you\u2019re watching full screen. If you're watching non full-screen, with the transcript, you'll want to have your resolution set higher to reduce artifacts. Make sure the settings for the video playback are HD/1080p for the best image. I\u2019ve increased the font size in Android Studio when recording, but you\u2019ll want to be sure things are as clear as possible. Keep in mind that YouTube allows you to change the playback speed. Some students like to speed up or (more likely, as I talk quickly at times) slow down a bit.","title":"Online Video Tips"},{"location":"week-01/1.1-Introduction/index.html#office-hours","text":"Office Hours will be held each Monday from 7pm-8pm Eastern. Please use the \"Office Hours\" link from the Canvas site to enter the Zoom office hours session. Note that if no one shows up by 7:20p, I\u2019ll close the session (unless you have let me know in advance that you intend to come and will be late)","title":"Office Hours"},{"location":"week-01/1.1-Introduction/index.html#questions","text":"If you have questions during the course, please: Search using Google or StackOverflow for ideas. You can often find a response faster than I will see your question and respond. Check the forum and see if the question has been asked If the question isn't private (such as a question about your grades), please post it in the discussion forums If it's a private matter, please email me at scott.stanchfield@jhu.edu Please use the forums as much as possible for questions; many students often have the same questions and this makes it easy for everyone to learn. As you progress through the course, if you have comments about the content (things you really like, dislike, or how things can be done better ), please post in the Course Feedback forum or keep a log of your thoughts to send to me after the course is finished. (For those who are not enrolled in the course, please email me at scott@javadude.com with any comments or siggesti) If you have any questions or concerns while going through this course you may post them in the General Questions thread, located under Discussions on the left menu in Canvas or you may contact me directly at scott.stanchfield@jhu.edu. Additionally, you can refer to Help & Support on the left menu for a listing of all the student services and support available to you. Here's to a great term! -- Scott","title":"Questions"},{"location":"week-01/1.1-Introduction/STEP_10_FULL.html","text":"Hardware You do not need an Android device for your coursework, but if you have access to one (or want to purchase one for your coursework) development feels more realistic. Note that if you have low memory and/or do not have an SSD on your computer, an external device may help performance. For running Android Studio, the minimum recommended configuration is 8GB RAM with an SSD. More memory is better, as Android Studio and the Android emulator love to use lots of memory. Ideally you'll have 16GB or more RAM. If you have only 8GB RAM, I strongly recommend you either upgrade your RAM or purchase an inexpensive Android phone for classwork. Many pay-as-you-go phones (which you do not have to activate) can be found for under $100 and will greatly improve your development experience. Software The following are the required versions of tools for this term. Please keep a copy of all downloaded installation files in case you need to reinstall during the term! Warning Do not upgrade any versions after the first module unless I instruct you to do so! We want to make sure we're using the same version of everything that you are when we grade your assignment submissions. Name Version Android Studio https://developer.android.com/studio/preview Dolphin (2021.3.1 RC 1) Kotlin (plugin version in build.gradle) 1.7.10 Jetpack Compose UI (compose_ui_version in build.gradle) 1.2.1 Jetpack Compose Compiler (compose_compiler_version in build.gradle) 1.3.1 Android minimum API (minSdk in app/build.gradle) 21 Android target API (targetSdk in app/build.gradle) 33 Android compile API (compileSdk in app/build.gradle) 33 Sample Code See the \"Sample Code\" module for download and usage instructions If you see any problems in the sample code, please let me know and I'll update it.","title":"Course Hardware and Software"},{"location":"week-01/1.1-Introduction/STEP_10_FULL.html#hardware","text":"You do not need an Android device for your coursework, but if you have access to one (or want to purchase one for your coursework) development feels more realistic. Note that if you have low memory and/or do not have an SSD on your computer, an external device may help performance. For running Android Studio, the minimum recommended configuration is 8GB RAM with an SSD. More memory is better, as Android Studio and the Android emulator love to use lots of memory. Ideally you'll have 16GB or more RAM. If you have only 8GB RAM, I strongly recommend you either upgrade your RAM or purchase an inexpensive Android phone for classwork. Many pay-as-you-go phones (which you do not have to activate) can be found for under $100 and will greatly improve your development experience.","title":"Hardware"},{"location":"week-01/1.1-Introduction/STEP_10_FULL.html#software","text":"The following are the required versions of tools for this term. Please keep a copy of all downloaded installation files in case you need to reinstall during the term! Warning Do not upgrade any versions after the first module unless I instruct you to do so! We want to make sure we're using the same version of everything that you are when we grade your assignment submissions. Name Version Android Studio https://developer.android.com/studio/preview Dolphin (2021.3.1 RC 1) Kotlin (plugin version in build.gradle) 1.7.10 Jetpack Compose UI (compose_ui_version in build.gradle) 1.2.1 Jetpack Compose Compiler (compose_compiler_version in build.gradle) 1.3.1 Android minimum API (minSdk in app/build.gradle) 21 Android target API (targetSdk in app/build.gradle) 33 Android compile API (compileSdk in app/build.gradle) 33","title":"Software"},{"location":"week-01/1.1-Introduction/STEP_10_FULL.html#sample-code","text":"See the \"Sample Code\" module for download and usage instructions If you see any problems in the sample code, please let me know and I'll update it.","title":"Sample Code"},{"location":"week-01/1.1-Introduction/STEP_20_FULL.html","text":"Late Submissions Late submissions will be reduced by one letter grade (1 point) for each DAY (or partial day) late (no exceptions without timely prior coordination with the instructors). See the grading policy for assignment grading details. Note If you expect any issues with turning in work on time, please see the instructor as soon as you know. If I know in advance about travel, expected high workloads or other issues, I can work with you. However, letting me know a day or two before an assignment is due is not acceptable (If an emergency occurs, please let me know as soon as possible afterwards.) Note If you encounter issues while trying to submit your assignment, please immediately send me an email with your submission text and a note stating that Canvas is being your best friend. If you submit in this manner, I will not count your submission as late. Note that the easiest way to get a lower grade is to turn in your assignments late. If you know that something is coming up (business/vacation travel, expected very busy week at work, medical, expected baby) please let me know and I'm happy to work with you. Commit Often!!! Note: I highly recommend that you store your code in a version control system such as subversion or git. However, if you host your project on a public site like github, you must make the repositories private! (Note that bitbucket provides free private repositories) Any non-private repositories that I find online will automatically set your grade to \"F\" for sharing code. Be sure to control your source code! Lost code will not be accepted as an excuse for late or missing assignments. General guidelines for grade ranges These are general guidelines, not absolute descriptions of a grading level. Your overall grade on an assignment depends on the overall quality and functionality of your submission. Again, these are general guidelines. You can get lower grades for very significant problems in your submissions and very late submissions. Letter Grade Common Reasons for the Grade A On time AND Working AND Good design B Missing required functionality Not quite working Bad design/bad style One day late (but would have otherwise been an \"A\") C Many missing functions Will not compile Will not execute properly Very bad design One day late (but would have been an \"B\") Two days late (but would have been an \"A\") F Little apparent effort Plagiarism Three or more days late Not turned in I grade on the following aspects of your submissions. Note that there is no specific percentage allocation for each of these concepts. Aspect What I Look For Design Does the design use the patterns discussed in class properly? Does the design fit the problem? Is the program designed with a maintenance programmer in mind? Can I determine why you did things the way you did by reading code and comments? Function Is all required function present? Is any non-required function present? (grade deduction) Does present function work properly? Style and Coding Conventions Is the code readable? Can I easily figure out what it's doing just by reading the code? Does the code follow the required coding conventions? Note: Not following the required coding conventions, even once in a submission, maximizes your assignment grade at A- Timeliness Was the assignment submitted on time? one day late = 1-point grade deduction two days late = 2-point grade deduction ... Coding Conventions All assignments must observe the following coding conventions. Why? I read your code Sometimes your code doesn't work correctly (sometimes spectacularly so...). Before I decide on the grade to give you, I carefully read the code to try to figure out why it didn't work. If the reason is a small, subtle thing, I'll often give more credit (rather than simply saying \"doesn't work; you get a C\") I often have to do this for several assignments. If the code is readable, using meaning variable, method and class names, I can often find the problems more quickly. Keep in mind that I have many submissions to review each time, and usually 20% or more have some big issues. This also helps a good bit when some of you are having trouble before submitting and ask for help. If I can read the code, I can figure out what's going on and respond that much more quickly. Indentation must be consistent. Use either spaces or tabs, but not both! All type names must follow Upper-Camel Case ShoppingCart ObjectDrawingApplet All variable and method names must follow Lower-Camel Case drawObject() numberOfObjectsOnScreen Type, variable and method names shall be a series of full words, not abbreviations or single letters. Standard acronyms are acceptable (such as url), but names like \"c\" are generally not acceptable. If you aren't sure whether a name is acceptable, feel free to ask me, but remember the rule of thumb: it should sound exactly like what it's being used for. Some Exceptions (based on common, understood usage) integer counters in loops can be named i, j, k the \"current number\" for walking through an array or counting items can be n e for an exception in a catch block All classes and interfaces must be contained in a Kotlin package All Kotlin package names must be completely lower-case and start with lastname.firstname.hw# where the # is the homework number. For example, I might have a project named \"stanchfield.scott.hw4\"(with the same Android package name) that contains Kotlin packages: stanchfield.scott.hw4 stanchfield.scott.hw4.model stanchfield.scott.hw4.database All projects must be named HW1, HW2, HW3 and so forth All submission zip files must be named lastname . firstname .HW1.zip, lastname . firstname .HW2.zip, etc All string literals that would appear for the user (typically text in TextViews, dialogs, toasts, etc) must be externalized into the strings.xml file. This is a really good habit to get into upfront, and you should always do this in any application you create to make localization simpler. Note This means all user-facing text. Any string constants that the user could see, whether used in your XML files or Kotlin code, must be externalized.","title":"Assignments"},{"location":"week-01/1.1-Introduction/STEP_20_FULL.html#late-submissions","text":"Late submissions will be reduced by one letter grade (1 point) for each DAY (or partial day) late (no exceptions without timely prior coordination with the instructors). See the grading policy for assignment grading details. Note If you expect any issues with turning in work on time, please see the instructor as soon as you know. If I know in advance about travel, expected high workloads or other issues, I can work with you. However, letting me know a day or two before an assignment is due is not acceptable (If an emergency occurs, please let me know as soon as possible afterwards.) Note If you encounter issues while trying to submit your assignment, please immediately send me an email with your submission text and a note stating that Canvas is being your best friend. If you submit in this manner, I will not count your submission as late. Note that the easiest way to get a lower grade is to turn in your assignments late. If you know that something is coming up (business/vacation travel, expected very busy week at work, medical, expected baby) please let me know and I'm happy to work with you.","title":"Late Submissions"},{"location":"week-01/1.1-Introduction/STEP_20_FULL.html#commit-often","text":"Note: I highly recommend that you store your code in a version control system such as subversion or git. However, if you host your project on a public site like github, you must make the repositories private! (Note that bitbucket provides free private repositories) Any non-private repositories that I find online will automatically set your grade to \"F\" for sharing code. Be sure to control your source code! Lost code will not be accepted as an excuse for late or missing assignments.","title":"Commit Often!!!"},{"location":"week-01/1.1-Introduction/STEP_20_FULL.html#general-guidelines-for-grade-ranges","text":"These are general guidelines, not absolute descriptions of a grading level. Your overall grade on an assignment depends on the overall quality and functionality of your submission. Again, these are general guidelines. You can get lower grades for very significant problems in your submissions and very late submissions. Letter Grade Common Reasons for the Grade A On time AND Working AND Good design B Missing required functionality Not quite working Bad design/bad style One day late (but would have otherwise been an \"A\") C Many missing functions Will not compile Will not execute properly Very bad design One day late (but would have been an \"B\") Two days late (but would have been an \"A\") F Little apparent effort Plagiarism Three or more days late Not turned in I grade on the following aspects of your submissions. Note that there is no specific percentage allocation for each of these concepts. Aspect What I Look For Design Does the design use the patterns discussed in class properly? Does the design fit the problem? Is the program designed with a maintenance programmer in mind? Can I determine why you did things the way you did by reading code and comments? Function Is all required function present? Is any non-required function present? (grade deduction) Does present function work properly? Style and Coding Conventions Is the code readable? Can I easily figure out what it's doing just by reading the code? Does the code follow the required coding conventions? Note: Not following the required coding conventions, even once in a submission, maximizes your assignment grade at A- Timeliness Was the assignment submitted on time? one day late = 1-point grade deduction two days late = 2-point grade deduction ...","title":"General guidelines for grade ranges"},{"location":"week-01/1.1-Introduction/STEP_20_FULL.html#coding-conventions","text":"All assignments must observe the following coding conventions. Why? I read your code Sometimes your code doesn't work correctly (sometimes spectacularly so...). Before I decide on the grade to give you, I carefully read the code to try to figure out why it didn't work. If the reason is a small, subtle thing, I'll often give more credit (rather than simply saying \"doesn't work; you get a C\") I often have to do this for several assignments. If the code is readable, using meaning variable, method and class names, I can often find the problems more quickly. Keep in mind that I have many submissions to review each time, and usually 20% or more have some big issues. This also helps a good bit when some of you are having trouble before submitting and ask for help. If I can read the code, I can figure out what's going on and respond that much more quickly. Indentation must be consistent. Use either spaces or tabs, but not both! All type names must follow Upper-Camel Case ShoppingCart ObjectDrawingApplet All variable and method names must follow Lower-Camel Case drawObject() numberOfObjectsOnScreen Type, variable and method names shall be a series of full words, not abbreviations or single letters. Standard acronyms are acceptable (such as url), but names like \"c\" are generally not acceptable. If you aren't sure whether a name is acceptable, feel free to ask me, but remember the rule of thumb: it should sound exactly like what it's being used for. Some Exceptions (based on common, understood usage) integer counters in loops can be named i, j, k the \"current number\" for walking through an array or counting items can be n e for an exception in a catch block All classes and interfaces must be contained in a Kotlin package All Kotlin package names must be completely lower-case and start with lastname.firstname.hw# where the # is the homework number. For example, I might have a project named \"stanchfield.scott.hw4\"(with the same Android package name) that contains Kotlin packages: stanchfield.scott.hw4 stanchfield.scott.hw4.model stanchfield.scott.hw4.database All projects must be named HW1, HW2, HW3 and so forth All submission zip files must be named lastname . firstname .HW1.zip, lastname . firstname .HW2.zip, etc All string literals that would appear for the user (typically text in TextViews, dialogs, toasts, etc) must be externalized into the strings.xml file. This is a really good habit to get into upfront, and you should always do this in any application you create to make localization simpler. Note This means all user-facing text. Any string constants that the user could see, whether used in your XML files or Kotlin code, must be externalized.","title":"Coding Conventions"},{"location":"week-01/1.1-Introduction/STEP_30_FULL.html","text":"Points Assignments are worth 4 points each, mapping to GPA letters. My grader and I assign letter grades first, then convert them to numbers and apply late penalties. The grading scale from letters to numbers is as follows: Letter Grade Numerical Equivalent A 4.0 A- 3.7 (A/B border) 3.5 B+ 3.3 B 3.0 B- 2.7 (B/C border) 2.5 C+ 2.3 C 2.0 C- 1.7 (C/D border) 1.5 D+ 1.3 D 1.0 D- 0.7 F 0 Note that there is no A+. We had been reserving that for \"exemplary\" submissions, but some students considered an \"A\" as lost points. Your final grade WILL NOT include +/- designations. A/A- both count as \"A\" and \"4\" for University GPA purposes(and similar for other letter grades). Late Penalty Each day late results in 1 full letter grade (1 point) off. This is to prevent cascading lateness. In the past students would submit an assignment a week late and have one week less to do the next assignment, which would often result in that assignment being late as well. The also made it difficult to discus assignments until all were submitted. When grading assignments, we will write comments describing your grade, but we will usually not note specific point-value deductions (see \"Holistic Grading\" below). Some comments are \"for your information\"/\"helpful hints\" and will be marked to indicate that they have no effect on the grade. If you disagree with a grade you can ask us to review it. Tell us what your concerns are and we'll look at it. Sometimes we may miss something in your code. If we note a problem with a submission that was also noted for a previous submission, we will not count off for it. (If we do, please let use know and we'll correct the grade.) \"Holistic\" Grading I started out using a rubric to grade. For many reasons, this almost never reflected reality, so after a few terms, I realized a much fairer scheme, that I call \"holistic grading\" First, some problems with Rubrics... Gaming the System When I had point counts next to features, many students would decide which features to implement based on how many points they felt they could afford to lose. Rather than implement all function (the point of which is to exercise important techniques), they would implement a subset just to \"get the grade\". This is frustrating for a teacher because we design exercises to be sure students have had the opportunity to try out important techniques. \"Sum of the Parts\" vs \"The Whole\" Rubrics tend to cut both ways when the points are added up... Sometimes, a few relatively minor things that don't greatly impact the overall submission would numerically push the grade into \"B\" territory or lower. This didn't feel fair to the student based on the overall result, but to be fair to all students I had to stick with the grade based off the rubric. Other times, small things that made an impact when combined could result in an \"A\" that didn't feel right (sometimes because of gaming the system, other times because the small problems really added up). \"That shouldn't be n points off\" The most common complaint would be that either the rubric was unfair in the number of points it assigned to a specific item, or that I was applying a rubric item too broadly to a problem in the submission. Most of the time I would leave the grade as-is, but in some cases it was a matter of a possible alternative interpretation of the assignment requirements, in which case I adjusted the points off. Later, after I stopped using rubrics, but would list points deductions on assignment comments, I'd get the same complaints. In either case, this never made any significant difference in the grade for the assignment, or the course. Students ended up spending a good bit of time trying to figure out which items they could argue to get a few points back, not realizing a few points over the term made no effective difference. This led me to... \"Holistic Grading\" (If it sounds a little \"New Age\", it's not... \"Holistic\" here simply means \"looking at the whole\") \"This feels like a B+\"... My grader and I write comments about what we see in the assignment, and don't write specific deductions for each one. We look at the overall result, taking all comments into account, and say \"that's an A\", or \"that's a B-\", or \"that's barely anything more than the sample code\" (at which point we estimate the % of the assignment that was done and assign that number). The letters we assign are converted to numbers. A=4.0, A-=3.7, etc. When coming up with these letters, one of my key concepts is \"things that cap the grade at A-\". There's not a fixed list of such items, but things like \"coding conventions\" fall into this category. If several small things like these happen, a rubric may have pushed the grade into \"B\" territory. When I see several little things but otherwise the overall submission feels like an \"A\", I use \"A-\" as the grade. Note that if there are \"cap\" items as well as bigger issues, the \"cap\" items won't push the grade lower than the bigger issues already would have. Usually, if features are missing or not implemented per the assignment description, I start thinking \"B\", but if they're very minor features or present but not quite what was explicitly stated in the assignment description, and otherwise the assignment looked good, I'll go with \"A-\". Because of this, \"A-\" is often the most common grade for an assignment. If the assignment does everything we ask, in the ways I taught in class, meets coding standards, and is on time, that's where \"A\" comes in. Other grades (before late deductions) are usually driven by Feature omissions or problems Most common: something is missing or doesn't work properly This is often because a student started work a few days before the assignment was due and didn't have time to ask questions or study the concepts. Crashes and compilation errors Note that we try to make your code work before grading it. Sometimes it's an inverted boolean expression, and if we can get it working and it's something simple, we'll give a better grade than \"doesn't work\". However, sometimes, after spending an hour or two trying to get it to work, we have to give up... Working together or Plagiarism I've caught many students doing this... Sometimes they even try to submit something they found online that doesn't match the assignment description or is very obviously not based on what I've taught. Bottom line: When you see a \"3.7\" for a submission, don't think of it as \"0.3 points off\". Think of it as a few minor things aren't right. If that's how most of your assignments go, that's an \"A\" for the course... Distribution of Grades It is possible (and has happened in past sections) for everyone to get an \"A\" in this course. I will not be applying any sort of curve or other means to artificially distribute grades. I will be looking closely at your efforts in this class when determining your final grades. An \"A\" grade in this course requires a good deal of effort. Do not expect an \"A\" if you start programming a few nights before they are due... Let me repeat that. Do not expect an \"A\" if you start programming assignments a few nights before they are due... This has often been the reason for B and C grades in the course; students do not allow enough time to ask clarifying questions or do the coding. Be sure to at least look over and understand the assignments at the beginning of the week they are assigned! This will give you time to ask questions. If you do all the work well and on-time, you will get an \"A\" for the course. If you do all of the work on-time but are having trouble with the concepts, you'll likely get a \"B\" for the course. If you're in danger of a lower grade, I will speak with you as soon as it becomes apparent to me.","title":"Grading"},{"location":"week-01/1.1-Introduction/STEP_30_FULL.html#points","text":"Assignments are worth 4 points each, mapping to GPA letters. My grader and I assign letter grades first, then convert them to numbers and apply late penalties. The grading scale from letters to numbers is as follows: Letter Grade Numerical Equivalent A 4.0 A- 3.7 (A/B border) 3.5 B+ 3.3 B 3.0 B- 2.7 (B/C border) 2.5 C+ 2.3 C 2.0 C- 1.7 (C/D border) 1.5 D+ 1.3 D 1.0 D- 0.7 F 0 Note that there is no A+. We had been reserving that for \"exemplary\" submissions, but some students considered an \"A\" as lost points. Your final grade WILL NOT include +/- designations. A/A- both count as \"A\" and \"4\" for University GPA purposes(and similar for other letter grades).","title":"Points"},{"location":"week-01/1.1-Introduction/STEP_30_FULL.html#late-penalty","text":"Each day late results in 1 full letter grade (1 point) off. This is to prevent cascading lateness. In the past students would submit an assignment a week late and have one week less to do the next assignment, which would often result in that assignment being late as well. The also made it difficult to discus assignments until all were submitted. When grading assignments, we will write comments describing your grade, but we will usually not note specific point-value deductions (see \"Holistic Grading\" below). Some comments are \"for your information\"/\"helpful hints\" and will be marked to indicate that they have no effect on the grade. If you disagree with a grade you can ask us to review it. Tell us what your concerns are and we'll look at it. Sometimes we may miss something in your code. If we note a problem with a submission that was also noted for a previous submission, we will not count off for it. (If we do, please let use know and we'll correct the grade.)","title":"Late Penalty"},{"location":"week-01/1.1-Introduction/STEP_30_FULL.html#holistic-grading","text":"I started out using a rubric to grade. For many reasons, this almost never reflected reality, so after a few terms, I realized a much fairer scheme, that I call \"holistic grading\" First, some problems with Rubrics... Gaming the System When I had point counts next to features, many students would decide which features to implement based on how many points they felt they could afford to lose. Rather than implement all function (the point of which is to exercise important techniques), they would implement a subset just to \"get the grade\". This is frustrating for a teacher because we design exercises to be sure students have had the opportunity to try out important techniques. \"Sum of the Parts\" vs \"The Whole\" Rubrics tend to cut both ways when the points are added up... Sometimes, a few relatively minor things that don't greatly impact the overall submission would numerically push the grade into \"B\" territory or lower. This didn't feel fair to the student based on the overall result, but to be fair to all students I had to stick with the grade based off the rubric. Other times, small things that made an impact when combined could result in an \"A\" that didn't feel right (sometimes because of gaming the system, other times because the small problems really added up). \"That shouldn't be n points off\" The most common complaint would be that either the rubric was unfair in the number of points it assigned to a specific item, or that I was applying a rubric item too broadly to a problem in the submission. Most of the time I would leave the grade as-is, but in some cases it was a matter of a possible alternative interpretation of the assignment requirements, in which case I adjusted the points off. Later, after I stopped using rubrics, but would list points deductions on assignment comments, I'd get the same complaints. In either case, this never made any significant difference in the grade for the assignment, or the course. Students ended up spending a good bit of time trying to figure out which items they could argue to get a few points back, not realizing a few points over the term made no effective difference. This led me to... \"Holistic Grading\" (If it sounds a little \"New Age\", it's not... \"Holistic\" here simply means \"looking at the whole\") \"This feels like a B+\"... My grader and I write comments about what we see in the assignment, and don't write specific deductions for each one. We look at the overall result, taking all comments into account, and say \"that's an A\", or \"that's a B-\", or \"that's barely anything more than the sample code\" (at which point we estimate the % of the assignment that was done and assign that number). The letters we assign are converted to numbers. A=4.0, A-=3.7, etc. When coming up with these letters, one of my key concepts is \"things that cap the grade at A-\". There's not a fixed list of such items, but things like \"coding conventions\" fall into this category. If several small things like these happen, a rubric may have pushed the grade into \"B\" territory. When I see several little things but otherwise the overall submission feels like an \"A\", I use \"A-\" as the grade. Note that if there are \"cap\" items as well as bigger issues, the \"cap\" items won't push the grade lower than the bigger issues already would have. Usually, if features are missing or not implemented per the assignment description, I start thinking \"B\", but if they're very minor features or present but not quite what was explicitly stated in the assignment description, and otherwise the assignment looked good, I'll go with \"A-\". Because of this, \"A-\" is often the most common grade for an assignment. If the assignment does everything we ask, in the ways I taught in class, meets coding standards, and is on time, that's where \"A\" comes in. Other grades (before late deductions) are usually driven by Feature omissions or problems Most common: something is missing or doesn't work properly This is often because a student started work a few days before the assignment was due and didn't have time to ask questions or study the concepts. Crashes and compilation errors Note that we try to make your code work before grading it. Sometimes it's an inverted boolean expression, and if we can get it working and it's something simple, we'll give a better grade than \"doesn't work\". However, sometimes, after spending an hour or two trying to get it to work, we have to give up... Working together or Plagiarism I've caught many students doing this... Sometimes they even try to submit something they found online that doesn't match the assignment description or is very obviously not based on what I've taught. Bottom line: When you see a \"3.7\" for a submission, don't think of it as \"0.3 points off\". Think of it as a few minor things aren't right. If that's how most of your assignments go, that's an \"A\" for the course...","title":"\"Holistic\" Grading"},{"location":"week-01/1.1-Introduction/STEP_30_FULL.html#distribution-of-grades","text":"It is possible (and has happened in past sections) for everyone to get an \"A\" in this course. I will not be applying any sort of curve or other means to artificially distribute grades. I will be looking closely at your efforts in this class when determining your final grades. An \"A\" grade in this course requires a good deal of effort. Do not expect an \"A\" if you start programming a few nights before they are due... Let me repeat that. Do not expect an \"A\" if you start programming assignments a few nights before they are due... This has often been the reason for B and C grades in the course; students do not allow enough time to ask clarifying questions or do the coding. Be sure to at least look over and understand the assignments at the beginning of the week they are assigned! This will give you time to ask questions. If you do all the work well and on-time, you will get an \"A\" for the course. If you do all of the work on-time but are having trouble with the concepts, you'll likely get a \"B\" for the course. If you're in danger of a lower grade, I will speak with you as soon as it becomes apparent to me.","title":"Distribution of Grades"},{"location":"week-01/1.1-Introduction/STEP_40_FULL.html","text":"Using Third-Party Code When writing your assignments, you may copy small sections of code and other content you find online if and only if you attribute it and the code is freely copyable with a license that says it's ok to copy. Place a comment above the copied section stating where you found it and the license that applies. Using code from stackoverflow If you're using code from https://stackoverflow.com, note that all code and content is licensed CREATIVE COMMONS \u2013 ATTRIBUTION \u2013 SHARE-ALIKE (CC-BY-SA 3.0) (see https://creativecommons.org/licenses/by-sa/3.0/us/). Warning THIS IS A VIRAL LICENSE!!! This means that any code/content you copy forces you to make your project be licensed CC-BY-SA 3.0!!! This is nearly always a no-no with companies you work for and the government! Note Some code or content may contain additional licenses. For example, when Googlers write code snippets on stackoverflow, they'll add something like // Copyright 2022 Google LLC. // SPDX-License-Identifier: Apache-2.0 at the top of their code to indicate that it's also licensed under the Apache 2.0 license. In this case, it's ok to use the code as long as you adhere to the Apache 2.0 license. For your assignment submissions in this course, copying any content from stackoverflow is fine. In real life, unless the content has a more permissive license, such as Apache 2.0, do not copy code from stackoverflow ! To use stackoverflow safely: Use \u201cclean room\u201d approach Read and understand Close the browser Then write your code Using Course Sample Code You may copy code from my class examples as well. Once again, you must attribute it. Add a comment at the top of your assignment submission source files that states that you're using sample code from the course. Code from the course sample code repository is licensed Apache 2 (see the LICENSE-code.md file in the repository) and can be used/incorporated into your own projects with attribution. Note that this code is generally not well-tested and may contain bugs. If you find something that doesn't work, please let me know and I'll update the samples. Code that I write live in face-to-face class or post in a discussion forum is not licensed for any use outside this class. You may not post or distribute any this code for any purpose other than writing your assignments.","title":"Using Third-Party and Course Sample Code"},{"location":"week-01/1.1-Introduction/STEP_40_FULL.html#using-third-party-code","text":"When writing your assignments, you may copy small sections of code and other content you find online if and only if you attribute it and the code is freely copyable with a license that says it's ok to copy. Place a comment above the copied section stating where you found it and the license that applies.","title":"Using Third-Party Code"},{"location":"week-01/1.1-Introduction/STEP_40_FULL.html#using-code-from-stackoverflow","text":"If you're using code from https://stackoverflow.com, note that all code and content is licensed CREATIVE COMMONS \u2013 ATTRIBUTION \u2013 SHARE-ALIKE (CC-BY-SA 3.0) (see https://creativecommons.org/licenses/by-sa/3.0/us/). Warning THIS IS A VIRAL LICENSE!!! This means that any code/content you copy forces you to make your project be licensed CC-BY-SA 3.0!!! This is nearly always a no-no with companies you work for and the government! Note Some code or content may contain additional licenses. For example, when Googlers write code snippets on stackoverflow, they'll add something like // Copyright 2022 Google LLC. // SPDX-License-Identifier: Apache-2.0 at the top of their code to indicate that it's also licensed under the Apache 2.0 license. In this case, it's ok to use the code as long as you adhere to the Apache 2.0 license. For your assignment submissions in this course, copying any content from stackoverflow is fine. In real life, unless the content has a more permissive license, such as Apache 2.0, do not copy code from stackoverflow ! To use stackoverflow safely: Use \u201cclean room\u201d approach Read and understand Close the browser Then write your code","title":"Using code from stackoverflow"},{"location":"week-01/1.1-Introduction/STEP_40_FULL.html#using-course-sample-code","text":"You may copy code from my class examples as well. Once again, you must attribute it. Add a comment at the top of your assignment submission source files that states that you're using sample code from the course. Code from the course sample code repository is licensed Apache 2 (see the LICENSE-code.md file in the repository) and can be used/incorporated into your own projects with attribution. Note that this code is generally not well-tested and may contain bugs. If you find something that doesn't work, please let me know and I'll update the samples. Code that I write live in face-to-face class or post in a discussion forum is not licensed for any use outside this class. You may not post or distribute any this code for any purpose other than writing your assignments.","title":"Using Course Sample Code"},{"location":"week-01/1.2-Android-studio/index.html","text":"Video Note You can change the quality and playback speed by clicking the icon when the video is playing. If you would like to search the captions for this video, click Watch on YouTube , press \"...\" and choose Show Transcript . Example Source See https://gitlab.com/android-development-2022-refresh/android-studio","title":"Android Studio"},{"location":"week-01/1.2-Android-studio/index.html#video","text":"Note You can change the quality and playback speed by clicking the icon when the video is playing. If you would like to search the captions for this video, click Watch on YouTube , press \"...\" and choose Show Transcript .","title":"Video"},{"location":"week-01/1.2-Android-studio/index.html#example-source","text":"See https://gitlab.com/android-development-2022-refresh/android-studio","title":"Example Source"},{"location":"week-01/1.3-Activities/index.html","text":"Introduction Activities are the main \"screens\" of your application. You can have a single activity and swap out the user-interface elements (which will be our strategy for this course), or navigate between multiple activities. In this module, we'll look at activities from a high level and take a quick peek at how the \"old school\" View setup works. We won't be using Views (other than Google Map) for this class, but you should be familiar with them. Objectives Understand how the Android system manages the lifecycle of an Activity, and some of the callbacks you can implement to become aware of changes in Activity state Shudder when you see the XML that you used to have to write for user interfaces. Smile knowing that the newer ways of writing user interfaces are much simpler and more direct. Videos Note You can change the quality and playback speed by clicking the icon when the video is playing. If you would like to search the captions for this video, click Watch on YouTube , press \"...\" and choose Show Transcript . Lecture: Activities Example: Activities Note This video shows how activities used to be created, to contrast with how we'll be creating applications in this class. Jetpack Compose makes thing much simpler, but this example is important, as you'll likely see applications using the old view-based approach. The application structure remains similar, as we'll use some XML resources (primarily string localizations). Example Source See https://gitlab.com/android-development-2022-refresh/android-studio","title":"Activities and Application Structure Overview"},{"location":"week-01/1.3-Activities/index.html#introduction","text":"Activities are the main \"screens\" of your application. You can have a single activity and swap out the user-interface elements (which will be our strategy for this course), or navigate between multiple activities. In this module, we'll look at activities from a high level and take a quick peek at how the \"old school\" View setup works. We won't be using Views (other than Google Map) for this class, but you should be familiar with them.","title":"Introduction"},{"location":"week-01/1.3-Activities/index.html#objectives","text":"Understand how the Android system manages the lifecycle of an Activity, and some of the callbacks you can implement to become aware of changes in Activity state Shudder when you see the XML that you used to have to write for user interfaces. Smile knowing that the newer ways of writing user interfaces are much simpler and more direct.","title":"Objectives"},{"location":"week-01/1.3-Activities/index.html#videos","text":"Note You can change the quality and playback speed by clicking the icon when the video is playing. If you would like to search the captions for this video, click Watch on YouTube , press \"...\" and choose Show Transcript .","title":"Videos"},{"location":"week-01/1.3-Activities/index.html#lecture-activities","text":"","title":"Lecture: Activities"},{"location":"week-01/1.3-Activities/index.html#example-activities","text":"Note This video shows how activities used to be created, to contrast with how we'll be creating applications in this class. Jetpack Compose makes thing much simpler, but this example is important, as you'll likely see applications using the old view-based approach. The application structure remains similar, as we'll use some XML resources (primarily string localizations).","title":"Example: Activities"},{"location":"week-01/1.3-Activities/index.html#example-source","text":"See https://gitlab.com/android-development-2022-refresh/android-studio","title":"Example Source"},{"location":"week-02/2.1-Kotlin-primer/index.html","text":"Introduction Kotlin is a fantastic new language that we'll be using to create our Android Applications. In this module, we'll quickly explore the basics of the language from a Java perspective. During the rest of the course, I'll often explain some of these concepts in more detail. Objectives Understand the basic structure of Kotlin classes, properties and functions Use lambdas as arguments to functions as callbacks or observers Video Note You can change the quality and playback speed by clicking the icon when the video is playing. If you would like to search the captions for this video, click Watch on YouTube , press \"...\" and choose Show Transcript . Example Source Example Source: https://gitlab.com/android-development-2022-refresh/kotlin-primer","title":"Kotlin Primer"},{"location":"week-02/2.1-Kotlin-primer/index.html#introduction","text":"Kotlin is a fantastic new language that we'll be using to create our Android Applications. In this module, we'll quickly explore the basics of the language from a Java perspective. During the rest of the course, I'll often explain some of these concepts in more detail.","title":"Introduction"},{"location":"week-02/2.1-Kotlin-primer/index.html#objectives","text":"Understand the basic structure of Kotlin classes, properties and functions Use lambdas as arguments to functions as callbacks or observers","title":"Objectives"},{"location":"week-02/2.1-Kotlin-primer/index.html#video","text":"Note You can change the quality and playback speed by clicking the icon when the video is playing. If you would like to search the captions for this video, click Watch on YouTube , press \"...\" and choose Show Transcript .","title":"Video"},{"location":"week-02/2.1-Kotlin-primer/index.html#example-source","text":"Example Source: https://gitlab.com/android-development-2022-refresh/kotlin-primer","title":"Example Source"},{"location":"week-02/2.2-Versions/index.html","text":"Introduction Android is an incredibly fast-moving platform, and designing applications that can run successfully on multiple versions of Android can be tricky. In this module, we'll talk about some concerns and techniques for creating backward-compatible applications. Objectives Know where to look to determine which versions of Android for which you want to retain compatibility See how version checks and compatibility libraries can assist with backward compatibility Video Note You can change the quality and playback speed by clicking the icon when the video is playing. If you would like to search the captions for this video, click Watch on YouTube , press \"...\" and choose Show Transcript .","title":"Versions"},{"location":"week-02/2.2-Versions/index.html#introduction","text":"Android is an incredibly fast-moving platform, and designing applications that can run successfully on multiple versions of Android can be tricky. In this module, we'll talk about some concerns and techniques for creating backward-compatible applications.","title":"Introduction"},{"location":"week-02/2.2-Versions/index.html#objectives","text":"Know where to look to determine which versions of Android for which you want to retain compatibility See how version checks and compatibility libraries can assist with backward compatibility","title":"Objectives"},{"location":"week-02/2.2-Versions/index.html#video","text":"Note You can change the quality and playback speed by clicking the icon when the video is playing. If you would like to search the captions for this video, click Watch on YouTube , press \"...\" and choose Show Transcript .","title":"Video"},{"location":"week-02/2.3-Architecture/index.html","text":"Before we start writing code, let's talk about how we should organize our application. Over the years there have been many best practices for organizing code. These practices evolve as technologies change and we learn from maintaining previous approaches. When we look at the application as a whole and consider all of its high-level parts, we're talking about the architecture of the application. The architecture describes the general division of responsibilities in your application, and which parts communicate with which other parts. Breaking your application into chunks allows for Easier discussion of how the application works Easier developer tasking (especially in larger applications) Reuse of chunks across different types of applications (reusing the data layer, for example, across mobile apps, web services, and command-line applications) Easier independent testing of separate parts of your application The architecture we use in this class is based on Modern Android Development , also known as \"MAD\". See https://developer.android.com/modern-android-development , which includes architecture, tools and libraries that Google recommends for Android development. Architecture Overview Applications are structured as Layers and Modules . A \"module\" is a separately-compilable group of code and resources that can be consumed by other modules in your system. They're useful for isolating functionality, internal implementation details can be hidden while exposing a subset of function, its public API (Application Programming Interface). Separating code into modules also helps large applications isolate changes that many developers are making at the same time. A \"layer\" is a grouping of one or more modules with certain responsibilities. Layers allow you to explicitly define communication between modules and further improve ease of maintenance. Application Layers graph TD UI[User-Interface Layer] -->|depends on| Domain Domain[Domain Layer] -->|depends on| Data[Data Layer] At a high level, we talk about application layers , separating data from its manipulation and presentation. Each layer isolates a responsibility in the application. At its simplest, each layer could be exactly one module. (While layers could be just conceptual grouping of code/resources that are all in a single module, using at least one module per layer gives us the ability to restrict what's exposed between layers.) Layers could contain multiple modules, which I recommend as the application grows in size. The Data Layer manages data acquisition and update. You can use it to persist data locally in a database, file or in memory. Or maybe your application connects to a server for its data; you can use the Data Layer to connect to a server to grab data and push changes. By keeping your data access code inside the Data Layer , you can abstract and hide the how data is accessed from the rest of the application. If your data management code changes over time, the rest of the application may require fewer changes to adapt. Operations in the Data Layer are sometimes called Primitive Operations , as they're the core, often simplest, operations you define on your data. Many primitive operations are simply property changes to objects and CRUD operations (Create/Read/Update/Delete) against your data store. You may also define more complex operations that are always needed for any user of the data. The Data Layer doesn't depend upon other architectural layers, but may depend upon other modules/libraries such as database storage or network communication. The Domain Layer is an optional layer that increases in value as the size of your application grows. Often you'll find that several parts of your application need to perform the same sequences of primitive operations. For example, a game might have several places that put an item in the player's inventory. It would be a great idea to create a function to contain the repeated code, but where do we put that function? In a smaller application, you could add a function in the User-Interface Layer , and you've successfully factored out that common functionality. As the application grows, the user interface might be broken down into multiple modules. Which UI module should host that functionality? Or if you want to use the same \"put item in inventory\" for an Android application, desktop application, and web application, you no longer have a common user interface to host it. A Domain Layer hosts this type of common functionality and gives you access from any user interface components, within the same application or across multiple applications. These types of operations are generally called \"macro operations\". They build upon primitive operations by combining primitives to create more complex processing of the data. In recent architectures, these types of operations are called Use Cases or Interactors . The Domain Layer only depends upon the architectural Data Layer for access to its data. It can also depend upon other modules/libraries that provide frameworks, algorithms or support functions to work with the data. Finally, we use our User-Interface Layer to present data to the user and interpret their actions. This layer can present the data using many different approaches: graphically, textually, as a service, or using assistive technologies for example. Note I've called out \"as a service\" as a type of User-Interface implementation. Think about what it means to be a \"user\". The \"outsider\" that's interacting with your application is its user. That could be a person, or it could be other applications. When we think of a service (such as a web service) as a \"user interface\", we're talking about a layer that prepares data for presentation (creating a JSON output, for example) and interprets user interaction (receives the service call, figures out what it means, and calls the appropriate functionality in the Domain (if present) or Data layers.) The User-Interface Layer only depends on the Domain Layer (if present) or the Data Layer . This is somewhat controversial; some want to allow the User-Interface Layer to use the Domain Layer for complex operations, and skip past it directly access the Data Layer for simpler operations. The problem here is that it's possible to miss added value in the Domain Layer with this approach. Suppose you have a Domain Layer that exposes macro operations to the User-Interface Layer , and also passes-through primitive operations from the Data Layer . If we allow the User-Interface Layer a choice of which layer it wants to work with, it may miss changes that the Domain Layer makes. For example, later on, as part of the simpler pass-throughs, if the Domain Layer adds some logging and verification (that the Data Layer doesn't have), it will be missed if the User-Interface Layer skipped around the Domain Layer to directly communicate with the Data Layer . When using a Domain Layer , all User-Interface Layer modules must only depend on modules in the Domain Layer . Data Layer Let's dive a little deeper into the Data Layer . The most basic part of the Data Layer is a Data Source . This is where you access your data. It could be a local or remote database, a web service, a file or another place to store your data. The data in this layer is usually persisted so it can be accessed across runs of the application. Sometimes your application may use more than one data source. For example, if your application managed contacts, they might be stored in a server for access across devices. To reduce the user's network use, you may also have a local database that stores any contacts that have been previously accessed. So how do you decide which data source to use? Add a repository module. A repository can act as a switch between data sources. If the repository is asked for a contact, it checks to see if it's in the local-database data source. If so, it just returns it; no network communication needed! If not, it grabs the contact from the network, stores it in the local database, then returns it. (We're ignoring data that's been changed on the server in this example, but there are other technologies that make that easy to manage.) flowchart LR other[User Interface/Domain Layer] --> repo ds1 --> db[(Database)] ds2 --> file(((File))) ds3 --> ws(((Web Service))) subgraph Data Layer direction LR repo[Repository] --> ds1[Data Source 1] repo[Repository] --> ds2[Data Source 2] repo[Repository] --> ds3[Data Source 3] end (Arrows represent dependencies) The repository can also perform another useful function - convert data that's used directly by a data source to data that can be returned to other layers. This conversion can limit which data is available to other layers (hiding data that you don't want to expose) add new data that's derived from a data source or pulled in from other sources change the accessibility of data, commonly making it immutable return objects that implement interfaces required by other layers One of the most important things we'll learn about our User-Interface Layer is that immutable data makes everything more reliable and can help frameworks like Jetpack Compose optimize what needs to be refreshed. Immutable data stops its users for directly modifying it; they must use other functions to make changes, functions that will then know that changes are being made. This allows for easy enforcement of Unidirectional Data Flow , which we'll talk about later. The repository copies the data from the actual data objects (often known as \"entities\") and creates Data Transfer Objects (DTOs) to carry that data. DTOs are often immutable , and can also restrict which data is visible or enhance the data with derived properties. DTOs may be a simple wrapper (an \"Adapter\" in design-pattern parlance), or an entirely-separate object that holds a copy of the data. Using a repository helps abstract the way the data is accessed outside the Data Layer . Depending on your level of abstraction, this may result in better isolation between the layers. Changes to how you store data become less likely to force changes outside the Data Layer . Note \"Less likely\" depends on the amount of abstraction used when exposing data from the data layer, and this is a tradeoff. Higher abstraction requires more types (interfaces and/or classes) to be defined and maintained and reduces required external changes. Lower abstraction (such as directly passing data that's managed by your database) is less to develop and maintain, but requires more to change outside the layer when data-later internals change. Think about how likely change is in your application. Is it likely you'll switch data sources? Is it likely the app will only be an Android application, or might you want to use parts of it in a desktop or web application? (Eventually, I think that Kotlin Multiplatform [KMP] will also allow easy reuse of much of your code on iOS as well.) Domain Layer The Domain Layer is optional, and we won't be using it in this class. It's overkill for small applications. As your applications grow, it becomes a much more useful. flowchart LR ui[User Interface Layer] ui --> uc1 ui --> uc2 ui --> uc3 ui --> data data --> repo uc1 --> repo uc2 --> repo uc3 --> repo ds1 --> db[(Database)] ds2 --> file(((File))) ds3 --> ws(((Web Service))) subgraph Domain Layer direction LR data[Data] uc1[Use Case 1] uc2[Use Case 2] uc3[Use Case 3] end subgraph Data Layer direction LR repo[Repository] --> ds1[Data Source 1] repo[Repository] --> ds2[Data Source 2] repo[Repository] --> ds3[Data Source 3] end (Arrows represent dependencies) The gist of this layer is that is exposes data from the Data Layer along with Use Cases for common data modifications. For more detail on the Domain Layer , please see https://developer.android.com/topic/architecture/domain-layer . You may also be interested in learning about \"Clean Architecture\", which explains the use of a Domain Layer . Be careful though - adding a Domain Layer can increase the complexity of a smaller app and make its maintenance burdensome - you'll have to find that line, and much of depends on how many developers will be working on the same application. If only a few, it's best to keep it simple. If many developers on a larger application, the extra separation and explicit use cases can be a great help. User-Interface Layer The User Interface Layer is likely where most of your changes will happen, and will usually involve much more detailed code. There are two major concepts in this layer: State - the data used to present the user interface User Interface - the means of allowing the user to consume and interact with the data State State includes data from other layers as well as data that's only used for controlling the user interface. If you have an application that's displaying contact information, the contact data comes from the other layers and is the \"what\" that you want to display. But you'll also need other information such as What screen is user seeing? Which position in a list is at the top? What field currently has focus? Some data only makes sense for a specific user interface. It's easiest to determine which data this is if you ask yourself \"would I need this data for a graphical user interface, a command-line interface, and a web service?\" If so, the data likely belongs in the Data Layer . Otherwise, the data only exists in the User-Interface Layer . Our goals in the User-Interface Layer are to Observe state changes Prepare our state for presentation to the user Interpret user interaction Update the state as needed (which will trigger our observers) We'll be using Jetpack Compose as our user interface in this class.Compose has great state-management support, often making the state observation invisible, but sometimes it can be tricky to set up. We'll work through several types of state use in this class, but be aware that best practices for state are still being developed and may change from what I present. Keep an eye on https://developer.android.com/ site and the https://android-developers.googleblog.com/ blog for emerging details. As part of the User-Interface Layer responsibilities, we need to prepare and update state. This function is usually managed by a View Model . View Models The concept of a View Model is simple - it's a place to manage state preparation and updates. Without Domain Layer With Domain Layer flowchart LR subgraph User Interface Layer ui[User Interface] --> vm[View Model] end vm --> repo ds1 --> db[(Database)] ds2 --> file(((File))) ds3 --> ws(((Web Service))) subgraph Data Layer direction LR repo[Repository] --> ds1[Data Source 1] repo[Repository] --> ds2[Data Source 2] repo[Repository] --> ds3[Data Source 3] end flowchart LR subgraph User Interface Layer ui[User Interface] --> vm[View Model] end vm --> uc1 vm --> uc2 vm --> uc3 vm --> data uc1 --> repo uc2 --> repo uc3 --> repo data --> repo ds1 --> db[(Database)] ds2 --> file(((File))) ds3 --> ws(((Web Service))) subgraph Domain Layer direction LR data[Data] uc1[Use Case 1] uc2[Use Case 2] uc3[Use Case 3] end subgraph Data Layer direction LR repo[Repository] --> ds1[Data Source 1] repo[Repository] --> ds2[Data Source 2] repo[Repository] --> ds3[Data Source 3] end (Arrows represent dependencies) Note You may have multiple view models. Some developers prefer one view model per screen, others prefer by types of data, and others prefer a single view model. The decision often depends on the size of the application as well. A view model creates state to be used by the user interface. In some cases, it may just pass the state along. In other cases, it may modify or combine state from underlying layers. View model functions allow the user interface to tell it what the user wants to do, such as adding/deleting a contact or switching to a different screen. These functions will interact with the Domain Layer (if present) or Data Layer to update the data. The view model needs to expose the state in a way that the user interface can observe it. Depending on the UI framework being used, the state might be exposed using the Observer pattern, using Android LiveData , Jetpack Compose State objects, Kotlin Flow s or other approaches. For our work, we'll be using Kotlin Flow s and Compose State s. We'll talk about what those are in later modules. Composable Functions For our user interfaces, we'll use Jetpack Compose to declare our user interface. In a nutshell, you'll create Composable functions in Kotlin. These functions will emit descriptions of parts of the user interface to a tree. The Compose UI framework will look at this tree and create a user interface. The cool thing is that Compose can watch the parameters passed to a Composable function. If the values change from one call to the next, it will recompose , emitting a replacement for the part of the tree that it previously emitted. The Compose UI will then detect changes and refresh only the parts of the UI that need to be refreshed. Data Objects Different types of data flow between different parts of the application. Your application may use Raw data - data obtained in its raw form from a database, file, service, etcetera. The data source formats it into an object to be passed back to the repository Entities - data obtained from data sources Data Transfer Objects (DTOs) - data abstracted/restricted before being passed out of the Data Layer State - data prepared for use in the user interface A typical flow of data might look like Without Domain Layer With Domain Layer flowchart RL subgraph User Interface Layer vm[View Model] -->|State| ui[User Interface] end repo -->|DTO| vm db[(Database)] -->|raw| ds subgraph Data Layer ds[Data Source] -->|Entity| repo[Repository] end flowchart RL subgraph User Interface Layer vm[View Model] -->|State| ui[User Interface] end Data data -->|DTO| vm repo -->|DTO| data db[(Database)] -->|raw| ds subgraph Domain Layer direction TB data[Data] uc[Use Case] end subgraph Data Layer ds[Data Source] -->|Entity| repo[Repository] end Events So how do we make changes? That's where events come in. The user interface receives user interactions, such as key and button presses, and interprets their meaning. It then calls Event functions to trigger state changes. When using Jetpack Compose , these event functions are typically Kotlin lambdas passed into the functions we use to create the user interface. Most of these lambdas will call functions in the view model; others may update some local state in the user interface itself. Without Domain Layer With Domain Layer flowchart LR subgraph User Interface Layer ui[User Interface] -->|\"event()\"| vm[View Model] end vm -->|\"update()\"| repo ds -->|query| db[(Database)] subgraph Data Layer repo[Repository] -->|\"update()\"| ds[Data Source] end flowchart LR subgraph User Interface Layer ui[User Interface] -->|\"event()\"| vm[View Model] end vm -->|\"update()\"| uc uc -->|\"update()\"| repo ds -->|query| db[(Database)] subgraph Domain Layer direction TB data[Data] uc[Use Case] end subgraph Data Layer repo[Repository] -->|\"update()\"| ds[Data Source] end We'll see how this works when we start coding our user interface. Concurrency User interfaces are typically updated via a single thread. That thread is responsible for drawing any needed changes and responding to user interactions. The UI should respond immediately to interactions such as pressing a button, scrolling the screen, or drawing pictures with their finger. Many user actions result in performing data updates, which can be expensive. If we perform these actions on the same thread that detected the user interaction, all screen updates are blocked until that update has completed. At best, this can result in \"jank\", an interface that doesn't immediately respond and jumps between drawn frames. At worst, an update might take long enough that the user interface freezes. The easiest fix for this is to run data updates on a different thread so the user interface can keep responding immediately. We'll do this using Kotlin Coroutines, but it could also be done using threads and executors. While the UI is now responsive, we can run into data synchronization, race and deadlock issues. Fortunately there are several patterns we can follow to more reliably work with concurrent processing. One of the most effective ways to help is to use a Unidirectional Data Flow , or UDF. Unidirectional Data Flow By passing data into functions, and receiving event calls out , we remove the possibility of data changing while it's being read. Jetpack Compose's Composable functions take parameters for data and events. For example, we might define a \"submit button\" function: @Composable fun Submit ( buttonText : String , onButtonPress : () -> Unit , ) { ... } Note The convention for Composable functions that emit ui nodes to the tree is that they are named using UpperCamelCase() . This feels a bit weird, but the idea is that we're treating these functions as declarations of what the ui looks like, not imperative code to build a UI. Declarations feel more like class or interface definitions, hence the case. The buttonText is data coming in; the Submit() function will emit a button to the tree that displays that text. Submit() will also attach a \"click listener\" to the button. When the button is pressed, it will call onButtonPress() to tell the caller of Submit() that the button was pressed. Data comes in; events go out. That's Unidirectional Data Flow . Somewhere up at the top of the call chain, a lambda is passed in to be used as that onButtonPress parameter, and it contains the code to perform the update. That lambda should immediately switch to a different thread to perform its work. We'll do this by launching a coroutine to perform the work. At the end of the coroutine, new data will be set for the state and passed in. For this example, if the new state contains the buttonText that's passed into SubmitButton() , the UI will be updated. We'll dig into this when we start talking about Jetpack Compose . For now, all you need to know is we'll be pushing data and event functions into the Composable functions, and call the event functions to indicate that something has changed.","title":"Architecture"},{"location":"week-02/2.3-Architecture/index.html#architecture-overview","text":"Applications are structured as Layers and Modules . A \"module\" is a separately-compilable group of code and resources that can be consumed by other modules in your system. They're useful for isolating functionality, internal implementation details can be hidden while exposing a subset of function, its public API (Application Programming Interface). Separating code into modules also helps large applications isolate changes that many developers are making at the same time. A \"layer\" is a grouping of one or more modules with certain responsibilities. Layers allow you to explicitly define communication between modules and further improve ease of maintenance. Application Layers graph TD UI[User-Interface Layer] -->|depends on| Domain Domain[Domain Layer] -->|depends on| Data[Data Layer] At a high level, we talk about application layers , separating data from its manipulation and presentation. Each layer isolates a responsibility in the application. At its simplest, each layer could be exactly one module. (While layers could be just conceptual grouping of code/resources that are all in a single module, using at least one module per layer gives us the ability to restrict what's exposed between layers.) Layers could contain multiple modules, which I recommend as the application grows in size. The Data Layer manages data acquisition and update. You can use it to persist data locally in a database, file or in memory. Or maybe your application connects to a server for its data; you can use the Data Layer to connect to a server to grab data and push changes. By keeping your data access code inside the Data Layer , you can abstract and hide the how data is accessed from the rest of the application. If your data management code changes over time, the rest of the application may require fewer changes to adapt. Operations in the Data Layer are sometimes called Primitive Operations , as they're the core, often simplest, operations you define on your data. Many primitive operations are simply property changes to objects and CRUD operations (Create/Read/Update/Delete) against your data store. You may also define more complex operations that are always needed for any user of the data. The Data Layer doesn't depend upon other architectural layers, but may depend upon other modules/libraries such as database storage or network communication. The Domain Layer is an optional layer that increases in value as the size of your application grows. Often you'll find that several parts of your application need to perform the same sequences of primitive operations. For example, a game might have several places that put an item in the player's inventory. It would be a great idea to create a function to contain the repeated code, but where do we put that function? In a smaller application, you could add a function in the User-Interface Layer , and you've successfully factored out that common functionality. As the application grows, the user interface might be broken down into multiple modules. Which UI module should host that functionality? Or if you want to use the same \"put item in inventory\" for an Android application, desktop application, and web application, you no longer have a common user interface to host it. A Domain Layer hosts this type of common functionality and gives you access from any user interface components, within the same application or across multiple applications. These types of operations are generally called \"macro operations\". They build upon primitive operations by combining primitives to create more complex processing of the data. In recent architectures, these types of operations are called Use Cases or Interactors . The Domain Layer only depends upon the architectural Data Layer for access to its data. It can also depend upon other modules/libraries that provide frameworks, algorithms or support functions to work with the data. Finally, we use our User-Interface Layer to present data to the user and interpret their actions. This layer can present the data using many different approaches: graphically, textually, as a service, or using assistive technologies for example. Note I've called out \"as a service\" as a type of User-Interface implementation. Think about what it means to be a \"user\". The \"outsider\" that's interacting with your application is its user. That could be a person, or it could be other applications. When we think of a service (such as a web service) as a \"user interface\", we're talking about a layer that prepares data for presentation (creating a JSON output, for example) and interprets user interaction (receives the service call, figures out what it means, and calls the appropriate functionality in the Domain (if present) or Data layers.) The User-Interface Layer only depends on the Domain Layer (if present) or the Data Layer . This is somewhat controversial; some want to allow the User-Interface Layer to use the Domain Layer for complex operations, and skip past it directly access the Data Layer for simpler operations. The problem here is that it's possible to miss added value in the Domain Layer with this approach. Suppose you have a Domain Layer that exposes macro operations to the User-Interface Layer , and also passes-through primitive operations from the Data Layer . If we allow the User-Interface Layer a choice of which layer it wants to work with, it may miss changes that the Domain Layer makes. For example, later on, as part of the simpler pass-throughs, if the Domain Layer adds some logging and verification (that the Data Layer doesn't have), it will be missed if the User-Interface Layer skipped around the Domain Layer to directly communicate with the Data Layer . When using a Domain Layer , all User-Interface Layer modules must only depend on modules in the Domain Layer .","title":"Architecture Overview"},{"location":"week-02/2.3-Architecture/index.html#data-layer","text":"Let's dive a little deeper into the Data Layer . The most basic part of the Data Layer is a Data Source . This is where you access your data. It could be a local or remote database, a web service, a file or another place to store your data. The data in this layer is usually persisted so it can be accessed across runs of the application. Sometimes your application may use more than one data source. For example, if your application managed contacts, they might be stored in a server for access across devices. To reduce the user's network use, you may also have a local database that stores any contacts that have been previously accessed. So how do you decide which data source to use? Add a repository module. A repository can act as a switch between data sources. If the repository is asked for a contact, it checks to see if it's in the local-database data source. If so, it just returns it; no network communication needed! If not, it grabs the contact from the network, stores it in the local database, then returns it. (We're ignoring data that's been changed on the server in this example, but there are other technologies that make that easy to manage.) flowchart LR other[User Interface/Domain Layer] --> repo ds1 --> db[(Database)] ds2 --> file(((File))) ds3 --> ws(((Web Service))) subgraph Data Layer direction LR repo[Repository] --> ds1[Data Source 1] repo[Repository] --> ds2[Data Source 2] repo[Repository] --> ds3[Data Source 3] end (Arrows represent dependencies) The repository can also perform another useful function - convert data that's used directly by a data source to data that can be returned to other layers. This conversion can limit which data is available to other layers (hiding data that you don't want to expose) add new data that's derived from a data source or pulled in from other sources change the accessibility of data, commonly making it immutable return objects that implement interfaces required by other layers One of the most important things we'll learn about our User-Interface Layer is that immutable data makes everything more reliable and can help frameworks like Jetpack Compose optimize what needs to be refreshed. Immutable data stops its users for directly modifying it; they must use other functions to make changes, functions that will then know that changes are being made. This allows for easy enforcement of Unidirectional Data Flow , which we'll talk about later. The repository copies the data from the actual data objects (often known as \"entities\") and creates Data Transfer Objects (DTOs) to carry that data. DTOs are often immutable , and can also restrict which data is visible or enhance the data with derived properties. DTOs may be a simple wrapper (an \"Adapter\" in design-pattern parlance), or an entirely-separate object that holds a copy of the data. Using a repository helps abstract the way the data is accessed outside the Data Layer . Depending on your level of abstraction, this may result in better isolation between the layers. Changes to how you store data become less likely to force changes outside the Data Layer . Note \"Less likely\" depends on the amount of abstraction used when exposing data from the data layer, and this is a tradeoff. Higher abstraction requires more types (interfaces and/or classes) to be defined and maintained and reduces required external changes. Lower abstraction (such as directly passing data that's managed by your database) is less to develop and maintain, but requires more to change outside the layer when data-later internals change. Think about how likely change is in your application. Is it likely you'll switch data sources? Is it likely the app will only be an Android application, or might you want to use parts of it in a desktop or web application? (Eventually, I think that Kotlin Multiplatform [KMP] will also allow easy reuse of much of your code on iOS as well.)","title":"Data Layer"},{"location":"week-02/2.3-Architecture/index.html#domain-layer","text":"The Domain Layer is optional, and we won't be using it in this class. It's overkill for small applications. As your applications grow, it becomes a much more useful. flowchart LR ui[User Interface Layer] ui --> uc1 ui --> uc2 ui --> uc3 ui --> data data --> repo uc1 --> repo uc2 --> repo uc3 --> repo ds1 --> db[(Database)] ds2 --> file(((File))) ds3 --> ws(((Web Service))) subgraph Domain Layer direction LR data[Data] uc1[Use Case 1] uc2[Use Case 2] uc3[Use Case 3] end subgraph Data Layer direction LR repo[Repository] --> ds1[Data Source 1] repo[Repository] --> ds2[Data Source 2] repo[Repository] --> ds3[Data Source 3] end (Arrows represent dependencies) The gist of this layer is that is exposes data from the Data Layer along with Use Cases for common data modifications. For more detail on the Domain Layer , please see https://developer.android.com/topic/architecture/domain-layer . You may also be interested in learning about \"Clean Architecture\", which explains the use of a Domain Layer . Be careful though - adding a Domain Layer can increase the complexity of a smaller app and make its maintenance burdensome - you'll have to find that line, and much of depends on how many developers will be working on the same application. If only a few, it's best to keep it simple. If many developers on a larger application, the extra separation and explicit use cases can be a great help.","title":"Domain Layer"},{"location":"week-02/2.3-Architecture/index.html#user-interface-layer","text":"The User Interface Layer is likely where most of your changes will happen, and will usually involve much more detailed code. There are two major concepts in this layer: State - the data used to present the user interface User Interface - the means of allowing the user to consume and interact with the data","title":"User-Interface Layer"},{"location":"week-02/2.3-Architecture/index.html#state","text":"State includes data from other layers as well as data that's only used for controlling the user interface. If you have an application that's displaying contact information, the contact data comes from the other layers and is the \"what\" that you want to display. But you'll also need other information such as What screen is user seeing? Which position in a list is at the top? What field currently has focus? Some data only makes sense for a specific user interface. It's easiest to determine which data this is if you ask yourself \"would I need this data for a graphical user interface, a command-line interface, and a web service?\" If so, the data likely belongs in the Data Layer . Otherwise, the data only exists in the User-Interface Layer . Our goals in the User-Interface Layer are to Observe state changes Prepare our state for presentation to the user Interpret user interaction Update the state as needed (which will trigger our observers) We'll be using Jetpack Compose as our user interface in this class.Compose has great state-management support, often making the state observation invisible, but sometimes it can be tricky to set up. We'll work through several types of state use in this class, but be aware that best practices for state are still being developed and may change from what I present. Keep an eye on https://developer.android.com/ site and the https://android-developers.googleblog.com/ blog for emerging details. As part of the User-Interface Layer responsibilities, we need to prepare and update state. This function is usually managed by a View Model .","title":"State"},{"location":"week-02/2.3-Architecture/index.html#view-models","text":"The concept of a View Model is simple - it's a place to manage state preparation and updates. Without Domain Layer With Domain Layer flowchart LR subgraph User Interface Layer ui[User Interface] --> vm[View Model] end vm --> repo ds1 --> db[(Database)] ds2 --> file(((File))) ds3 --> ws(((Web Service))) subgraph Data Layer direction LR repo[Repository] --> ds1[Data Source 1] repo[Repository] --> ds2[Data Source 2] repo[Repository] --> ds3[Data Source 3] end flowchart LR subgraph User Interface Layer ui[User Interface] --> vm[View Model] end vm --> uc1 vm --> uc2 vm --> uc3 vm --> data uc1 --> repo uc2 --> repo uc3 --> repo data --> repo ds1 --> db[(Database)] ds2 --> file(((File))) ds3 --> ws(((Web Service))) subgraph Domain Layer direction LR data[Data] uc1[Use Case 1] uc2[Use Case 2] uc3[Use Case 3] end subgraph Data Layer direction LR repo[Repository] --> ds1[Data Source 1] repo[Repository] --> ds2[Data Source 2] repo[Repository] --> ds3[Data Source 3] end (Arrows represent dependencies) Note You may have multiple view models. Some developers prefer one view model per screen, others prefer by types of data, and others prefer a single view model. The decision often depends on the size of the application as well. A view model creates state to be used by the user interface. In some cases, it may just pass the state along. In other cases, it may modify or combine state from underlying layers. View model functions allow the user interface to tell it what the user wants to do, such as adding/deleting a contact or switching to a different screen. These functions will interact with the Domain Layer (if present) or Data Layer to update the data. The view model needs to expose the state in a way that the user interface can observe it. Depending on the UI framework being used, the state might be exposed using the Observer pattern, using Android LiveData , Jetpack Compose State objects, Kotlin Flow s or other approaches. For our work, we'll be using Kotlin Flow s and Compose State s. We'll talk about what those are in later modules.","title":"View Models"},{"location":"week-02/2.3-Architecture/index.html#composable-functions","text":"For our user interfaces, we'll use Jetpack Compose to declare our user interface. In a nutshell, you'll create Composable functions in Kotlin. These functions will emit descriptions of parts of the user interface to a tree. The Compose UI framework will look at this tree and create a user interface. The cool thing is that Compose can watch the parameters passed to a Composable function. If the values change from one call to the next, it will recompose , emitting a replacement for the part of the tree that it previously emitted. The Compose UI will then detect changes and refresh only the parts of the UI that need to be refreshed.","title":"Composable Functions"},{"location":"week-02/2.3-Architecture/index.html#data-objects","text":"Different types of data flow between different parts of the application. Your application may use Raw data - data obtained in its raw form from a database, file, service, etcetera. The data source formats it into an object to be passed back to the repository Entities - data obtained from data sources Data Transfer Objects (DTOs) - data abstracted/restricted before being passed out of the Data Layer State - data prepared for use in the user interface A typical flow of data might look like Without Domain Layer With Domain Layer flowchart RL subgraph User Interface Layer vm[View Model] -->|State| ui[User Interface] end repo -->|DTO| vm db[(Database)] -->|raw| ds subgraph Data Layer ds[Data Source] -->|Entity| repo[Repository] end flowchart RL subgraph User Interface Layer vm[View Model] -->|State| ui[User Interface] end Data data -->|DTO| vm repo -->|DTO| data db[(Database)] -->|raw| ds subgraph Domain Layer direction TB data[Data] uc[Use Case] end subgraph Data Layer ds[Data Source] -->|Entity| repo[Repository] end","title":"Data Objects"},{"location":"week-02/2.3-Architecture/index.html#events","text":"So how do we make changes? That's where events come in. The user interface receives user interactions, such as key and button presses, and interprets their meaning. It then calls Event functions to trigger state changes. When using Jetpack Compose , these event functions are typically Kotlin lambdas passed into the functions we use to create the user interface. Most of these lambdas will call functions in the view model; others may update some local state in the user interface itself. Without Domain Layer With Domain Layer flowchart LR subgraph User Interface Layer ui[User Interface] -->|\"event()\"| vm[View Model] end vm -->|\"update()\"| repo ds -->|query| db[(Database)] subgraph Data Layer repo[Repository] -->|\"update()\"| ds[Data Source] end flowchart LR subgraph User Interface Layer ui[User Interface] -->|\"event()\"| vm[View Model] end vm -->|\"update()\"| uc uc -->|\"update()\"| repo ds -->|query| db[(Database)] subgraph Domain Layer direction TB data[Data] uc[Use Case] end subgraph Data Layer repo[Repository] -->|\"update()\"| ds[Data Source] end We'll see how this works when we start coding our user interface.","title":"Events"},{"location":"week-02/2.3-Architecture/index.html#concurrency","text":"User interfaces are typically updated via a single thread. That thread is responsible for drawing any needed changes and responding to user interactions. The UI should respond immediately to interactions such as pressing a button, scrolling the screen, or drawing pictures with their finger. Many user actions result in performing data updates, which can be expensive. If we perform these actions on the same thread that detected the user interaction, all screen updates are blocked until that update has completed. At best, this can result in \"jank\", an interface that doesn't immediately respond and jumps between drawn frames. At worst, an update might take long enough that the user interface freezes. The easiest fix for this is to run data updates on a different thread so the user interface can keep responding immediately. We'll do this using Kotlin Coroutines, but it could also be done using threads and executors. While the UI is now responsive, we can run into data synchronization, race and deadlock issues. Fortunately there are several patterns we can follow to more reliably work with concurrent processing. One of the most effective ways to help is to use a Unidirectional Data Flow , or UDF.","title":"Concurrency"},{"location":"week-02/2.3-Architecture/index.html#unidirectional-data-flow","text":"By passing data into functions, and receiving event calls out , we remove the possibility of data changing while it's being read. Jetpack Compose's Composable functions take parameters for data and events. For example, we might define a \"submit button\" function: @Composable fun Submit ( buttonText : String , onButtonPress : () -> Unit , ) { ... } Note The convention for Composable functions that emit ui nodes to the tree is that they are named using UpperCamelCase() . This feels a bit weird, but the idea is that we're treating these functions as declarations of what the ui looks like, not imperative code to build a UI. Declarations feel more like class or interface definitions, hence the case. The buttonText is data coming in; the Submit() function will emit a button to the tree that displays that text. Submit() will also attach a \"click listener\" to the button. When the button is pressed, it will call onButtonPress() to tell the caller of Submit() that the button was pressed. Data comes in; events go out. That's Unidirectional Data Flow . Somewhere up at the top of the call chain, a lambda is passed in to be used as that onButtonPress parameter, and it contains the code to perform the update. That lambda should immediately switch to a different thread to perform its work. We'll do this by launching a coroutine to perform the work. At the end of the coroutine, new data will be set for the state and passed in. For this example, if the new state contains the buttonText that's passed into SubmitButton() , the UI will be updated. We'll dig into this when we start talking about Jetpack Compose . For now, all you need to know is we'll be pushing data and event functions into the Composable functions, and call the event functions to indicate that something has changed.","title":"Unidirectional Data Flow"},{"location":"week-03/3.1-Room/index.html","text":"Each \"thing\" that you want to represent in your database is called an \"Entity\". Each entity has attributes, the data that describes it. In a Relational Database , each entity is represented by one row in a database table. The attributes are held in columns of the table. For these examples, we'll define \"Person\", \"Birth Certificate\", \"Organ\" and \"Address\" entities with the following attributes. In the \"Key\" column, you'll see three possible values: (blank) the attribute is not a key PK - represents a Primary Key, a value that must be unique in the table storing the entity. This is typically a unique identifier for an entity. FK - represents a Foreign Key, a primary key in some other table that we're associated with. In this example, I'm representing primary keys using Strings. I chose Strings here because mobile applications may synchronize their data between mobile devices and servers (or even other mobile devices). If entities can be created on mobile devices, possibly while not connected to a server, we can use a UUID ( Universally Unique Identifier ) to ensure we don't have collisions between ids created on different mobile devices at the same time. We'll see examples of this later. Person Attribute Type Key Comment id String PK Unique identifier name String name of the person ssn String social security number Organ Attribute Type Key Comment id String PK Unique identifier personId String FK id of owning person type String type of organ Birth Certificate Attribute Type Key Comment id String PK Unique identifier personId String FK id of owning person timeOfBirth long birth time in millis Address Attribute Type Key Comment id String PK Unique identifier street String city String state String zip String","title":"Entities"},{"location":"week-03/3.1-Room/index.html#person","text":"Attribute Type Key Comment id String PK Unique identifier name String name of the person ssn String social security number","title":"Person"},{"location":"week-03/3.1-Room/index.html#organ","text":"Attribute Type Key Comment id String PK Unique identifier personId String FK id of owning person type String type of organ","title":"Organ"},{"location":"week-03/3.1-Room/index.html#birth-certificate","text":"Attribute Type Key Comment id String PK Unique identifier personId String FK id of owning person timeOfBirth long birth time in millis","title":"Birth Certificate"},{"location":"week-03/3.1-Room/index.html#address","text":"Attribute Type Key Comment id String PK Unique identifier street String city String state String zip String","title":"Address"},{"location":"week-03/3.1-Room/STEP_10_FULL.html","text":"Entities can be related to other entities in the same or other tables. These relationships ca be One-to-one: One instance of an entity relates to exactly one instance other entity One-to-many: One instance of entity relates to multiple instances of another entity Many-to-Many: Multiple instances of an entity can be related to multiple instances of another entity These relationships are easiest to understand through examples One to One In our database, each Person can have exactly one Birth Certificate. Each Birth Certificate is owned by exactly one person. erDiagram PERSON ||--|| BIRTH-CERTIFICATE : born This relationship is often used for extra/optional data. While we could add the birth certificate details directly to the person, putting it in a separate entity allows that data to be optional, or easily moved to a different entity. Using one-to-one relationships, we can gradually attach more data to an entity as our system grows with new function. There are several ways to represent this, but we typically define an attribute in one of the entities that holds the id of the other entity. This attribute is called a Foreign Key, as it's a key in another entity. Usually you'll put this attribute in the entity that feels like it's \"owned\" by the other entity (if the relationship feels like that). In this example, the Person owns the Birth Certificate, so we put a Foreign Key called personId in the Birth Certificate. One to Many Often we'll need to have more than one entity attached/owned by an entity. In our example, a Person has organs, and those organs are only associated with that specific person. erDiagram PERSON ||--|{ ORGAN : has-organ By making Organ a separate entity, we can attach any number of Organs to a Person by defining a personId foreign key in the Organ entity. We can even donate organs to another Person entity by just changing the value of that foreign key. The donate organ can only belong to one Person at a time. Many to Many The real fun begins when entities can be shared. Think about an address as representing a home, office, hotel room, and so on. Each Person entity could be associated with multiple Address entities. Each Address entity could be associated with multiple Person entities. erDiagram PERSON }o--o{ ADDRESS : has-address This relationship is trickier to represent - we cannot simply add a foreign key to either entity; we need to create a table to represent the linkage. We can create an Person-Address table to relate each person/address pair Attribute Type Key Comment personId String FK The ID of the related person addressId String FK The ID of the related address In this case, the combination of the personId and addressId create a unique key for a row in the Person-Address table. Associative Entities Sometimes, a many-to-many relationship requires additional information describing the relationship itself. When we defined that Person-Address table above to represent the many-to-many relationship, we can add more columns to it for that extra information. Because we now have data we care about attached to the relationship, we now think of that Person-Address as an entity, and can link the three entities: erDiagram PERSON ||--o{ PERSON-ADDRESS : has-address PERSON-ADDRESS }o--|| ADDRESS: has-address The many-to-many relationship now looks like two one-to-many relationships: One Person can have zero or more Person-Addresses One Address can have zero or more Person-Addresses One Person-Address can have exactly one Person and one Address The Person-Address Entity now looks like Attribute Type Key Comment personId String FK The ID of the related person addressId String FK The ID of the related address type String The type of address (home, work...) Full Example We can put them all together in a single diagram erDiagram PERSON ||--|| BIRTH-CERTIFICATE : born PERSON ||--|{ ORGAN : has-organ PERSON }o--|| PERSON-ADDRESS : has-address PERSON-ADDRESS ||--|{ ADDRESS: has-address","title":"Relationships"},{"location":"week-03/3.1-Room/STEP_10_FULL.html#one-to-one","text":"In our database, each Person can have exactly one Birth Certificate. Each Birth Certificate is owned by exactly one person. erDiagram PERSON ||--|| BIRTH-CERTIFICATE : born This relationship is often used for extra/optional data. While we could add the birth certificate details directly to the person, putting it in a separate entity allows that data to be optional, or easily moved to a different entity. Using one-to-one relationships, we can gradually attach more data to an entity as our system grows with new function. There are several ways to represent this, but we typically define an attribute in one of the entities that holds the id of the other entity. This attribute is called a Foreign Key, as it's a key in another entity. Usually you'll put this attribute in the entity that feels like it's \"owned\" by the other entity (if the relationship feels like that). In this example, the Person owns the Birth Certificate, so we put a Foreign Key called personId in the Birth Certificate.","title":"One to One"},{"location":"week-03/3.1-Room/STEP_10_FULL.html#one-to-many","text":"Often we'll need to have more than one entity attached/owned by an entity. In our example, a Person has organs, and those organs are only associated with that specific person. erDiagram PERSON ||--|{ ORGAN : has-organ By making Organ a separate entity, we can attach any number of Organs to a Person by defining a personId foreign key in the Organ entity. We can even donate organs to another Person entity by just changing the value of that foreign key. The donate organ can only belong to one Person at a time.","title":"One to Many"},{"location":"week-03/3.1-Room/STEP_10_FULL.html#many-to-many","text":"The real fun begins when entities can be shared. Think about an address as representing a home, office, hotel room, and so on. Each Person entity could be associated with multiple Address entities. Each Address entity could be associated with multiple Person entities. erDiagram PERSON }o--o{ ADDRESS : has-address This relationship is trickier to represent - we cannot simply add a foreign key to either entity; we need to create a table to represent the linkage. We can create an Person-Address table to relate each person/address pair Attribute Type Key Comment personId String FK The ID of the related person addressId String FK The ID of the related address In this case, the combination of the personId and addressId create a unique key for a row in the Person-Address table.","title":"Many to Many"},{"location":"week-03/3.1-Room/STEP_10_FULL.html#associative-entities","text":"Sometimes, a many-to-many relationship requires additional information describing the relationship itself. When we defined that Person-Address table above to represent the many-to-many relationship, we can add more columns to it for that extra information. Because we now have data we care about attached to the relationship, we now think of that Person-Address as an entity, and can link the three entities: erDiagram PERSON ||--o{ PERSON-ADDRESS : has-address PERSON-ADDRESS }o--|| ADDRESS: has-address The many-to-many relationship now looks like two one-to-many relationships: One Person can have zero or more Person-Addresses One Address can have zero or more Person-Addresses One Person-Address can have exactly one Person and one Address The Person-Address Entity now looks like Attribute Type Key Comment personId String FK The ID of the related person addressId String FK The ID of the related address type String The type of address (home, work...)","title":"Associative Entities"},{"location":"week-03/3.1-Room/STEP_10_FULL.html#full-example","text":"We can put them all together in a single diagram erDiagram PERSON ||--|| BIRTH-CERTIFICATE : born PERSON ||--|{ ORGAN : has-organ PERSON }o--|| PERSON-ADDRESS : has-address PERSON-ADDRESS ||--|{ ADDRESS: has-address","title":"Full Example"},{"location":"week-03/3.1-Room/STEP_20_FULL.html","text":"Room is a simple Object-Relational-Mapping (aka ORM ) framework for Android. ORM s allow you to treat database tables as types in your programming language. Some require external definitions of your database and types. Others create databases and the access code by examining your types, which may include extra metadata such as annotations. Room takes the annotated-type approach. You define Entity classes Data-Access-Object interfaces (or abstract classes) Database abstract class and Room can generate the database, tables, and code to access them. When we walk through our movie example, we'll see how to set up the Room compiler as part of our build to process the annotated types and generate code. Note We're just going to show code snippets here; the setup needed for Room, as well as full example code, appears in the Movie Database Example. Entity Let's start by defining a simple entity using Room. @Entity data class Person ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var name : String , var age : Int , var ssn : String , ) We're using a Kotlin Data Class to define the entity type. The @Entity annotation tells the Room compiler to generate a database table and code to convert the class definition to/from a row in that table. The @PrimaryKey annotation tells the Room compiler which attribute represents the unique identifier for the entity. Here we see a Kotlin default value specification - if a caller creates a Person instance and does not specify the id, one will be created for them by generating a random UUID . When you want to create a Person , all you need to do is write val person = Person ( name = \"Scott\" , age = 55 , ssn = \"123-45-6789\" ) You can then use a Data Access Object to store that Person in the database. By default the table name will be the class name, and all columns will be the property names. You can modify this, but we won't go into that detail in this class. If you want more detail, take a look at https://developer.android.com/training/data-storage/room . Data Access Object (DAO) A Data Access Object defines your \"CRUD\" functions. \"CRUD\" stands for \"Create, Read, Update and Delete\", the four types of queries you'll use to access and modify database contents. A simple DAO might look like @Dao interface PersonDao { @Query ( \"SELECT * FROM Person\" ) fun getPeople (): List < Person > @Query ( \"SELECT * FROM Person WHERE id = :id\" ) fun getPerson ( id : String ): Person @Insert fun insert ( vararg people : Person ) @Update fun update ( vararg people : Person ) @Delete fun delete ( vararg people : Person ) @Query ( \"DELETE FROM Person WHERE id IN (:ids)\" ) fun delete ( ids : List < String > ) } Note This is an interface, but you can also define it as an abstract class. The Room compiler will generate an implementation (or subclass) with the details of how to perform the declared functions. Here we're defining some simple CRUD operations for a Person. getPeople() - Returns a list of all Person instances in the table. Note that the specified SQL is just normal SQL, using the entity as the table name. getPerson(id) - Returns a single person with the specified id. The :id syntax is replaced with the id parameter passed to the function. insert(people) - inserts the passed Person instances into the database. By default, this will throw an exception if a passed Person has an id that's already in the table. update(people) - updates the Person table with the values for each passed Person . Will throw an exception if any passed Person doesn't exist. delete(people) - deletes the specified people from the table. delete(ids) - deletes the people with the specified ids from the table. Note that we're using the @Query annotation here to tailor the deletion. Once you have a DAO instance, you just call the functions to access/modify data. Note All of the functions defined in this DAO are synchronous ! You really don't want to call these from the user-interface thread or the UI may become \"janky\" (non-smooth animation, delays in user interaction, etc). Using the above DAO requires you to call the DAO functions from a different thread. We'll see how to do that shortly. We'll also see how to set up asynchronous queries in the DAO. Note You can define separate DAOs for separate entities, but you don't need to. If you don't have a huge number of DAO functions needed for your application, you can define them all in the same DAO interface/abstract class. Database But how do we get an instance of a DAO? That's where the Database class comes in. @Database ( version = 1 , entities = [ Person :: class ], exportSchema = false ) abstract class PersonDatabase : RoomDatabase () { abstract val dao : PersonDao } You define a database class with the @Database annotation, and the class must be abstract and extend RoomDatabase . The Room compiler will generate a subclass that creates the actual DAO instance you'll use to run your queries. By listing the entity classes in the @Database annotation, Room knows which tables it should create. Room also supports database migration (when the entity definitions change), but that's a more advanced topic and not covered in this class.) Usage Now that all the pieces are defined, we can use the database as follows. Note You'd normally put this code in a View Model or Repository class, spread across multiple functions. val database = Room . databaseBuilder ( context , // An Android context, like an Activity, used // to locate the database file on the device PersonDatabase :: class . java , // The database type to create \"PEOPLE\" // The name of the database file ) . build () val person1 = Person ( name = \"Scott\" , age = 55 , ssn = \"123-45-6789\" ) val person2 = Person ( name = \"Mikey\" , age = 10 , ssn = \"234-56-7890\" ) database . dao . insert ( person1 , person2 ) val people = database . dao . getPeople () person1 . age ++ database . dao . update ( person1 ) database . dao . delete ( person2 ) Room.databaseBuilder creates our database for us. Be sure to use only one instance of your database! The database has caching and other code that won't work as expected if you create multiple instances! Because of this, you usually want to hold onto your database in a View Model or Repository, or create the instance using Dependency Injection. Room.databaseBuilder is written in Java, and because of this, you cannot use named parameters or pass the Kotlin KClass ( PersonDatabase::class ) as a parameter. You must pass the Java Class that represents the database by adding .class . The Class is metadata describing the type, and is using to create an instance of the type dynamically at runtime. Once you have a database, you can access the dao and calls its functions. Threading Issues The problem with the code you've seen so far is that it might be invoked on the user interface thread, causing \"jank\", a poor-performing UI. It's important to perform the database processing on another thread. In this class, we'll use Kotlin's coroutines to perform our work. For data-access queries, we'll use Flows , collected in a coroutine. For everything else we'll launch a coroutine to perform the action. I'm going to do a lot of hand-waving on coroutines at this point (imagine you're watching a video with my hands flailing about) and explain them in more detail later in the course. For now, follow the patterns I'll describe and don't worry too much about how things work behind the scenes. For now, think of a coroutine as a helper that will run some code on a specific thread, and can switch to other threads depending on the work you need to run. Coroutines use Dispatchers to manage their execution on different threads. The \"Main\" dispatcher runs code on the user-interface thread. The \"IO\" dispatcher runs potentially blocking code on a set of threads optimized for blocking function calls. The \"Default\" dispatcher runs code on other background threads. Let's say that we want to display a message, fetch 10 items from the database, updating a progress bar and the message for each, then display a \"done\" message. For this type of processing, we need to update the message and progress bar on the UI thread, and fetch the items from the database on a background thread. Our coroutine might look like fun doStuff () { scope . launch ( Dispatchers . Main ) { showMessage ( \"Fetching data...\" ) repeat ( 10 ) { n -> val item = withContext ( Dispatchers . IO ) { fetch ( n ) } showMessage ( item . message ) updateProgress ( n ) } showMessage ( \"All data fetched!\" ) } } Notice how this is just a function, and it looks like normal imperative logic. But it's actually switching threads! And we don't need to set up callbacks or other constructs to pass values around or trigger thread changes. The withContext(...) function switches over to the IO dispatcher to run our background work, then returns back to the Main (UI) dispatcher to update the UI. Note The code we'll write will be even simpler, as we'll be updating state for our UI rather than switching over the UI thread to update the UI directly. Using Flows Kotlin Flows allow your coroutine to fetch new data as it becomes available. We can tweak our DAO data-access functions to return Flows rather than just data: @Query ( \"SELECT * FROM Person\" ) fun getPeople (): Flow < List < Person >> @Query ( \"SELECT * FROM Person WHERE id = :id\" ) fun getPerson ( id : String ): Flow < Person > So what does this do? We can now call getPeople() or getPerson() and it will immediately return a Flow . We collect it from a coroutine val people = database . dao . getPeople () // returns the Flow immediately scope . launch { // watch the Flow for new lists when data changes people . collect { people -> // display the current list of people } } The coroutine will ask for the next list of people to process, and suspend until a new list is available. (We'll talk more about \"suspension\" later, but in a nutshell, it allows the dispatcher to process other coroutines rather than blocking to wait for the next result to come in.) On the database side, a trigger is installed to serve up a new list when the data changes. The collect will keep receiving new lists until we cancel the coroutine (when its host scope is canceled - could be when the application or current activity is closed). One-Shot DAO Functions But what if we just want to run a DAO function and not receive updates? Or what if the function is an insert/update/delete? We want to call these functions and wait for the result . This call needs to be on a non-UI thread. In our examples, we again use Kotlin coroutines. For example, let's call an update function in the DAO: scope . launch { database . dao . update ( person1 ) } Here we kick off a coroutine to perform some work and call the update function. But what thread does this run on? That depends on the scope used to launch the coroutine, and would be a decision for the caller to make. We could do scope . launch ( Dispatchers . IO ) { database . dao . update ( person1 ) } but this has a few problems. First, as mentioned, the caller has to choose the dispatcher. When you leave things to the caller reading the documentation that says \"make sure you run this off the UI thread\", some calls are going to miss it. Second, Room cannot optimize the way that the database is accessed, because it doesn't know we're running the function in a coroutine. So let's tell Room.","title":"Room Basics"},{"location":"week-03/3.1-Room/STEP_20_FULL.html#entity","text":"Let's start by defining a simple entity using Room. @Entity data class Person ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var name : String , var age : Int , var ssn : String , ) We're using a Kotlin Data Class to define the entity type. The @Entity annotation tells the Room compiler to generate a database table and code to convert the class definition to/from a row in that table. The @PrimaryKey annotation tells the Room compiler which attribute represents the unique identifier for the entity. Here we see a Kotlin default value specification - if a caller creates a Person instance and does not specify the id, one will be created for them by generating a random UUID . When you want to create a Person , all you need to do is write val person = Person ( name = \"Scott\" , age = 55 , ssn = \"123-45-6789\" ) You can then use a Data Access Object to store that Person in the database. By default the table name will be the class name, and all columns will be the property names. You can modify this, but we won't go into that detail in this class. If you want more detail, take a look at https://developer.android.com/training/data-storage/room .","title":"Entity"},{"location":"week-03/3.1-Room/STEP_20_FULL.html#data-access-object-dao","text":"A Data Access Object defines your \"CRUD\" functions. \"CRUD\" stands for \"Create, Read, Update and Delete\", the four types of queries you'll use to access and modify database contents. A simple DAO might look like @Dao interface PersonDao { @Query ( \"SELECT * FROM Person\" ) fun getPeople (): List < Person > @Query ( \"SELECT * FROM Person WHERE id = :id\" ) fun getPerson ( id : String ): Person @Insert fun insert ( vararg people : Person ) @Update fun update ( vararg people : Person ) @Delete fun delete ( vararg people : Person ) @Query ( \"DELETE FROM Person WHERE id IN (:ids)\" ) fun delete ( ids : List < String > ) } Note This is an interface, but you can also define it as an abstract class. The Room compiler will generate an implementation (or subclass) with the details of how to perform the declared functions. Here we're defining some simple CRUD operations for a Person. getPeople() - Returns a list of all Person instances in the table. Note that the specified SQL is just normal SQL, using the entity as the table name. getPerson(id) - Returns a single person with the specified id. The :id syntax is replaced with the id parameter passed to the function. insert(people) - inserts the passed Person instances into the database. By default, this will throw an exception if a passed Person has an id that's already in the table. update(people) - updates the Person table with the values for each passed Person . Will throw an exception if any passed Person doesn't exist. delete(people) - deletes the specified people from the table. delete(ids) - deletes the people with the specified ids from the table. Note that we're using the @Query annotation here to tailor the deletion. Once you have a DAO instance, you just call the functions to access/modify data. Note All of the functions defined in this DAO are synchronous ! You really don't want to call these from the user-interface thread or the UI may become \"janky\" (non-smooth animation, delays in user interaction, etc). Using the above DAO requires you to call the DAO functions from a different thread. We'll see how to do that shortly. We'll also see how to set up asynchronous queries in the DAO. Note You can define separate DAOs for separate entities, but you don't need to. If you don't have a huge number of DAO functions needed for your application, you can define them all in the same DAO interface/abstract class.","title":"Data Access Object (DAO)"},{"location":"week-03/3.1-Room/STEP_20_FULL.html#database","text":"But how do we get an instance of a DAO? That's where the Database class comes in. @Database ( version = 1 , entities = [ Person :: class ], exportSchema = false ) abstract class PersonDatabase : RoomDatabase () { abstract val dao : PersonDao } You define a database class with the @Database annotation, and the class must be abstract and extend RoomDatabase . The Room compiler will generate a subclass that creates the actual DAO instance you'll use to run your queries. By listing the entity classes in the @Database annotation, Room knows which tables it should create. Room also supports database migration (when the entity definitions change), but that's a more advanced topic and not covered in this class.)","title":"Database"},{"location":"week-03/3.1-Room/STEP_20_FULL.html#usage","text":"Now that all the pieces are defined, we can use the database as follows. Note You'd normally put this code in a View Model or Repository class, spread across multiple functions. val database = Room . databaseBuilder ( context , // An Android context, like an Activity, used // to locate the database file on the device PersonDatabase :: class . java , // The database type to create \"PEOPLE\" // The name of the database file ) . build () val person1 = Person ( name = \"Scott\" , age = 55 , ssn = \"123-45-6789\" ) val person2 = Person ( name = \"Mikey\" , age = 10 , ssn = \"234-56-7890\" ) database . dao . insert ( person1 , person2 ) val people = database . dao . getPeople () person1 . age ++ database . dao . update ( person1 ) database . dao . delete ( person2 ) Room.databaseBuilder creates our database for us. Be sure to use only one instance of your database! The database has caching and other code that won't work as expected if you create multiple instances! Because of this, you usually want to hold onto your database in a View Model or Repository, or create the instance using Dependency Injection. Room.databaseBuilder is written in Java, and because of this, you cannot use named parameters or pass the Kotlin KClass ( PersonDatabase::class ) as a parameter. You must pass the Java Class that represents the database by adding .class . The Class is metadata describing the type, and is using to create an instance of the type dynamically at runtime. Once you have a database, you can access the dao and calls its functions.","title":"Usage"},{"location":"week-03/3.1-Room/STEP_20_FULL.html#threading-issues","text":"The problem with the code you've seen so far is that it might be invoked on the user interface thread, causing \"jank\", a poor-performing UI. It's important to perform the database processing on another thread. In this class, we'll use Kotlin's coroutines to perform our work. For data-access queries, we'll use Flows , collected in a coroutine. For everything else we'll launch a coroutine to perform the action. I'm going to do a lot of hand-waving on coroutines at this point (imagine you're watching a video with my hands flailing about) and explain them in more detail later in the course. For now, follow the patterns I'll describe and don't worry too much about how things work behind the scenes. For now, think of a coroutine as a helper that will run some code on a specific thread, and can switch to other threads depending on the work you need to run. Coroutines use Dispatchers to manage their execution on different threads. The \"Main\" dispatcher runs code on the user-interface thread. The \"IO\" dispatcher runs potentially blocking code on a set of threads optimized for blocking function calls. The \"Default\" dispatcher runs code on other background threads. Let's say that we want to display a message, fetch 10 items from the database, updating a progress bar and the message for each, then display a \"done\" message. For this type of processing, we need to update the message and progress bar on the UI thread, and fetch the items from the database on a background thread. Our coroutine might look like fun doStuff () { scope . launch ( Dispatchers . Main ) { showMessage ( \"Fetching data...\" ) repeat ( 10 ) { n -> val item = withContext ( Dispatchers . IO ) { fetch ( n ) } showMessage ( item . message ) updateProgress ( n ) } showMessage ( \"All data fetched!\" ) } } Notice how this is just a function, and it looks like normal imperative logic. But it's actually switching threads! And we don't need to set up callbacks or other constructs to pass values around or trigger thread changes. The withContext(...) function switches over to the IO dispatcher to run our background work, then returns back to the Main (UI) dispatcher to update the UI. Note The code we'll write will be even simpler, as we'll be updating state for our UI rather than switching over the UI thread to update the UI directly.","title":"Threading Issues"},{"location":"week-03/3.1-Room/STEP_20_FULL.html#using-flows","text":"Kotlin Flows allow your coroutine to fetch new data as it becomes available. We can tweak our DAO data-access functions to return Flows rather than just data: @Query ( \"SELECT * FROM Person\" ) fun getPeople (): Flow < List < Person >> @Query ( \"SELECT * FROM Person WHERE id = :id\" ) fun getPerson ( id : String ): Flow < Person > So what does this do? We can now call getPeople() or getPerson() and it will immediately return a Flow . We collect it from a coroutine val people = database . dao . getPeople () // returns the Flow immediately scope . launch { // watch the Flow for new lists when data changes people . collect { people -> // display the current list of people } } The coroutine will ask for the next list of people to process, and suspend until a new list is available. (We'll talk more about \"suspension\" later, but in a nutshell, it allows the dispatcher to process other coroutines rather than blocking to wait for the next result to come in.) On the database side, a trigger is installed to serve up a new list when the data changes. The collect will keep receiving new lists until we cancel the coroutine (when its host scope is canceled - could be when the application or current activity is closed).","title":"Using Flows"},{"location":"week-03/3.1-Room/STEP_20_FULL.html#one-shot-dao-functions","text":"But what if we just want to run a DAO function and not receive updates? Or what if the function is an insert/update/delete? We want to call these functions and wait for the result . This call needs to be on a non-UI thread. In our examples, we again use Kotlin coroutines. For example, let's call an update function in the DAO: scope . launch { database . dao . update ( person1 ) } Here we kick off a coroutine to perform some work and call the update function. But what thread does this run on? That depends on the scope used to launch the coroutine, and would be a decision for the caller to make. We could do scope . launch ( Dispatchers . IO ) { database . dao . update ( person1 ) } but this has a few problems. First, as mentioned, the caller has to choose the dispatcher. When you leave things to the caller reading the documentation that says \"make sure you run this off the UI thread\", some calls are going to miss it. Second, Room cannot optimize the way that the database is accessed, because it doesn't know we're running the function in a coroutine. So let's tell Room.","title":"One-Shot DAO Functions"},{"location":"week-03/3.1-Room/STEP_25_FULL.html","text":"So far we've only talked about entities by themselves. But we really need relationships to make things work. There are two general approaches to making relationships work Helper class: You define a non-entity class to hold data and explicitly pull columns @Embedded objects can group attributes into objects @Relation objects run secondary queries automatically Multi-map: Specify a Map<Entity, List<OtherEntity>> as the return type on a DAO function We'll look into using some of these in a few examples, which should be enough for the class assignment. For a more detailed discussion see https://developer.android.com/training/data-storage/room/relationships . Fetching Partial Data You can use a helper class to fetch partial data from an Entity. Let's start by only fetching the name and age of Person entities. Recall that our Person looks like @Entity data class Person ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var name : String , var age : Int , var ssn : String , ) If we only want the name and age , we can define a data class with just those properties: data class NameAndAge ( val name : String , val age : Int , ) Note Note that NameAndAge does not have the @Entity annotation! It's just a normal data class! And then in the DAO, you can define @Query ( \"SELECT name, age FROM Person\" ) fun getNamesAndAges (): Flow < List < NameAndAge >> Room will fill the NameAndAge instances, not returning the id or ssn . (This would also work with a \"SELECT * FROM Person\" query, but that would fetch all the data from the database before creating NameAndAge objects with just the name and age ) One-to-One Let's set up support to fetch a BirthCertificate while we're fetching a Person . Suppose we have entities @Entity data class Person ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var name : String , var age : Int , var ssn : String , ) @Entity data class BirthCertificate ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var owningPersonId : String , var fatherName : String , var motherName : String , var birthTime : Long , ) We want to fetch a Person and its associated BirthCertificate at the same time. So we create data class PersonAndBirthCertificate ( @Embedded val person : Person , @Relation ( parentColumn = \"id\" , // the id attribute of the \"owner\" entityColumn = \"owningPersonId\" , // the foreign key in the related item that holds the // owner id ) val birthCertificate : BirthCertificate ) // (in the DAO) @Transaction @Query ( \"SELECT * FROM Person\" ) fun getPeopleWithBirthCertificates (): Flow < List < PersonAndBirthCertificate >> Our helper class, PersonAndBirthCertificate contains two objects - a Person and a BirthCertificate . Surprise! Let's talk through how they get filled in. We run the getPeopleWithBirthCertificates function in the Dao. The \"SELECT * FROM Person\" query is run, fetching all Person data from the table. Room looks at the return type and creates a PersonAndBirthCertificate instance for each row in the table. Room sees the @Embedded annotation on person and copies the data from all columns matching properties in the Person to a new Person instance. Note that the @Embedded object doesn't have to be the same type as table we're querying. It could be a partial-data class that contains properties that match columns in the table. Note that you can use @ColumnInfo annotations to create custom mappings between column names and properties, but we're not covering that in this class. Room sees a @Relation annotation on the birthCertificates property, and runs another query to fetch the BirthCertificates . The @Relation annotation specifies a parentColumn and entityColumn . parentColumn is the column in the original query that is considered the id of the owner entityColumn is the foreign key inside the related object (the one specified as the type of the annotated property, BirthCertificate in this example) Room's query fetches from the BirthCertificate table grabbing entities that have a owningPersonId that matches the id of each Person Room fills in the BirthCertificate for each PersonWithBirthCertificate You can have multiple @Relation annotations inside the helper class, but note that they each result in running an extra query. You can also nest relations, where related objects can contain their own @Relation annotations to create a larger graph of results. Note Did you notice the @Transaction annotation on the getPeopleWithBirthCertificates function? This ensures that no matter how many queries are run when the function is called, they're all treated atomically. No updates can happen between any of the queries, keeping the returned data consistent. Whenever you use @Relation , make sure any DAO functions that reference the class containing it are marked with @Transaction . @Transaction can also be used when defining non-abstract functions in a DAO. For example, suppose you want to define a transfer function in a banking DAO that removes funds from one account and deposits them in another account. You would need a @Transaction annotation on such a function so the operation is atomic. You'd never want it to be able to only deposit or withdraw. You could write (if the DAO is an abstract class): @Transaction fun transfer ( from : Account , to : Account , amount : Long ) { withdraw ( from , amount ) deposit ( to , amount ) } One-to-Many One-to-Many works almost exactly like One-to-One. The only difference is the declaration of the related property in the helper object. For our Organs example, we could define @Entity data class Person ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var name : String , var age : Int , var ssn : String , ) @Entity data class Organ ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var owningPersonId : String , var type : String , ) for our entities, and data class PersonAndOrgans ( @Embedded val person : Person , @Relation ( parentColumn = \"id\" , // the id attribute of the \"owner\" entityColumn = \"owningPersonId\" , // the foreign key in the related item that holds the // owner id ) val organs : List < Organ > ) // and in the DAO @Transaction @Query ( \"SELECT * FROM Person\" ) fun getPeopleAndOrgans (): Flow < List < PersonAndOrgans >> The only difference here is that our related property, organs is a List rather than a single-value property. Many-to-Many Things get more complex when we define a many-to-many relationship. Take our example of Person and Address : @Entity data class Person ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var name : String , var age : Int , var ssn : String , ) @Entity data class Address ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var street : String , var city : String , var state : String , var zipCode : String , ) @Entity ( primaryKeys = [ \"personId\" , \"addressId\" ] ) data class PersonAddress ( var personId : String , var addressId : String , ) These three entities give us a many-to-many relationship: A Person can have multiple Address entities (home, work, etc) An Address can host multiple Person entities. All three are entities, and we can use helper objects to fetch a Person or Address and the related other: data class PersonAndAddresses ( @Embedded val person : Person , @Relation ( parentColumn = \"id\" , // which property represents the id of the person // (the main entity we're fetching) entityColumn = \"id\" , // which property represents the id of the Address (the related entity) associateBy = Junction ( PersonAddress :: class , parentColumn = \"personId\" , // which property **in the association table** represents // the id of the person (the main entity we're fetching) entityColumn = \"addressId\" , // which property **in the association table** represents // the id of the Address (the related entity) ), ) val addresses : List < Address > ) // in the DAO @Transaction @Query ( \"SELECT * FROM Person\" ) fun getPeopleAndAddresses (): Flow < List < PersonAndAddresses >> Similar to before, but we add an associateBy attribute to describe the association table. Room maps the parentColumn of the @Relation to the parentColumn in the Junction , and the entityColumn in the @Relation to the entityColumn in the Junction . This ends up running two queries. First, get all the Person entities. SELECT * FROM Person Room now has all the Person data, including the ids of each Person . Room will now run its second query, passing those ids (I'm representing them as $personIds in this query). SELECT Address.id, Address.street, Address.city, Address.state, Address.zip, PersonAddress.movieId FROM PersonAddress INNER JOIN Address ON (PersonAddress.addressId = Address.id) WHERE PersonAddress.personId IN ($personIds)","title":"Room Relations"},{"location":"week-03/3.1-Room/STEP_25_FULL.html#fetching-partial-data","text":"You can use a helper class to fetch partial data from an Entity. Let's start by only fetching the name and age of Person entities. Recall that our Person looks like @Entity data class Person ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var name : String , var age : Int , var ssn : String , ) If we only want the name and age , we can define a data class with just those properties: data class NameAndAge ( val name : String , val age : Int , ) Note Note that NameAndAge does not have the @Entity annotation! It's just a normal data class! And then in the DAO, you can define @Query ( \"SELECT name, age FROM Person\" ) fun getNamesAndAges (): Flow < List < NameAndAge >> Room will fill the NameAndAge instances, not returning the id or ssn . (This would also work with a \"SELECT * FROM Person\" query, but that would fetch all the data from the database before creating NameAndAge objects with just the name and age )","title":"Fetching Partial Data"},{"location":"week-03/3.1-Room/STEP_25_FULL.html#one-to-one","text":"Let's set up support to fetch a BirthCertificate while we're fetching a Person . Suppose we have entities @Entity data class Person ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var name : String , var age : Int , var ssn : String , ) @Entity data class BirthCertificate ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var owningPersonId : String , var fatherName : String , var motherName : String , var birthTime : Long , ) We want to fetch a Person and its associated BirthCertificate at the same time. So we create data class PersonAndBirthCertificate ( @Embedded val person : Person , @Relation ( parentColumn = \"id\" , // the id attribute of the \"owner\" entityColumn = \"owningPersonId\" , // the foreign key in the related item that holds the // owner id ) val birthCertificate : BirthCertificate ) // (in the DAO) @Transaction @Query ( \"SELECT * FROM Person\" ) fun getPeopleWithBirthCertificates (): Flow < List < PersonAndBirthCertificate >> Our helper class, PersonAndBirthCertificate contains two objects - a Person and a BirthCertificate . Surprise! Let's talk through how they get filled in. We run the getPeopleWithBirthCertificates function in the Dao. The \"SELECT * FROM Person\" query is run, fetching all Person data from the table. Room looks at the return type and creates a PersonAndBirthCertificate instance for each row in the table. Room sees the @Embedded annotation on person and copies the data from all columns matching properties in the Person to a new Person instance. Note that the @Embedded object doesn't have to be the same type as table we're querying. It could be a partial-data class that contains properties that match columns in the table. Note that you can use @ColumnInfo annotations to create custom mappings between column names and properties, but we're not covering that in this class. Room sees a @Relation annotation on the birthCertificates property, and runs another query to fetch the BirthCertificates . The @Relation annotation specifies a parentColumn and entityColumn . parentColumn is the column in the original query that is considered the id of the owner entityColumn is the foreign key inside the related object (the one specified as the type of the annotated property, BirthCertificate in this example) Room's query fetches from the BirthCertificate table grabbing entities that have a owningPersonId that matches the id of each Person Room fills in the BirthCertificate for each PersonWithBirthCertificate You can have multiple @Relation annotations inside the helper class, but note that they each result in running an extra query. You can also nest relations, where related objects can contain their own @Relation annotations to create a larger graph of results. Note Did you notice the @Transaction annotation on the getPeopleWithBirthCertificates function? This ensures that no matter how many queries are run when the function is called, they're all treated atomically. No updates can happen between any of the queries, keeping the returned data consistent. Whenever you use @Relation , make sure any DAO functions that reference the class containing it are marked with @Transaction . @Transaction can also be used when defining non-abstract functions in a DAO. For example, suppose you want to define a transfer function in a banking DAO that removes funds from one account and deposits them in another account. You would need a @Transaction annotation on such a function so the operation is atomic. You'd never want it to be able to only deposit or withdraw. You could write (if the DAO is an abstract class): @Transaction fun transfer ( from : Account , to : Account , amount : Long ) { withdraw ( from , amount ) deposit ( to , amount ) }","title":"One-to-One"},{"location":"week-03/3.1-Room/STEP_25_FULL.html#one-to-many","text":"One-to-Many works almost exactly like One-to-One. The only difference is the declaration of the related property in the helper object. For our Organs example, we could define @Entity data class Person ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var name : String , var age : Int , var ssn : String , ) @Entity data class Organ ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var owningPersonId : String , var type : String , ) for our entities, and data class PersonAndOrgans ( @Embedded val person : Person , @Relation ( parentColumn = \"id\" , // the id attribute of the \"owner\" entityColumn = \"owningPersonId\" , // the foreign key in the related item that holds the // owner id ) val organs : List < Organ > ) // and in the DAO @Transaction @Query ( \"SELECT * FROM Person\" ) fun getPeopleAndOrgans (): Flow < List < PersonAndOrgans >> The only difference here is that our related property, organs is a List rather than a single-value property.","title":"One-to-Many"},{"location":"week-03/3.1-Room/STEP_25_FULL.html#many-to-many","text":"Things get more complex when we define a many-to-many relationship. Take our example of Person and Address : @Entity data class Person ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var name : String , var age : Int , var ssn : String , ) @Entity data class Address ( @PrimaryKey var id : String = UUID . randomUUID (). toString (), var street : String , var city : String , var state : String , var zipCode : String , ) @Entity ( primaryKeys = [ \"personId\" , \"addressId\" ] ) data class PersonAddress ( var personId : String , var addressId : String , ) These three entities give us a many-to-many relationship: A Person can have multiple Address entities (home, work, etc) An Address can host multiple Person entities. All three are entities, and we can use helper objects to fetch a Person or Address and the related other: data class PersonAndAddresses ( @Embedded val person : Person , @Relation ( parentColumn = \"id\" , // which property represents the id of the person // (the main entity we're fetching) entityColumn = \"id\" , // which property represents the id of the Address (the related entity) associateBy = Junction ( PersonAddress :: class , parentColumn = \"personId\" , // which property **in the association table** represents // the id of the person (the main entity we're fetching) entityColumn = \"addressId\" , // which property **in the association table** represents // the id of the Address (the related entity) ), ) val addresses : List < Address > ) // in the DAO @Transaction @Query ( \"SELECT * FROM Person\" ) fun getPeopleAndAddresses (): Flow < List < PersonAndAddresses >> Similar to before, but we add an associateBy attribute to describe the association table. Room maps the parentColumn of the @Relation to the parentColumn in the Junction , and the entityColumn in the @Relation to the entityColumn in the Junction . This ends up running two queries. First, get all the Person entities. SELECT * FROM Person Room now has all the Person data, including the ids of each Person . Room will now run its second query, passing those ids (I'm representing them as $personIds in this query). SELECT Address.id, Address.street, Address.city, Address.state, Address.zip, PersonAddress.movieId FROM PersonAddress INNER JOIN Address ON (PersonAddress.addressId = Address.id) WHERE PersonAddress.personId IN ($personIds)","title":"Many-to-Many"},{"location":"week-03/3.1-Room/STEP_30_FULL.html","text":"Many operations in a multi-threaded application end up blocking the current thread, and it cannot be used for any other work while it's blocked. Think about a sleep function. You've got some background work running, and it wants to pause for a moment (perhaps you're checking if something has changed once a minute). This ties up the thread that's being used to run that operation. Threads are a limited resource. Using them like this severely limits concurrency on your machine. What we'd like to do is allow other operations to be performed while we're waiting. This is where suspending functions come into play. A suspending function is one that can be paused when it's called, with the current state of its caller captured. Coroutines are cooperative . Java threads are pre-emptive . Long ago, multitasking was all about being cooperative. Your program would start running on a CPU, and would keep running until you would yield , telling the CPU it was ok to give another program a turn. Your state was saved, the CPU would run something else, and it would yield to allow you (or something else picked by the scheduler) to run. But all it took was one rogue program to hog the CPU and starve all other programs until it was done. This wouldn't necessarily be done by a malicious programmer; it was easy to accidentally omit the yield, as it depended upon the programmer reading the right chunk of documentation. Pre-emptive multitasking got rid of that worry. When multiple programs wanted to run at the same time, the CPU scheduler would grant each a chunk of time on one of its threads, then switch to another program. It wasn't up to the programmer. Kotlin is most often run on top of the Java Virtual Machine (JVM), which uses a pre-emptive threading model. When we use cooperative coroutines, we get an interesting mix of threading models that works well in our favor. A coroutine cannot starve other processes that want to use a thread, as the pre-emptive nature of the JVM will force switches. But if a blocking operation (like a sleep ) is performed, the CPU will keep switching back to the operation, wasting time that other processes could use. Coroutine work is scheduled in a way that can decide when it really needs to use a thread. Instead of blocking a thread from being used while sleep is called, we use delay , which interacts with the scheduler to request to be continued at a later time. Other coroutines can then use the underlying thread, allowing much better concurrency. Marking a function with the suspend keyword causes the Kotlin compiler to modify that function to pass an additional parameter called a \"continuation\". Whenever a suspend function is called from within it, the continuation remembers our function state so we can restart at that point later. The scheduler can then use the thread that the suspend function was being run on. Later, when our suspend function gets another chance to run, the continuation is used to execute the next chunk (up until another suspend function is called). For more detail on how this works, check out Suspend functions - Kotlin vocabulary . Suspending functions can only be called from another suspend function or within a coroutine, started by launch (no result needed) or async (allows us to wait for a result). Dispatchers manage one or more threads as a group. As we've seen earlier, we use dispatchers to switch the coroutine processing to work on a different thread using the withContext(dispatcher) function, which is itself a suspending function! Google's current advice is that suspending functions should be \"main-thread safe\". If the function is called from the main (UI) thread, it should use withContext to switch to a different dispatcher. For example, if we wanted to define a function to update a person in the database, we could write suspend fun updatePerson ( person : Person ) { withContext ( Dispatchers . IO ) { database . dao . update ( person ) } } This function is main-safe, as it forces a switch to the IO dispatcher. Often you'll see suspend functions written using Kotlin's single-expression-function syntax. ( withContext will return the value that its lambda returns). suspend fun updatePerson ( person : Person ) = withContext ( Dispatchers . IO ) { database . dao . update ( person ) } Because this is a common task to perform, and because Room can perform some extra optimization if it knows it's running in a coroutine, we can add suspend to our DAO function declarations. The Room compiler will create a main-safe suspending function for you: @Dao interface PersonDao { ... @Insert suspend fun insert ( vararg person : Person ) @Update suspend fun update ( vararg person : Person ) @Delete suspend fun delete ( vararg person : Person ) @Query ( \"DELETE FROM Person WHERE id IN (:ids)\" ) suspend fun delete ( ids : List < String > ) } This forces you to launch coroutines to call these functions ( suspend functions can only be called from coroutines or other suspend functions) and switches to a dispatcher that Room defines to optimize the database access.","title":"Suspending Functions"},{"location":"week-03/3.1-Room/STEP_40_FULL.html","text":"A Repository is an optional abstraction at the top of the Data Layer . It's often used to Expose data from multiple data sources Cache data from a remote data source (such as a web service) in a local data source (such as a database or file) Convert data into Data Transfer Objects that expose a more restricted view of the data In this class, we'll be using it to create Data Transfer Objects . If you're interested in other uses of a Repository, search online for terms such as \"Android Repository Cache\". But first, where does the Repository go? It's part of the Data Layer , but by smart use of Modules in your application, you can take advantage of dependencies between modules to prevent other layers from accidentally accessing data directly. flowchart LR subgraph User Interface Layer ui[User Interface Module\\nView Model\\nUser interface] end ui --> repo subgraph Data Layer repo[Repository Module\\nRepository\\nData Transfer Objects] ds[Data Source Module\\nEntities\\nDAO] repo --> ds end The separate Repository Module prevents the User Interface Module from directly accessing anything in the Data Source Module (assuming you set up module dependencies in your build to restrict that). It's a great way to hide details as well as make the data we use in the user interface immutable , which is great for the Jetpack Compose UI that we'll be creating. We'll see how these modules are set up when we're walking through the example code. Repository Code So what does the code in the Repository module look like? First, let's define a Data Transfer Object for our Person: data class PersonDto ( val id : String , val name : String , val age : Int , val ssn : String , ) Note that all of the properties here are val properties; we can only read them; we cannot change them. We can also define a couple of helper extension functions internal fun Person . toDto () = PersonDto ( id = id , name = name , age = age , ssn = ssn ) internal fun PersonDto . toEntity () = Person ( id = id , name = name , age = age , ssn = ssn ) Kotlin extension functions make it look like we're defining new functions on existing types. Here we add a toDto function to our Person entity, and a toEntity function to our PersonDto . Note that both functions are marked internal . This restricts their use to inside of the module defining them. We're only doing the transformation inside the Repository module. Marking them internal allows us to use them anywhere within the module, no matter which package. Next, we define an interface for the Repository: interface PersonRepository { val peopleFlow : Flow < List < PersonDto >> suspend fun insert ( vararg people : PersonDto ) suspend fun update ( vararg people : PersonDto ) suspend fun delete ( vararg people : PersonDto ) } Note that this interface only uses the PersonDto , not the Person entity. We're only exposing the DTO. We can (and will) have multiple implementations of this interface. We'll start with one that talks to a Room database, and later in the course we'll implement it by talking to a web service. class PersonDatabaseRepository ( context : Context ): PersonRepository { private val dao = Room . databaseBuilder ( context , PersonDatabase :: class . java , \"PEOPLE\" ) . build () . dao ... } To create a Room database instance, we need an Android Context . The Context (typically an Application or Activity instance) gives us access to details about the application, such as where our database files are stored. We pass that to the PersonDatabaseRepository , create a database instance and grab the DAO from it. Next, we expose a Flow<List<PersonDto>> . To do this, we'll take advantage of the map operator on Flow . map creates a new Flow by collecting objects from a Flow and transforming each item into something else. class PersonDatabaseRepository ( context : Context ): PersonRepository { private val dao = ... override val peopleFlow = dao . getPeople () . map { people -> // AAA people . map { it . toDto () } // BBB } ... } The first map call creates that new Flow . Whenever we get a new value, the List<Person> , we pass it to the lambda starting on line AAA . That list is represented by lambda parameter people . Using a map operator against that list (line BBB ), we create a new list by converting each Person into a PersonDto . Anyone collecting peopleFlow will get a List<PersonDto> that contains a read-only copy of the Person entity data. The one-shot functions are all implemented similarly, so we'll just talk through the insert function. class PersonDatabaseRepository ( context : Context ): PersonRepository { private val dao = ... ... override suspend fun insert ( vararg people : PersonDto ) = dao . insert ( * people // AAA . map { it . toEntity () } // BBB . toTypedArray () // CCC ) override suspend fun update ( vararg people : PersonDto ) = ... // similar to insert override suspend fun delete ( vararg people : PersonDto ) = ... // similar to insert } The caller will pass in a varying-length argument list of PersonDto instances. This means they can pass any number of PersonDtos into insert , separarted by commas. For example repository . insert ( person1 ) repository . insert ( person1 , person2 , person3 ) are valid calls to insert . Inside insert , the people parameter is an Array<PersonDto> . We need to convert each PersonDto to a Person entity. Line BBB converts people into a List<Person> . But now we need to pass those Person instances into a varying-length, comma-separated argument list. Java would allow you to just pass an array, but that caused some ambiguity problems. Kotlin removed the ambiguity, but it had to make things a little more complex in the process. We need to \"spread\" the values out as a comma-separated list. That's what the * does on line AAA . * is called the \"spread operator\" in this context. But it only works against an Array of values, so we need to call toTypedArray on line CCC to convert our new List<Person> into an Array<Person> . Once spread, we pass the values into the DAO's insert function. Implement the update and delete functions similarly, and we now have a repository that isolates the Room data from the User Interface Layer .","title":"The Repository"},{"location":"week-03/3.1-Room/STEP_40_FULL.html#repository-code","text":"So what does the code in the Repository module look like? First, let's define a Data Transfer Object for our Person: data class PersonDto ( val id : String , val name : String , val age : Int , val ssn : String , ) Note that all of the properties here are val properties; we can only read them; we cannot change them. We can also define a couple of helper extension functions internal fun Person . toDto () = PersonDto ( id = id , name = name , age = age , ssn = ssn ) internal fun PersonDto . toEntity () = Person ( id = id , name = name , age = age , ssn = ssn ) Kotlin extension functions make it look like we're defining new functions on existing types. Here we add a toDto function to our Person entity, and a toEntity function to our PersonDto . Note that both functions are marked internal . This restricts their use to inside of the module defining them. We're only doing the transformation inside the Repository module. Marking them internal allows us to use them anywhere within the module, no matter which package. Next, we define an interface for the Repository: interface PersonRepository { val peopleFlow : Flow < List < PersonDto >> suspend fun insert ( vararg people : PersonDto ) suspend fun update ( vararg people : PersonDto ) suspend fun delete ( vararg people : PersonDto ) } Note that this interface only uses the PersonDto , not the Person entity. We're only exposing the DTO. We can (and will) have multiple implementations of this interface. We'll start with one that talks to a Room database, and later in the course we'll implement it by talking to a web service. class PersonDatabaseRepository ( context : Context ): PersonRepository { private val dao = Room . databaseBuilder ( context , PersonDatabase :: class . java , \"PEOPLE\" ) . build () . dao ... } To create a Room database instance, we need an Android Context . The Context (typically an Application or Activity instance) gives us access to details about the application, such as where our database files are stored. We pass that to the PersonDatabaseRepository , create a database instance and grab the DAO from it. Next, we expose a Flow<List<PersonDto>> . To do this, we'll take advantage of the map operator on Flow . map creates a new Flow by collecting objects from a Flow and transforming each item into something else. class PersonDatabaseRepository ( context : Context ): PersonRepository { private val dao = ... override val peopleFlow = dao . getPeople () . map { people -> // AAA people . map { it . toDto () } // BBB } ... } The first map call creates that new Flow . Whenever we get a new value, the List<Person> , we pass it to the lambda starting on line AAA . That list is represented by lambda parameter people . Using a map operator against that list (line BBB ), we create a new list by converting each Person into a PersonDto . Anyone collecting peopleFlow will get a List<PersonDto> that contains a read-only copy of the Person entity data. The one-shot functions are all implemented similarly, so we'll just talk through the insert function. class PersonDatabaseRepository ( context : Context ): PersonRepository { private val dao = ... ... override suspend fun insert ( vararg people : PersonDto ) = dao . insert ( * people // AAA . map { it . toEntity () } // BBB . toTypedArray () // CCC ) override suspend fun update ( vararg people : PersonDto ) = ... // similar to insert override suspend fun delete ( vararg people : PersonDto ) = ... // similar to insert } The caller will pass in a varying-length argument list of PersonDto instances. This means they can pass any number of PersonDtos into insert , separarted by commas. For example repository . insert ( person1 ) repository . insert ( person1 , person2 , person3 ) are valid calls to insert . Inside insert , the people parameter is an Array<PersonDto> . We need to convert each PersonDto to a Person entity. Line BBB converts people into a List<Person> . But now we need to pass those Person instances into a varying-length, comma-separated argument list. Java would allow you to just pass an array, but that caused some ambiguity problems. Kotlin removed the ambiguity, but it had to make things a little more complex in the process. We need to \"spread\" the values out as a comma-separated list. That's what the * does on line AAA . * is called the \"spread operator\" in this context. But it only works against an Array of values, so we need to call toTypedArray on line CCC to convert our new List<Person> into an Array<Person> . Once spread, we pass the values into the DAO's insert function. Implement the update and delete functions similarly, and we now have a repository that isolates the Room data from the User Interface Layer .","title":"Repository Code"},{"location":"week-03/3.2-Movie-Database/index.html","text":"Example Source: https://gitlab.com/android-development-2022-refresh/movie-database","title":"Movie Database"},{"location":"week-03/3.2-Movie-Database/STEP_010_REPO.html","text":"After creating a new project in Android Studio.","title":"Starter Project"},{"location":"week-03/3.2-Movie-Database/STEP_020_REPO.html","text":"Update the Android, Kotlin and dependency versions to the latest available. After updating the files, you'll need to re-synchronize them with Android Studio. Android Studio reads the build scripts to determine which modules and which dependencies are used so it can provide code-assist and lint checks in the IDE. When you change a build script, Android Studio will normally display a banner at the top of the file indicating that it needs to be re-synchronized, and you can click \"Sync Now\" to do so. Otherwise you can click the elephant icon on the toolbar to perform this synchronization.","title":"Update Versions"},{"location":"week-03/3.2-Movie-Database/STEP_030_REPO.html","text":"We created new data and repository modules. To do this: Right-click the top-level project in the Project view Choose New -> Module Select the Android Library template Enter data as the Application/Library name Update the Package name to lastname . firstname . appname .data Press Finish Press Add to add the newly-created files to git Then do the same for the repository module. Note that settings.gradle has been updated to add the two new modules. This is how gradle (and Android Studio) know that these are modules it needs to build.","title":"Add Data/Repository Modules"},{"location":"week-03/3.2-Movie-Database/STEP_040_REPO.html","text":"First, I did a little cleanup on the new build scripts, updating versions. Now we're adding the Room dependencies and the Kotlin Symbol Processor (KSP). The Kotlin Symbol Processor is a compiler plugin that loads \"symbol processors\". When we specify dependencies { ... ksp \"androidx.room:room-compiler:$room_version\" ... } in our build.gradle build script for the data module, we're loading in the \"Room Compiler\" symbol processor. This runs as part of the overall Kotlin compilation process, and looks for Room annotations like @Entity and @Database . When it sees them, it generates code to perform our database work. We're only using Room in the data module, so we don't need to add these dependencies in the repository module's build.gradle file. Remember after changing any gradle build files to re-synchronize!","title":"Add Room"},{"location":"week-03/3.2-Movie-Database/STEP_050_REPO.html","text":"Now we need to tell the modules how they depend on each other. flowchart LR subgraph User Interface Layer ui[Module: app\\n] end ui --> repo subgraph Data Layer repo[Module: repository] ds[Module: data] repo --> ds end We set up these dependencies by using implementation project(\":xyz\") in our dependencies. Dependencies can be specified as implementation dependencies or api dependencies. Implementation dependencies are only available within the module that declares them. API dependencies become part of the API of the current module and are made available to any module that depends on the current module. Normally, you should choose the implementation dependency type so modules can hide their implementation dependencies. This also improves build speed, as changes to implementation dependencies are not inherited, and won't trigger a rebuild of modules that depend on the current module.","title":"Module Dependencies"},{"location":"week-03/3.2-Movie-Database/STEP_060_REPO.html","text":"Let's define the Entities, DAO and Database using Room. Here's our schema erDiagram RATING ||--o{ MOVIE: movies MOVIE ||--o{ ROLE : cast ROLE }o--|| ACTOR : appearance What does this mean? RATING <-> MOVIE is a one-to-many relationship A RATING can be associated with zero or more MOVIEs A MOVIE has exactly one RATING MOVIE <-> ACTOR is a many-to-many relationship An ACTOR can appear in zero or more MOVIEs A MOVIE can cast zero or more ACTORs To implement this, we introduce an associative entity ROLE with a one-to-many relationship on each side A MOVIE can cast zero or more ROLEs An ACTOR can appear in zero or more ROLEs A ROLE can appear in exactly one MOVIE A ROLE is played by exactly one ACTOR Let's look at the attributes of each entity. All entities are represented as Kotlin data classes. Rating Represents an MPAA rating (G, PG, PG-13, R, NR) Attribute Type Key id String PK name String description String Actor An actor that can appear in movies Attribute Type Key Comment id String PK name String Movie A movie Attribute Type Key id String PK title String description String ratingId String FK Role Association entity that casts actors into movies Attribute Type Key movieId String FK actorId String FK character String orderInCredits int MovieDAO We start with a DAO that has basic CRUD (Create, Read, Update, Delete) operations. Later we're going to add a concrete function, so I chose to make the DAO an abstract class rather than an interface. All one-shot functions are declared as suspend functions so they'll ensure they're not run on the UI thread. The query functions immediately return a Flow that we'll collect inside a coroutine. We'll add a few more functions as the example grows. MovieDatabase A very typical Room database declaration. The database will contain Movie, Actor, Role and Rating entities and expose a MovieDAO. DatabaseBuilder.kt This Kotlin file hosts a single function that we'll use to create an instance of the database. Defining this function here, in the data module, avoids the need to make the repository module depend on Room. Note that if you want to see the SQL queries that are being run, you can uncomment the setQueryCallback call and look at the Logcat view at the bottom of Android Studio.","title":"Entities, DAO and Database"},{"location":"week-03/3.2-Movie-Database/STEP_060_REPO.html#rating","text":"Represents an MPAA rating (G, PG, PG-13, R, NR) Attribute Type Key id String PK name String description String","title":"Rating"},{"location":"week-03/3.2-Movie-Database/STEP_060_REPO.html#actor","text":"An actor that can appear in movies Attribute Type Key Comment id String PK name String","title":"Actor"},{"location":"week-03/3.2-Movie-Database/STEP_060_REPO.html#movie","text":"A movie Attribute Type Key id String PK title String description String ratingId String FK","title":"Movie"},{"location":"week-03/3.2-Movie-Database/STEP_060_REPO.html#role","text":"Association entity that casts actors into movies Attribute Type Key movieId String FK actorId String FK character String orderInCredits int","title":"Role"},{"location":"week-03/3.2-Movie-Database/STEP_060_REPO.html#moviedao","text":"We start with a DAO that has basic CRUD (Create, Read, Update, Delete) operations. Later we're going to add a concrete function, so I chose to make the DAO an abstract class rather than an interface. All one-shot functions are declared as suspend functions so they'll ensure they're not run on the UI thread. The query functions immediately return a Flow that we'll collect inside a coroutine. We'll add a few more functions as the example grows.","title":"MovieDAO"},{"location":"week-03/3.2-Movie-Database/STEP_060_REPO.html#moviedatabase","text":"A very typical Room database declaration. The database will contain Movie, Actor, Role and Rating entities and expose a MovieDAO.","title":"MovieDatabase"},{"location":"week-03/3.2-Movie-Database/STEP_060_REPO.html#databasebuilderkt","text":"This Kotlin file hosts a single function that we'll use to create an instance of the database. Defining this function here, in the data module, avoids the need to make the repository module depend on Room. Note that if you want to see the SQL queries that are being run, you can uncomment the setQueryCallback call and look at the Logcat view at the bottom of Android Studio.","title":"DatabaseBuilder.kt"},{"location":"week-03/3.2-Movie-Database/STEP_070_REPO.html","text":"Now the basics of the repository module. DTOs We create Data Transfer Objects to abstract and restrict how the data is used. These DTOs are immutable, which will help Jetpack Compose optimize UI updates. We also define extension functions to convert between the entities defined in the data module and the DTOs we expose from this repository module. Note that the extension functions are marked internal . This makes them accessible anywhere inside the repository module, but not outside the module. MovieRepository The MovieRepository interface defines how we communicate with a repository. This allows different repository implementations (later we'll add a web-service implementation). Note that I'm not using vararg in the MovieRepository . This is because it simplifies our web services implementation when we do it later. MovieDatabaseRepository This is the concrete implementation of MovieRepository that we use to work with the Room database. Much of it (the one-shot functions) is direct passthrough to the DAO. The query functions that expose a Flow transform the returned entities into DTOs. The map function on Flow creates a new flow that calls the nested map on the list of entities to convert them into DTOs.","title":"Repository Types"},{"location":"week-03/3.2-Movie-Database/STEP_070_REPO.html#dtos","text":"We create Data Transfer Objects to abstract and restrict how the data is used. These DTOs are immutable, which will help Jetpack Compose optimize UI updates. We also define extension functions to convert between the entities defined in the data module and the DTOs we expose from this repository module. Note that the extension functions are marked internal . This makes them accessible anywhere inside the repository module, but not outside the module.","title":"DTOs"},{"location":"week-03/3.2-Movie-Database/STEP_070_REPO.html#movierepository","text":"The MovieRepository interface defines how we communicate with a repository. This allows different repository implementations (later we'll add a web-service implementation). Note that I'm not using vararg in the MovieRepository . This is because it simplifies our web services implementation when we do it later.","title":"MovieRepository"},{"location":"week-03/3.2-Movie-Database/STEP_070_REPO.html#moviedatabaserepository","text":"This is the concrete implementation of MovieRepository that we use to work with the Room database. Much of it (the one-shot functions) is direct passthrough to the DAO. The query functions that expose a Flow transform the returned entities into DTOs. The map function on Flow creates a new flow that calls the nested map on the list of entities to convert them into DTOs.","title":"MovieDatabaseRepository"},{"location":"week-03/3.2-Movie-Database/STEP_080_REPO.html","text":"For our example application, I want to add an easy way to reset the database to contain some initial, sample data. We start at the DAO in the data module, and add one-shot functions to clear the existing tables, and a concrete one-shot resetDatabase function to perform those clears and re-add the sample data. Moving on to the repository module, we expose the resetDatabase function. Finally, we move up to the app module, our user interface, and add a MovieViewModel class to manage data for the user interface. We create an instance of the repository, and expose the Flows to the UI along with the resetDatabase function. Note The resetDatabase function in the repository and data modules is a suspend function, so we need to start a coroutine to call it. When we're responding to user events, like button presses, we generally want to call a function in the view model and have it start its processing using the view model's coroutine scope , which is called viewModelScope . We'll see some other ways to start coroutines for looking up data when we enter a screen later.","title":"Sample Data"},{"location":"week-03/3.2-Movie-Database/STEP_090_REPO.html","text":"Let's see if anything is working by creating a truly hideous (but simple) UI. (When we talk about Jetpack Compose in more detail, we'll create much better UI.) build.gradle First, we'll need to access the view model in the user interface. We update the app module's build.gradle to include the lifecycle-viewmodel-compose dependency. This gives us a viewModel() function that we can use as a default parameter value when we're defining our UI functions. Info Super quick intro to Jetpack Compose: You write functions to declare what the UI should look like. When the values of the parameters change, the UI is refreshed. (That's a huge oversimplification, but should be enough to work with for now.) Notice the word \"declare\"? These functions describe the user interface rather than creating it directly. Behind the scenes, that description is updated as these functions run, and the Compose runtime determines what has changed for each update so it can refresh the UI. Follow this example when writing your assignment and you'll survive just fine. Later we'll detail how things work. Unfortunately, if we spent the time to learn Compose and Room before starting the first assignment, we'd have several weeks of no assignments... MovieViewModel For our simple UI, we need some way to track which \"screen\" the user is viewing. We do that be defining a sealed interface named Screen . This is a special type of interface that requires all implementations be defined in the same module . This is awesome, because the compiler can know all possible values , and we can write exhaustive when expressions! At this stage we use objects to represent each screen the user might visit. Kotlin's object keyword defines a singleton instance that implements the interface. Right now there's no data needed inside the screen state, so objects work perfectly. We'll add a screen that views a specific movie shortly, and this will require a class that we can instantiate. We expose the current screen using Jetpack Compose state. (I'm waiving my hands furiously right now) Just think of it as a box that can store data, and Compose will know when that data changes so it can refresh the UI. MainActivity Finally! The user interface! We define functions annotated with @Composable (known as \"Composable Functions\") to declare parts of our user interface. Note The names of these @Composable functions will probably look odd. Jetpack Compose uses an UpperCamelCase naming convention for @Composable functions that declare parts of the UI. We're defining a (did I mention hideous?) UI that has buttons at the top of the screen to switch between screens and reset the database. You'll need to reset the database to see any data. Warning When choosing types via content selection, be careful which package you select. Modifier is particularly painful, as the content assist often sorts java.lang.reflect.Modifier above androidx.compose.ui.Modifier (which is the one we want when using Compose). I can't count the number of times I've accidentally selected java.lang.reflect.Modifier ... This mistake will usually become obvious when you try to use other functions (and they're not found). For example, when writing these samples I made the java.lang.reflect.Modifier mistake, and then padding and clickable couldn't be found.","title":"Hideous UI"},{"location":"week-03/3.2-Movie-Database/STEP_090_REPO.html#buildgradle","text":"First, we'll need to access the view model in the user interface. We update the app module's build.gradle to include the lifecycle-viewmodel-compose dependency. This gives us a viewModel() function that we can use as a default parameter value when we're defining our UI functions. Info Super quick intro to Jetpack Compose: You write functions to declare what the UI should look like. When the values of the parameters change, the UI is refreshed. (That's a huge oversimplification, but should be enough to work with for now.) Notice the word \"declare\"? These functions describe the user interface rather than creating it directly. Behind the scenes, that description is updated as these functions run, and the Compose runtime determines what has changed for each update so it can refresh the UI. Follow this example when writing your assignment and you'll survive just fine. Later we'll detail how things work. Unfortunately, if we spent the time to learn Compose and Room before starting the first assignment, we'd have several weeks of no assignments...","title":"build.gradle"},{"location":"week-03/3.2-Movie-Database/STEP_090_REPO.html#movieviewmodel","text":"For our simple UI, we need some way to track which \"screen\" the user is viewing. We do that be defining a sealed interface named Screen . This is a special type of interface that requires all implementations be defined in the same module . This is awesome, because the compiler can know all possible values , and we can write exhaustive when expressions! At this stage we use objects to represent each screen the user might visit. Kotlin's object keyword defines a singleton instance that implements the interface. Right now there's no data needed inside the screen state, so objects work perfectly. We'll add a screen that views a specific movie shortly, and this will require a class that we can instantiate. We expose the current screen using Jetpack Compose state. (I'm waiving my hands furiously right now) Just think of it as a box that can store data, and Compose will know when that data changes so it can refresh the UI.","title":"MovieViewModel"},{"location":"week-03/3.2-Movie-Database/STEP_090_REPO.html#mainactivity","text":"Finally! The user interface! We define functions annotated with @Composable (known as \"Composable Functions\") to declare parts of our user interface. Note The names of these @Composable functions will probably look odd. Jetpack Compose uses an UpperCamelCase naming convention for @Composable functions that declare parts of the UI. We're defining a (did I mention hideous?) UI that has buttons at the top of the screen to switch between screens and reset the database. You'll need to reset the database to see any data. Warning When choosing types via content selection, be careful which package you select. Modifier is particularly painful, as the content assist often sorts java.lang.reflect.Modifier above androidx.compose.ui.Modifier (which is the one we want when using Compose). I can't count the number of times I've accidentally selected java.lang.reflect.Modifier ... This mistake will usually become obvious when you try to use other functions (and they're not found). For example, when writing these samples I made the java.lang.reflect.Modifier mistake, and then padding and clickable couldn't be found.","title":"MainActivity"},{"location":"week-03/3.2-Movie-Database/STEP_100_REPO.html","text":"Let's create a screen to display a Rating and a list of its Movies. This screen will be displayed when a Rating is clicked in the rating list screen. We'll keep track of the id of the clicked Rating in a new Screen object, passing that id to the new display screen. When we set up the real UI later on, we'll be tracking screens that the user has visited in a stack, so they can go back. This allows the user to explore movie and actor relationships. If the user is watching a \"The Transporter\" movie and views its cast in this application, they might want to see what other movies star \"Jason Statham\". After looking, they may want to go back to see who else is in \"The Transporter\" by pressing the Android \"back\" button. If we keep track of the actual Dtos in that stack, they could become stale. The user could have edited a Movie or Actor , and the old DTO instances would still old the old information. Going back would show the stale data. Instead, we track the ids of the objects we've seen on the stack. But how do we get the data we need to display on the screen? We pass the id and a function that can fetch the actual data. When we enter the screen, it will kick off a coroutine to fetch the data, and update itself when the fetch has completed. There are several files being modified in this step; we'll work our way from the data module up through the app module a piece at a time. data Rating.kt Rating <-> Movie is a one-to-many relationship. We can use a non- @Entity Kotlin data class to tell Room to fetch the Rating and its Movies at the same time. First, we create a helper class, RatingWithMovies to ask Room to fetch the Rating and its Movies . We'll be asking the DAO to fetch a single Rating by its id . We'll hold onto it in the @Embedded rating property. Room sees the @Relation annotation on the movies property and runs a query to fetch all Movies that have a ratingId value that matches the Rating id . data MovieDAO.kt We add a new @Query to the DAO to look up a single Rating by its id . Note the return type! We're not returning an entity here; we're returning the new RatingWithMovies data class. Because it contains a @Relation annotation, Room will need to run an additional query to fetch the Movies . To ensure we're seeing consistent data, we must annotate getRatingWithMovies with @Transaction so no database updates can occur between the Rating query and the query to get its Movies . repository Rating.kt Moving up to the repository module, we create a corresponding Data Transfer Object RatingWithMoviesDto and a toDto function to make the transform easy. repository MovieRepository, MovieDatabaseRepository The screen will be fetching the Rating by its id and using its result. We can't do this on the UI thread or the user interface can become less responsive and appear \"janky\". So the screen will kick off a coroutine to fetch the Rating and its Movies . We expose the fetching functionality through the MovieRepository as a one-shot suspend function (which in turn will be exposed through the MovieViewModel for the UI to call). app MovieViewModel Because we're adding a new Screen , we need to create data to represent it. The \"rating screen\" needs to know which Rating to display, so we cannot use a singleton object ; we'll need separate instances for each time we see a rating screen. We define a Kotlin data class called RatingScreen (implementing Screen ) to track this. To facilitate the Rating lookup, we define a passthrough getRatingWithMovies function, which asks the repository module to fetch the data (which in turn asks the data module to fetch the data.) app MainActivity.kt (This file is getting big and managing too many different things... we'll clean that up in the next step.) Let's look at each of the changed pieces. SimpleText and SimpleButton I'm tweaking these functions to allow text to be clicked (so we can click a Rating and switch to the rating display screen). The .clickable modifier handles this. Unfortunately I had used SimpleText inside of a Button , and this change would override the button-click functionality! So I converted the text display in the button back to Compose's Text . Screen Selection The when expression used to determine what to display on the screen now includes the RatingScreen . We need to check for it using is RatingScreen , which checks to see if the screen is an instance of RatingScreen , rather than comparing it to a singleton object value as we did for the lists. We also add a \"what to do when the name of a Rating is clicked on the RatingList \" lambda to the RatingList function. Rating Display The RatingDisplay function has some interesting features that we'll touch upon here and cover in more detail when we talk about Compose. First, the parameters: We pass in the id of the Rating we want to display. We need to look up the Rating (and its Movies ). To perform the lookup, we pass in a fetchRatingsWithMovies function. fetchRatingWithMovies : suspend ( String ) -> RatingWithMoviesDto This function takes a String (the rating id) as a parameter, and returns a RatingWithMoviesDto . Because it will need to call suspend functions to perform this one-shot fetch, this function must also be a suspend function. You'll get used to function-type syntax like this pretty quickly; you'll see it a lot. Whenever you see -> inside a parameter type, you know a function is being passed in. The parameter list for that function appears in (...) and the return type appears after the -> . If we pass in a function that doesn't return anything, we'll use Unit as the return type. Unit means \"just perform some processing; don't return a value\". Next, you'll see var ratingWithMoviesDto by remember { mutableStateOf < RatingWithMoviesDto?> ( null ) } There's a lot going on there, and we'll cover it in detail later. For right now, think of this as a fancy way to declare a local variable in Compose, conceptually similar to var ratingWithMoviesDto : RatingWithMoviesDto = null This variable is used as the data that the rest of the function displays on the UI. But we need to fetch that data. To do this, we launch a coroutine and set that local variable: LaunchedEffect ( key1 = ratingId ) { // starts a coroutine to fetch the rating ratingWithMoviesDto = fetchRatingWithMovies ( ratingId ) } A coroutine is launched whenever the passed-in ratingId value changes (if the last rating was still being fetched, that coroutine will be canceled). Finally, we create the UI. We use Kotlin's let scoping function to only display the data if a rating has been fetched. By writing ratingWithMoviesDto ?. let { ratingWithMovies -> ... } We check if ratingWithMoviesDto is non-null, and if so, call let passing in that non-null value. Keep in mind that ratingWithMoviesDto is set by a coroutine, and could change at any time; using this let call will capture its value so we have a consistent value to work with in the let body.","title":"Rating with Movies"},{"location":"week-03/3.2-Movie-Database/STEP_100_REPO.html#data-ratingkt","text":"Rating <-> Movie is a one-to-many relationship. We can use a non- @Entity Kotlin data class to tell Room to fetch the Rating and its Movies at the same time. First, we create a helper class, RatingWithMovies to ask Room to fetch the Rating and its Movies . We'll be asking the DAO to fetch a single Rating by its id . We'll hold onto it in the @Embedded rating property. Room sees the @Relation annotation on the movies property and runs a query to fetch all Movies that have a ratingId value that matches the Rating id .","title":"data Rating.kt"},{"location":"week-03/3.2-Movie-Database/STEP_100_REPO.html#data-moviedaokt","text":"We add a new @Query to the DAO to look up a single Rating by its id . Note the return type! We're not returning an entity here; we're returning the new RatingWithMovies data class. Because it contains a @Relation annotation, Room will need to run an additional query to fetch the Movies . To ensure we're seeing consistent data, we must annotate getRatingWithMovies with @Transaction so no database updates can occur between the Rating query and the query to get its Movies .","title":"data MovieDAO.kt"},{"location":"week-03/3.2-Movie-Database/STEP_100_REPO.html#repository-ratingkt","text":"Moving up to the repository module, we create a corresponding Data Transfer Object RatingWithMoviesDto and a toDto function to make the transform easy.","title":"repository Rating.kt"},{"location":"week-03/3.2-Movie-Database/STEP_100_REPO.html#repository-movierepository-moviedatabaserepository","text":"The screen will be fetching the Rating by its id and using its result. We can't do this on the UI thread or the user interface can become less responsive and appear \"janky\". So the screen will kick off a coroutine to fetch the Rating and its Movies . We expose the fetching functionality through the MovieRepository as a one-shot suspend function (which in turn will be exposed through the MovieViewModel for the UI to call).","title":"repository MovieRepository, MovieDatabaseRepository"},{"location":"week-03/3.2-Movie-Database/STEP_100_REPO.html#app-movieviewmodel","text":"Because we're adding a new Screen , we need to create data to represent it. The \"rating screen\" needs to know which Rating to display, so we cannot use a singleton object ; we'll need separate instances for each time we see a rating screen. We define a Kotlin data class called RatingScreen (implementing Screen ) to track this. To facilitate the Rating lookup, we define a passthrough getRatingWithMovies function, which asks the repository module to fetch the data (which in turn asks the data module to fetch the data.)","title":"app MovieViewModel"},{"location":"week-03/3.2-Movie-Database/STEP_100_REPO.html#app-mainactivitykt","text":"(This file is getting big and managing too many different things... we'll clean that up in the next step.) Let's look at each of the changed pieces.","title":"app MainActivity.kt"},{"location":"week-03/3.2-Movie-Database/STEP_100_REPO.html#simpletext-and-simplebutton","text":"I'm tweaking these functions to allow text to be clicked (so we can click a Rating and switch to the rating display screen). The .clickable modifier handles this. Unfortunately I had used SimpleText inside of a Button , and this change would override the button-click functionality! So I converted the text display in the button back to Compose's Text .","title":"SimpleText and SimpleButton"},{"location":"week-03/3.2-Movie-Database/STEP_100_REPO.html#screen-selection","text":"The when expression used to determine what to display on the screen now includes the RatingScreen . We need to check for it using is RatingScreen , which checks to see if the screen is an instance of RatingScreen , rather than comparing it to a singleton object value as we did for the lists. We also add a \"what to do when the name of a Rating is clicked on the RatingList \" lambda to the RatingList function.","title":"Screen Selection"},{"location":"week-03/3.2-Movie-Database/STEP_100_REPO.html#rating-display","text":"The RatingDisplay function has some interesting features that we'll touch upon here and cover in more detail when we talk about Compose. First, the parameters: We pass in the id of the Rating we want to display. We need to look up the Rating (and its Movies ). To perform the lookup, we pass in a fetchRatingsWithMovies function. fetchRatingWithMovies : suspend ( String ) -> RatingWithMoviesDto This function takes a String (the rating id) as a parameter, and returns a RatingWithMoviesDto . Because it will need to call suspend functions to perform this one-shot fetch, this function must also be a suspend function. You'll get used to function-type syntax like this pretty quickly; you'll see it a lot. Whenever you see -> inside a parameter type, you know a function is being passed in. The parameter list for that function appears in (...) and the return type appears after the -> . If we pass in a function that doesn't return anything, we'll use Unit as the return type. Unit means \"just perform some processing; don't return a value\". Next, you'll see var ratingWithMoviesDto by remember { mutableStateOf < RatingWithMoviesDto?> ( null ) } There's a lot going on there, and we'll cover it in detail later. For right now, think of this as a fancy way to declare a local variable in Compose, conceptually similar to var ratingWithMoviesDto : RatingWithMoviesDto = null This variable is used as the data that the rest of the function displays on the UI. But we need to fetch that data. To do this, we launch a coroutine and set that local variable: LaunchedEffect ( key1 = ratingId ) { // starts a coroutine to fetch the rating ratingWithMoviesDto = fetchRatingWithMovies ( ratingId ) } A coroutine is launched whenever the passed-in ratingId value changes (if the last rating was still being fetched, that coroutine will be canceled). Finally, we create the UI. We use Kotlin's let scoping function to only display the data if a rating has been fetched. By writing ratingWithMoviesDto ?. let { ratingWithMovies -> ... } We check if ratingWithMoviesDto is non-null, and if so, call let passing in that non-null value. Keep in mind that ratingWithMoviesDto is set by a coroutine, and could change at any time; using this let call will capture its value so we have a consistent value to work with in the let body.","title":"Rating Display"},{"location":"week-03/3.2-Movie-Database/STEP_110_REPO.html","text":"That MainActivity has become quite the mess. While it can be tempting to start off throwing all of your @Composable functions into the same file, try to avoid that temptation, as you'll quickly end up with our current mess. In this step, I've moved the functions out into their own files. SimpleButton and SimpleText have been moved to a components package, and the other @Composable functions moved into a screens package. Much better now!","title":"Refactoring"},{"location":"week-03/3.2-Movie-Database/STEP_120_FULL.html","text":"We'll stop here for now and flesh this example out more over time. We'll need to fill in all of the details for displaying Movies and Actors and create a nice user interface. For now, we have enough of an example to create your first real assignment!","title":"Wrap-Up"},{"location":"week-04/4.1-Compose-basics/index.html","text":"Now that we have a Data Layer (using Android Room and a Repository), let's focus on our User Interface layer . We'll be using Jetpack Compose to implement our user interface, but before we start talking about the UI, what is Jetpack Compose? There are two general parts that make up Compose: Runtime - general-purpose framework for creating trees and managing state UI - user-interface components in the form of Composable Functions , that emit tree nodes The runtime can do much more than manage UI trees, and I look forward to it being used for other tree management as developers discover this. (Currently these two parts are usually thought of as a \"UI framework\", but hopefully Google will refactor them into separate dependencies to encourage the runtime use in other contexts). Note If you're interested in an example of the runtime being used outside Compose UI, take a look at https://arunkumar.dev/jetpack-compose-for-non-ui-tree-construction-and-code-generation/ , exploring code-generation using Compose runtime. Kotlin-Only Jetpack Compose uses some advanced features of Kotlin, including its compiler-plugin support. Because of this, you can only use Jetpack Compose inside a Kotlin compilation unit (file, class, interface, etc) Declaring a Tree Jetpack Compose is a declarative framework. Chances are, most of the programming you've done is imperative . You've written code that describes how to do something, as a series of steps and calls to other code that describes how to do something. Imperative programming is quite useful, but requires that you specify how to do a task, which tends to be verbose and forces you to define abstractions when you want to hide that how . A typical imperative user interface consists of calls to functions that present a UI on the screen. Declarative programming means you specify what you want to do or what you want your output to look like. You may have heard of Domain-Specific Langauges (DSLs). These are little languages that are often used to describe what to do. For example, using a tool like ANTLR https://www.antlr.org/ , you define a grammar that describes what a language looks like, with embedded actions to perform work when you see certain constructs. Tools like these are often used to create compilers (translating code in that language to lower-level code), interpreters (running code in that the language directly) or static analyzers (examining code in that language to produce reports). A declarative user-interface consists of calls that describe the user interface, and other parts of the UI framework render it. That may not seem like a big distinction, but it allows for some great optimization (and potentially parallel processing) when rendering. We declare a tree that represents the UI by defining Composable Functions . Annotating a function with @Composable declares it will be emitting nodes to a tree or defining data for use during composition. The Compose compiler plugin tweaks the definition of the function to add a Composer parameter, which has an emit function that adds to the tree. Some lower-level composable functions will emit nodes; some functions will simply call other composable functions to build up more complex structures. When you define your composable functions, you probably won't be emitting nodes directly. Rather, you'll declare your user interface using existing components declared using other composable functions. Note You'll probably hear at some point that under the covers, the tree that represents the UI is implemented using a * Gap Buffer data structure known as the \"slot table\", which is an Array with a moveable empty chunk of nodes that optimizes updates and reads. If you want to really dig deep into the internals, you may want to read https://medium.com/@takahirom/inside-jetpack-compose-2e971675e55e or https://jorgecastillo.dev/book/ . You don't need to know this level of detail, but there are some pretty cool things going on behind the scenes. It's important to think of your Composable functions as declaring your user interface, as much happens between the time you declare it and its realization on the screen. Note We've been talking about Compose emitting nodes to \"a tree\". Compose actually keeps track of two trees: Composition Tree - the tree that contains the description of your user interface Semantics Tree - a parallel tree that adds metadata about the composition. This metadata is typically Accessibility data and actions Test data such as labels to access nodes in the composition tree We'll look into the Semantics Tree in more detail when we discuss testing our applications. Composition vs Recomposition Your composable functions will be called a lot , potentially for every frame displayed to the user. Info \"Frame\" is a term used in computer animation, describing a unique image shown to the user. During an animation, multiple frames are displayed to the user at a rate that tricks the eye into thinking things are moving on the screen. The \"frame-rate\" is measured in \"frames-per-second\" or more generally, \"hertz\". Hertz is a unit of frequency , where 1hz is one cycle per second. The higher the frequency, the faster the animation and less the eye can detect the switching between images. Faster animation appears smoother. If anything delays a new image from being displayed on time, the user experiences \"jank\", a visual pause in the animation, which can be very distracting. Think about watching a show on a streaming service, and suddenly the image freezes due to network slowness and then restarts. That's an extreme case of jankiness, but the human eye can detect much smaller pauses during a smooth animation. Composition is the first time a composable function is called. Your function will declare the entire visible user interface and return. Recomposition is later calls to the same function when the data passed has changed. Jetpack Compose uses a Snapshot System to track data that's been previously passed to functions, and compares the last values to current values. Let's take a look at an example: @Composable fun MyScreen ( count : Int , name : String , ) { Column { TopPart ( count = count ) BottomPart ( name = name ) } } @Composable fun TopPart ( count : Int , ) { ... } @Composable fun BottomPart ( name : String , ) { ... } Suppose in our initial composition, we call MyScreen ( viewModel . count , viewModel . name ) (assuming viewModel.count and viewModel.name are state that is observable by Jetpack Compose - we'll describe that in more detail later). During initial composition, count is 1 and name is \"Scott\". Compose's snapshot system remembers this. The UI tree is emitted and rendered. Later, the user does something that changes the name, but not the count. Compose detects the change to name, and asks MyScreen and BottomPart to update their parts of the tree. The tree changes are detected by compose and trigger updates to those parts of the screen. Note that TopPart isn't asked to recompose. How can this be? Unidirectional Data Flow Composable functions take two kinds of parameters: Data - the state that drives what the user will see Event functions - functional parameters that inform the caller when something happens Data is passed down, from composable function to other composable functions. Composable functions do not access any data outside of them unless that access is controlled (more on that later). If a composable function needs to modify data, it does not directly perform the update; it calls one of its function parameters to inform the caller of the update. This ensures that the part of your application that manages its state is involved in all updates, keeping its state consistent. Data in; function calls out. For example: @Composable fun MyButton ( text : String , onClick : () -> Unit , ) { ... } We pass text in to be displayed on the button, and call onClick when the user clicks the button. Composition Locals Caution I strongly advise against creating your own composition locals unless you have a very good reason to do so. They make composable functions more difficult to reason about and more difficult to test. Compose supports implicitly-available scoped data objects called \"Composition Locals\". These objects are scoped at some level of the tree and available to all composable functions nested within that level, without passing them as parameters. There are some pre-defined composition locals, including MaterialTheme - gives access to colors, fonts, etc LocalDensity - describes the screen density and provides functions for converting between density-independent pixels and screen pixels LocalContext - access to the current Android context (usually an Activity) as a handle to resources and platform features You access them by making a call like @Composable fun SomeComposable ( padding : Dp , ) { with ( LocalDensity . current ) { val paddingInPixels = padding . toPx () // use graphics-drawing features that require pixels } } You can define your own composition locals, but you generally shouldn't. You may think they're convenient for making values available down through a long call chain, but that makes the functions more difficult to reason about and test. See https://developer.android.com/jetpack/compose/compositionlocal for a more detailed discussion if you're thinking about creating one. Idempotency and Stable Data Composable functions use data that's passed into them to determine what to emit. If a composable function is called with the same data parameters, it should emit the same nodes to the tree. This concept is called idempotency , and is key to Compose's optimization. If a function is idempotent , Compose can assume that if the parameters haven't changed, it doesn't need to refresh that part of the UI. But Compose can only do this if it knows the data coming in is stable . Stable data is data that Compose can track for changes. Think about a Person class like data class Person ( var name : String , var age : Int , ) If we pass in an instance of Person to a Composable function, there's no way for Compose to know when the name or age change; it cannot know when to perform updates. It's also possible for the function to update the Person directly and nothing outside the function would know. And even more dangerously - if another thread updates that Person at the same time the tree nodes are being emitted, the displayed data could be inconsistent. For example: We pass in Person(\"Scott\", 55) to a composable function The function creates a Text node to display \"Scott\" Another thread updates the name and age of the Person to \"Mikey\" and 10 . The function creates a Text node to display 10 . The displayed data is inconsistent. Stable data is usually made up of Jetpack Compose State objects. Whenever State is read, the Compose snapshot system takes a note of the read at the current point of the composition, and watches it for changes. If the State changes, compose starts recomposition and knows exactly which parts of the tree to re-emit. In the above example, Compose would know that the name and age have changed and would recompose again. For a class to be Stable , all properties of that class must be Stable as well. Immutable data is the lowest-level Stable data in a passed-in data structure. Immutable data is data that cannot be changed (and must be deeply immutable - all of its properties are immutable all the way down). We'll talk about Stable State in more detail later, but as a quick example: class Person ( initialName : String = \"\" , initialAge : Int = 0 , ) { var name by mutableStateOf < String > ( initialName ) var age by mutableStateOf < Int > ( initialAge ) var bestFriend by mutableStateOf < Person?> ( null ) } There's a lot to unpack here: You can pass in a name and age when creating a Person , or let them default to \"\" and 0 respectively. name is managed by a Compose MutableState object. Whenever it is read or updated, the Compose snapshot system takes note or starts recomposition (similar for age and bestFriend ). The by keyword in Kotlin delegates a property to an object that manages its data. Looking at name : The name property has no backing field, so it cannot store its own data. Whenever name is read, Kotlin asks the delegate object (the MutableState ) to get the value. Whenever name is changed, Kotlin asks the delegate to set the value. This is similar to writing private var nameState = mutableStateOf < String > ( initialName ) var name : String get () = nameState . value set ( value ) { nameState . value = value } The MutableState instance has get and set functions that interact with the Snapshot system. That's what makes the magic happen! The values of name and age are Immutable . The value of bestFriend is Stable ; Compose can listen to its properties for changes. Data that is not stable can be passed to a Composable function, but the function won't be able to skip calls that use that data. For a great deep-dive into stability, see https://medium.com/androiddevelopers/jetpack-compose-stability-explained-79c10db270c8 . Uncontrolled Side Effects Uncontrolled side effects are data access or changes that happen outside of a composable function. Suppose we had the following: // DO NOT DO THIS!!! var count = 1 @Composable fun DoNotDoThis ( text : String , onClick : () -> Unit , ) { count ++ Text ( text = count . toString ()) ... } This function is not idempotent. Each time you call it with the same parameters, you'll get a different count printed, and that count variable is updated whenever the the function is recomposed. Later we'll see that we can use controlled side effects to perform processing that compose is aware of. Calling Composable Functions Composable functions can only be called from other composable functions, or from Kotlin inline functions. Note Most collection/stream functions are inline . This means that the call is replaced by the body of the function. You can use functions like these to call other composable functions. For example: @Composable fun ShowList ( list : List < String > , ) { list . forEach { item -> Text ( text = item ) } }","title":"Compose Basics"},{"location":"week-04/4.1-Compose-basics/index.html#kotlin-only","text":"Jetpack Compose uses some advanced features of Kotlin, including its compiler-plugin support. Because of this, you can only use Jetpack Compose inside a Kotlin compilation unit (file, class, interface, etc)","title":"Kotlin-Only"},{"location":"week-04/4.1-Compose-basics/index.html#declaring-a-tree","text":"Jetpack Compose is a declarative framework. Chances are, most of the programming you've done is imperative . You've written code that describes how to do something, as a series of steps and calls to other code that describes how to do something. Imperative programming is quite useful, but requires that you specify how to do a task, which tends to be verbose and forces you to define abstractions when you want to hide that how . A typical imperative user interface consists of calls to functions that present a UI on the screen. Declarative programming means you specify what you want to do or what you want your output to look like. You may have heard of Domain-Specific Langauges (DSLs). These are little languages that are often used to describe what to do. For example, using a tool like ANTLR https://www.antlr.org/ , you define a grammar that describes what a language looks like, with embedded actions to perform work when you see certain constructs. Tools like these are often used to create compilers (translating code in that language to lower-level code), interpreters (running code in that the language directly) or static analyzers (examining code in that language to produce reports). A declarative user-interface consists of calls that describe the user interface, and other parts of the UI framework render it. That may not seem like a big distinction, but it allows for some great optimization (and potentially parallel processing) when rendering. We declare a tree that represents the UI by defining Composable Functions . Annotating a function with @Composable declares it will be emitting nodes to a tree or defining data for use during composition. The Compose compiler plugin tweaks the definition of the function to add a Composer parameter, which has an emit function that adds to the tree. Some lower-level composable functions will emit nodes; some functions will simply call other composable functions to build up more complex structures. When you define your composable functions, you probably won't be emitting nodes directly. Rather, you'll declare your user interface using existing components declared using other composable functions. Note You'll probably hear at some point that under the covers, the tree that represents the UI is implemented using a * Gap Buffer data structure known as the \"slot table\", which is an Array with a moveable empty chunk of nodes that optimizes updates and reads. If you want to really dig deep into the internals, you may want to read https://medium.com/@takahirom/inside-jetpack-compose-2e971675e55e or https://jorgecastillo.dev/book/ . You don't need to know this level of detail, but there are some pretty cool things going on behind the scenes. It's important to think of your Composable functions as declaring your user interface, as much happens between the time you declare it and its realization on the screen. Note We've been talking about Compose emitting nodes to \"a tree\". Compose actually keeps track of two trees: Composition Tree - the tree that contains the description of your user interface Semantics Tree - a parallel tree that adds metadata about the composition. This metadata is typically Accessibility data and actions Test data such as labels to access nodes in the composition tree We'll look into the Semantics Tree in more detail when we discuss testing our applications.","title":"Declaring a Tree"},{"location":"week-04/4.1-Compose-basics/index.html#composition-vs-recomposition","text":"Your composable functions will be called a lot , potentially for every frame displayed to the user. Info \"Frame\" is a term used in computer animation, describing a unique image shown to the user. During an animation, multiple frames are displayed to the user at a rate that tricks the eye into thinking things are moving on the screen. The \"frame-rate\" is measured in \"frames-per-second\" or more generally, \"hertz\". Hertz is a unit of frequency , where 1hz is one cycle per second. The higher the frequency, the faster the animation and less the eye can detect the switching between images. Faster animation appears smoother. If anything delays a new image from being displayed on time, the user experiences \"jank\", a visual pause in the animation, which can be very distracting. Think about watching a show on a streaming service, and suddenly the image freezes due to network slowness and then restarts. That's an extreme case of jankiness, but the human eye can detect much smaller pauses during a smooth animation. Composition is the first time a composable function is called. Your function will declare the entire visible user interface and return. Recomposition is later calls to the same function when the data passed has changed. Jetpack Compose uses a Snapshot System to track data that's been previously passed to functions, and compares the last values to current values. Let's take a look at an example: @Composable fun MyScreen ( count : Int , name : String , ) { Column { TopPart ( count = count ) BottomPart ( name = name ) } } @Composable fun TopPart ( count : Int , ) { ... } @Composable fun BottomPart ( name : String , ) { ... } Suppose in our initial composition, we call MyScreen ( viewModel . count , viewModel . name ) (assuming viewModel.count and viewModel.name are state that is observable by Jetpack Compose - we'll describe that in more detail later). During initial composition, count is 1 and name is \"Scott\". Compose's snapshot system remembers this. The UI tree is emitted and rendered. Later, the user does something that changes the name, but not the count. Compose detects the change to name, and asks MyScreen and BottomPart to update their parts of the tree. The tree changes are detected by compose and trigger updates to those parts of the screen. Note that TopPart isn't asked to recompose. How can this be?","title":"Composition vs Recomposition"},{"location":"week-04/4.1-Compose-basics/index.html#unidirectional-data-flow","text":"Composable functions take two kinds of parameters: Data - the state that drives what the user will see Event functions - functional parameters that inform the caller when something happens Data is passed down, from composable function to other composable functions. Composable functions do not access any data outside of them unless that access is controlled (more on that later). If a composable function needs to modify data, it does not directly perform the update; it calls one of its function parameters to inform the caller of the update. This ensures that the part of your application that manages its state is involved in all updates, keeping its state consistent. Data in; function calls out. For example: @Composable fun MyButton ( text : String , onClick : () -> Unit , ) { ... } We pass text in to be displayed on the button, and call onClick when the user clicks the button.","title":"Unidirectional Data Flow"},{"location":"week-04/4.1-Compose-basics/index.html#composition-locals","text":"Caution I strongly advise against creating your own composition locals unless you have a very good reason to do so. They make composable functions more difficult to reason about and more difficult to test. Compose supports implicitly-available scoped data objects called \"Composition Locals\". These objects are scoped at some level of the tree and available to all composable functions nested within that level, without passing them as parameters. There are some pre-defined composition locals, including MaterialTheme - gives access to colors, fonts, etc LocalDensity - describes the screen density and provides functions for converting between density-independent pixels and screen pixels LocalContext - access to the current Android context (usually an Activity) as a handle to resources and platform features You access them by making a call like @Composable fun SomeComposable ( padding : Dp , ) { with ( LocalDensity . current ) { val paddingInPixels = padding . toPx () // use graphics-drawing features that require pixels } } You can define your own composition locals, but you generally shouldn't. You may think they're convenient for making values available down through a long call chain, but that makes the functions more difficult to reason about and test. See https://developer.android.com/jetpack/compose/compositionlocal for a more detailed discussion if you're thinking about creating one.","title":"Composition Locals"},{"location":"week-04/4.1-Compose-basics/index.html#idempotency-and-stable-data","text":"Composable functions use data that's passed into them to determine what to emit. If a composable function is called with the same data parameters, it should emit the same nodes to the tree. This concept is called idempotency , and is key to Compose's optimization. If a function is idempotent , Compose can assume that if the parameters haven't changed, it doesn't need to refresh that part of the UI. But Compose can only do this if it knows the data coming in is stable . Stable data is data that Compose can track for changes. Think about a Person class like data class Person ( var name : String , var age : Int , ) If we pass in an instance of Person to a Composable function, there's no way for Compose to know when the name or age change; it cannot know when to perform updates. It's also possible for the function to update the Person directly and nothing outside the function would know. And even more dangerously - if another thread updates that Person at the same time the tree nodes are being emitted, the displayed data could be inconsistent. For example: We pass in Person(\"Scott\", 55) to a composable function The function creates a Text node to display \"Scott\" Another thread updates the name and age of the Person to \"Mikey\" and 10 . The function creates a Text node to display 10 . The displayed data is inconsistent. Stable data is usually made up of Jetpack Compose State objects. Whenever State is read, the Compose snapshot system takes a note of the read at the current point of the composition, and watches it for changes. If the State changes, compose starts recomposition and knows exactly which parts of the tree to re-emit. In the above example, Compose would know that the name and age have changed and would recompose again. For a class to be Stable , all properties of that class must be Stable as well. Immutable data is the lowest-level Stable data in a passed-in data structure. Immutable data is data that cannot be changed (and must be deeply immutable - all of its properties are immutable all the way down). We'll talk about Stable State in more detail later, but as a quick example: class Person ( initialName : String = \"\" , initialAge : Int = 0 , ) { var name by mutableStateOf < String > ( initialName ) var age by mutableStateOf < Int > ( initialAge ) var bestFriend by mutableStateOf < Person?> ( null ) } There's a lot to unpack here: You can pass in a name and age when creating a Person , or let them default to \"\" and 0 respectively. name is managed by a Compose MutableState object. Whenever it is read or updated, the Compose snapshot system takes note or starts recomposition (similar for age and bestFriend ). The by keyword in Kotlin delegates a property to an object that manages its data. Looking at name : The name property has no backing field, so it cannot store its own data. Whenever name is read, Kotlin asks the delegate object (the MutableState ) to get the value. Whenever name is changed, Kotlin asks the delegate to set the value. This is similar to writing private var nameState = mutableStateOf < String > ( initialName ) var name : String get () = nameState . value set ( value ) { nameState . value = value } The MutableState instance has get and set functions that interact with the Snapshot system. That's what makes the magic happen! The values of name and age are Immutable . The value of bestFriend is Stable ; Compose can listen to its properties for changes. Data that is not stable can be passed to a Composable function, but the function won't be able to skip calls that use that data. For a great deep-dive into stability, see https://medium.com/androiddevelopers/jetpack-compose-stability-explained-79c10db270c8 .","title":"Idempotency and Stable Data"},{"location":"week-04/4.1-Compose-basics/index.html#uncontrolled-side-effects","text":"Uncontrolled side effects are data access or changes that happen outside of a composable function. Suppose we had the following: // DO NOT DO THIS!!! var count = 1 @Composable fun DoNotDoThis ( text : String , onClick : () -> Unit , ) { count ++ Text ( text = count . toString ()) ... } This function is not idempotent. Each time you call it with the same parameters, you'll get a different count printed, and that count variable is updated whenever the the function is recomposed. Later we'll see that we can use controlled side effects to perform processing that compose is aware of.","title":"Uncontrolled Side Effects"},{"location":"week-04/4.1-Compose-basics/index.html#calling-composable-functions","text":"Composable functions can only be called from other composable functions, or from Kotlin inline functions. Note Most collection/stream functions are inline . This means that the call is replaced by the body of the function. You can use functions like these to call other composable functions. For example: @Composable fun ShowList ( list : List < String > , ) { list . forEach { item -> Text ( text = item ) } }","title":"Calling Composable Functions"},{"location":"week-04/4.1-Compose-basics/STEP_10_FULL.html","text":"Let's write some composable functions and learn more about them. We'll do a full walkthrough for the Movie example in a later module. Where to Start Jetpack Compose defines an extension function ComponentActivity.setContent . This is your starting point for declaring your user interface. A typical Jetpack Compose activity looks like class MainActivity : ComponentActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { DeleteMe5Theme { Surface ( modifier = Modifier . fillMaxSize (), color = MaterialTheme . colors . background ) { Greeting ( \"Android\" ) } } } } } @Composable fun Greeting ( name : String , ) { Text ( text = \"Hello $ name !\" ) } The onCreate function is called when the Android framework is ready for us to declare the user interface. In the old view-based framework, onCreate would be used to read an XML file describing the user interface and instantiate the classes needed to run that UI. For Compose, it's much simpler; we just write functions. What does the above do? onCreate calls setContent passing a composable lambda that calls other composable functions to declare the user interface. DeleteMe5Theme is a composable function that sets up the MaterialTheme composition local. This makes its colors and fonts available to all composable functions called from its lamba. Surface declares the background of the UI, filling the available activity area. It calls Greeting to declare what the UI looks like. Greeting is a composable function that's defined by this application, which calls Text to display the text \"Hello Android\" Running the above results in Not the most interesting user interface, but it's a start! The View Model Static user interfaces are rarely useful; we really need dynamic data. We've talked about the Data Layer exposing data, directly via one-shot functions, or using Flows to emit a stream of values. We need to expose them in the User Interface Layer . There are many ways to do this; we'll use a View Model . Note The concept of a \"View Model\" is the set of objects that provide data and logic needed for a user interface. Some logic is \"business logic\", and is necessary for any use of the data. Other logic is only necessary for specific user interface implementations. Consider a web-based application, a desktop application and a mobile application that all expose the same data. Each type of user interface needs some logic to prepare the data for use in that user interface, but they can all share business logic (in the Data Layer or Domain Layer ) to manage the data itself. The \"Android Architecture Components\" (AAC) define a specific class called ViewModel which can be used as part of the conceptual \"View Model\" in our application, but has specific lifecycle tie-ins (for better or worse). We'll use an AAC ViewModel , but keep in mind that there are debates in the community about it, some saying we don't need it. The user-interface logic needs to exist somewhere , and until we've got better guidance, we'll stick with the AAC ViewModel . Please keep your eyes posted for alternative recommendations! Configuration Changes One of the big \"gotchas\" in Android application development is a \"configuration change\". The current configuration of a device includes Device orientation Language and region Screen width and height Android API level Screen density Day/Night mode UI Mode (phone, car, desktop, tv etc) Some aspects of the configuration can change, such as the user selecting a different language, or, more commonly, rotating the device. When an Activity is started, any resources it references are selected based on the current configuration. Strings are a good example here. If you define your user-visible strings in src/ main/ res/ values/ strings.xml and reference the string in your Activity (we'll do that using Compose's stringResource function), it's pulled from the best-matching values directory. The above directory structure represents where the default string values reside. By adding a suffix on the values directory, we can set up more-specific overrides. For example: src/ main/ res/ values/ strings.xml values-land/ strings.xml values-es/ strings.xml values-fr-rFR/ strings.xml values-fr-rCA/ strings.xml The values-es directory will take precedence when the language is Spanish. The values-fr-rFR and values-FR-rCA will take precedence when the language is French ahd the region is France or Canada. Other resource directories, such as drawable might be modified based on available screen space: drawable-w720dp would take precedence over drawable when there are at least 720 density-independent pixels available in the current screen width. Users can change some aspects of a configuration while an application is running, and we may need to refresh the user interface in response. To make this easy, Android (by default) destroys the Activity instance and recreates it, choosing the new best-batch resources when requested. Because the Activity is destroyed, any data residing inside it is lost unless you do something specific to save that data. Some data is persistent (saved in the Data Layer ) and can easily be re-fetched, but other data, such as \"which Person is displayed on the screen, may only needed while the application is running. Keeping Data via ViewModel The AAC ViewModel stays alive as long as any instance of the Activity is alive, and can hold any data you want to survive a configuration change. During a configuration change, the new instance of the Activity is created before the old instance is destroyed. The same ViewModel instance is supplied to the new Activity, making the existing data available to it. Remember how our ViewModel fits into our architecture? Without Domain Layer With Domain Layer flowchart LR subgraph User Interface Layer ui[User Interface] --> vm[View Model] end vm --> repo ds1 --> db[(Database)] ds2 --> file(((File))) ds3 --> ws(((Web Service))) subgraph Data Layer direction LR repo[Repository] --> ds1[Data Source 1] repo[Repository] --> ds2[Data Source 2] repo[Repository] --> ds3[Data Source 3] end flowchart LR subgraph User Interface Layer ui[User Interface] --> vm[View Model] end vm --> uc1 vm --> uc2 vm --> uc3 vm --> data uc1 --> repo uc2 --> repo uc3 --> repo data --> repo ds1 --> db[(Database)] ds2 --> file(((File))) ds3 --> ws(((Web Service))) subgraph Domain Layer direction LR data[Data] uc1[Use Case 1] uc2[Use Case 2] uc3[Use Case 3] end subgraph Data Layer direction LR repo[Repository] --> ds1[Data Source 1] repo[Repository] --> ds2[Data Source 2] repo[Repository] --> ds3[Data Source 3] end Let's define a ViewModel and use it in a composable function. Important Only the top level of composable functions should touch the view model! All other composable functions should be passed data that was made available in the view model. The top-level composable will get data from thew view model and call view-model functions in response to events passed up from called composable functions. Sample View Model Suppose we have defined a PersonRepository : interface PersonRepository { val peopleFlow : Flow < List < PersonDto >> suspend fun getPerson ( id : String ): PersonDto suspend fun insert ( vararg people : PersonDto ) suspend fun update ( vararg people : PersonDto ) suspend fun delete ( vararg people : PersonDto ) } A simple view model using this might look like class PersonViewModel ( application : Application ) : AndroidViewModel ( application ) { private val repository = PersonDatabaseRepository ( application ) val peopleFlow = repository . peopleFlow suspend fun getPerson ( id : String ) = repository . getPerson ( id ) suspend fun insert ( vararg people : PersonDto ) = repository . insert ( * people ) suspend fun update ( vararg people : PersonDto ) = repository . update ( * people ) suspend fun delete ( vararg people : PersonDto ) = repository . delete ( * people ) } This view model only acts as a handle for the repository and passes-through all functions. But most view models will add more functionality (we'll see some later).","title":"Writing Composable Functions"},{"location":"week-04/4.1-Compose-basics/STEP_10_FULL.html#where-to-start","text":"Jetpack Compose defines an extension function ComponentActivity.setContent . This is your starting point for declaring your user interface. A typical Jetpack Compose activity looks like class MainActivity : ComponentActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { DeleteMe5Theme { Surface ( modifier = Modifier . fillMaxSize (), color = MaterialTheme . colors . background ) { Greeting ( \"Android\" ) } } } } } @Composable fun Greeting ( name : String , ) { Text ( text = \"Hello $ name !\" ) } The onCreate function is called when the Android framework is ready for us to declare the user interface. In the old view-based framework, onCreate would be used to read an XML file describing the user interface and instantiate the classes needed to run that UI. For Compose, it's much simpler; we just write functions. What does the above do? onCreate calls setContent passing a composable lambda that calls other composable functions to declare the user interface. DeleteMe5Theme is a composable function that sets up the MaterialTheme composition local. This makes its colors and fonts available to all composable functions called from its lamba. Surface declares the background of the UI, filling the available activity area. It calls Greeting to declare what the UI looks like. Greeting is a composable function that's defined by this application, which calls Text to display the text \"Hello Android\" Running the above results in Not the most interesting user interface, but it's a start!","title":"Where to Start"},{"location":"week-04/4.1-Compose-basics/STEP_10_FULL.html#the-view-model","text":"Static user interfaces are rarely useful; we really need dynamic data. We've talked about the Data Layer exposing data, directly via one-shot functions, or using Flows to emit a stream of values. We need to expose them in the User Interface Layer . There are many ways to do this; we'll use a View Model . Note The concept of a \"View Model\" is the set of objects that provide data and logic needed for a user interface. Some logic is \"business logic\", and is necessary for any use of the data. Other logic is only necessary for specific user interface implementations. Consider a web-based application, a desktop application and a mobile application that all expose the same data. Each type of user interface needs some logic to prepare the data for use in that user interface, but they can all share business logic (in the Data Layer or Domain Layer ) to manage the data itself. The \"Android Architecture Components\" (AAC) define a specific class called ViewModel which can be used as part of the conceptual \"View Model\" in our application, but has specific lifecycle tie-ins (for better or worse). We'll use an AAC ViewModel , but keep in mind that there are debates in the community about it, some saying we don't need it. The user-interface logic needs to exist somewhere , and until we've got better guidance, we'll stick with the AAC ViewModel . Please keep your eyes posted for alternative recommendations!","title":"The View Model"},{"location":"week-04/4.1-Compose-basics/STEP_10_FULL.html#configuration-changes","text":"One of the big \"gotchas\" in Android application development is a \"configuration change\". The current configuration of a device includes Device orientation Language and region Screen width and height Android API level Screen density Day/Night mode UI Mode (phone, car, desktop, tv etc) Some aspects of the configuration can change, such as the user selecting a different language, or, more commonly, rotating the device. When an Activity is started, any resources it references are selected based on the current configuration. Strings are a good example here. If you define your user-visible strings in src/ main/ res/ values/ strings.xml and reference the string in your Activity (we'll do that using Compose's stringResource function), it's pulled from the best-matching values directory. The above directory structure represents where the default string values reside. By adding a suffix on the values directory, we can set up more-specific overrides. For example: src/ main/ res/ values/ strings.xml values-land/ strings.xml values-es/ strings.xml values-fr-rFR/ strings.xml values-fr-rCA/ strings.xml The values-es directory will take precedence when the language is Spanish. The values-fr-rFR and values-FR-rCA will take precedence when the language is French ahd the region is France or Canada. Other resource directories, such as drawable might be modified based on available screen space: drawable-w720dp would take precedence over drawable when there are at least 720 density-independent pixels available in the current screen width. Users can change some aspects of a configuration while an application is running, and we may need to refresh the user interface in response. To make this easy, Android (by default) destroys the Activity instance and recreates it, choosing the new best-batch resources when requested. Because the Activity is destroyed, any data residing inside it is lost unless you do something specific to save that data. Some data is persistent (saved in the Data Layer ) and can easily be re-fetched, but other data, such as \"which Person is displayed on the screen, may only needed while the application is running.","title":"Configuration Changes"},{"location":"week-04/4.1-Compose-basics/STEP_10_FULL.html#keeping-data-via-viewmodel","text":"The AAC ViewModel stays alive as long as any instance of the Activity is alive, and can hold any data you want to survive a configuration change. During a configuration change, the new instance of the Activity is created before the old instance is destroyed. The same ViewModel instance is supplied to the new Activity, making the existing data available to it. Remember how our ViewModel fits into our architecture? Without Domain Layer With Domain Layer flowchart LR subgraph User Interface Layer ui[User Interface] --> vm[View Model] end vm --> repo ds1 --> db[(Database)] ds2 --> file(((File))) ds3 --> ws(((Web Service))) subgraph Data Layer direction LR repo[Repository] --> ds1[Data Source 1] repo[Repository] --> ds2[Data Source 2] repo[Repository] --> ds3[Data Source 3] end flowchart LR subgraph User Interface Layer ui[User Interface] --> vm[View Model] end vm --> uc1 vm --> uc2 vm --> uc3 vm --> data uc1 --> repo uc2 --> repo uc3 --> repo data --> repo ds1 --> db[(Database)] ds2 --> file(((File))) ds3 --> ws(((Web Service))) subgraph Domain Layer direction LR data[Data] uc1[Use Case 1] uc2[Use Case 2] uc3[Use Case 3] end subgraph Data Layer direction LR repo[Repository] --> ds1[Data Source 1] repo[Repository] --> ds2[Data Source 2] repo[Repository] --> ds3[Data Source 3] end Let's define a ViewModel and use it in a composable function. Important Only the top level of composable functions should touch the view model! All other composable functions should be passed data that was made available in the view model. The top-level composable will get data from thew view model and call view-model functions in response to events passed up from called composable functions.","title":"Keeping Data via ViewModel"},{"location":"week-04/4.1-Compose-basics/STEP_10_FULL.html#sample-view-model","text":"Suppose we have defined a PersonRepository : interface PersonRepository { val peopleFlow : Flow < List < PersonDto >> suspend fun getPerson ( id : String ): PersonDto suspend fun insert ( vararg people : PersonDto ) suspend fun update ( vararg people : PersonDto ) suspend fun delete ( vararg people : PersonDto ) } A simple view model using this might look like class PersonViewModel ( application : Application ) : AndroidViewModel ( application ) { private val repository = PersonDatabaseRepository ( application ) val peopleFlow = repository . peopleFlow suspend fun getPerson ( id : String ) = repository . getPerson ( id ) suspend fun insert ( vararg people : PersonDto ) = repository . insert ( * people ) suspend fun update ( vararg people : PersonDto ) = repository . update ( * people ) suspend fun delete ( vararg people : PersonDto ) = repository . delete ( * people ) } This view model only acts as a handle for the repository and passes-through all functions. But most view models will add more functionality (we'll see some later).","title":"Sample View Model"},{"location":"week-04/4.1-Compose-basics/STEP_20_FULL.html","text":"We defined the following view model in the previous section: class PersonViewModel ( application : Application ) : AndroidViewModel ( application ) { private val repository = PersonDatabaseRepository ( application ) val peopleFlow = repository . peopleFlow suspend fun getPerson ( id : String ) = repository . getPerson ( id ) suspend fun insert ( vararg people : PersonDto ) = repository . insert ( * people ) suspend fun update ( vararg people : PersonDto ) = repository . update ( * people ) suspend fun delete ( vararg people : PersonDto ) = repository . delete ( * people ) } Let's define some composable functions that display a list of people, that we expose as a Flow . // only reference `viewModel()` from top-level composable function(s) @Composable fun PeopleListScreen ( viewModel : PersonViewModel = viewModel () // AAA ) { val people by // BBB viewModel . peopleFlow . collectAsState ( initial = emptyList () ) Column { // CCC Text ( // DDD text = \"People\" , style = MaterialTheme . typography . h4 , modifier = Modifier . padding ( 8. dp ) ) PeopleList ( // EEE people = people , modifier = Modifier . padding ( 8. dp ) ) } } @Composable fun PeopleList ( people : List < PersonDto > , modifier : Modifier = Modifier , // FFF ) { Column ( modifier = modifier ) { // GGG people . forEach { // HHH Text ( // III text = it . name , modifier = Modifier . padding ( 8. dp ) ) } } } Note The viewModel() function used in PeopleListScreen requires the androidx.lifecycle:lifecycle-viewmodel-compose dependency. We'll see that when we walk through the Movie example in detail. Line Description AAA The viewModel function creates a new PersonViewModel instance (it infers the type from the parameter definition), or fetches an existing one. This view model instance stays alive as long as we have an instance of the activity hosting the composition. BBB For now, think of this as \"launch a coroutine to fetch each emitted list of people, and expose it via the local people property\". We'll go through it in gory detail shortly... CCC Declare a vertical column in our user interface that hosts other composable nodes. DDD Add a label to the top of the column. We're using the typography defined by the theme, and tweaking the layout of the Text using a padding Modifier . EEE Call our PeopleList composable function. Note that we pass people , and do not pass the view model. Most of our composable functions shouldn't know that the view model even exists. FFF Note that we're passing in a Modifier so the caller can adjust our layout (or other aspects). Composables should allow a Modifier to be passed and default it to an empty Modifier or other reasonable default. The Modifier parameter should be either the last parameter or second-to-last if the last parameter is a lambda that describes enclosed content. GGG We use that passed-in Modifier in our Column definition. This allows the caller to control things like padding that affect the \"overall\" composition that this function is emitting. HHH We walk through the list of people using a standard forEach function. It's an inline function so its body can call other composable functions III Emit Text for each Person's name Note Big note here - List is not Stable as far as Compose can see. Using List here doesn't allow Compose to skip PeopleList or any composable functions called within it. But this may not be an issue. If you notice jank or other problems, take a closer look here and either replace the List with an actual immutable list implementation, or define a wrapper class that declares the list immutable by adding an @Immutable annotation (assuming nothing modifies the list or its items). Accessing Flows Let's dig into that people definition. val people by viewModel . peopleFlow . collectAsState ( initial = emptyList () ) We talked about Kotlin's by before - it delegates the get and set for a property to another object. In this case, we defined people as a val , so it only has a get to delegate. First, what does collectAsState do? @Composable fun < T : R , R > Flow < T > . collectAsState ( initial : R , context : CoroutineContext = EmptyCoroutineContext ): State < R > = produceState ( initial , this , context ) { if ( context == EmptyCoroutineContext ) { collect { value = it } } else withContext ( context ) { collect { value = it } } } It calls produceState to create a Compose MutableState instance, and then sets the value of that state to each emitted item from the Flow . Easy for me to say, but let's see what that really means by looking at produceState : @Composable fun < T > produceState ( initialValue : T , key1 : Any? , key2 : Any? , @BuilderInference producer : suspend ProduceStateScope < T > .() -> Unit ): State < T > { val result = remember { mutableStateOf ( initialValue ) } LaunchedEffect ( key1 , key2 ) { ProduceStateScopeImpl ( result , coroutineContext ). producer () } return result } Jetpack Compose State are objects that Compose can observe. When the value of State changes, Compose will trigger recomposition of any composable functions/lambdas that read the value. State has a read-only value property; MutableState extends that by making the state writable. Think of State as an observable bucket that holds a value. The idea is that we'll launch a coroutine that passes the bucket to a producer function, who will drop new values into it. But we need to store that bucket (the MutableState ) somewhere so it lives across composition/recomposition. Because we're in a composable function, we have access to the composition tree, so we'll store the MutableState inside the tree. The remember function does that for us. So val result = remember { mutableStateOf ( initialValue ) } does Create our bucket by calling mutableStateOf , and store the initial value in it. (We need an initial value so something is available while we're waiting for the producer to send something) Store the bucket in the tree by calling remember Hold the bucket locally in result Next, we need to fill the bucket. LaunchedEffect launches a coroutine, which will be canceled and restarted if its keys change. (In this example, the keys are the initial value and the flow itself.) Note LaunchedEffect is a controlled side effect in Compose. It allows you to specify the data that triggers its cancellation and restart. One of its common uses is to fetch data. Make sure that any fetches like this are done from a LaunchedEffect and not from the body of the composable function. The body of the function declares what will be done, and if you add side-effect code outside of a safe handler such as LaunchedEffect , that code will be run on every composition/recomposition, not just when the related data (like id here) changes. The launched coroutine calls producer passing it a receiver that holds the bucket. The producer can then deposit items in the bucket whenever it likes. That's produceState . Let's go back up a level to collectAsState . @Composable fun < T : R , R > Flow < T > . collectAsState ( initial : R , context : CoroutineContext = EmptyCoroutineContext ): State < R > = produceState ( initial , this , context ) { if ( context == EmptyCoroutineContext ) { collect { value = it } } else withContext ( context ) { collect { value = it } } } The producer is the lambda { if ( context == EmptyCoroutineContext ) { collect { value = it } } else withContext ( context ) { collect { value = it } } } This lambda switches dispatchers if necessary, and calls collect on the Flow , which will suspend until the next value is available. Once it has a value, it drops it in the bucket. Back up one more level, where we have val people by viewModel . peopleFlow . collectAsState ( initial = emptyList () ) collectAsState returns that bucket, which can act as a Kotlin property delegate. We forward all calls to get the people value to the bucket . When anything else in the composable function asks for people , it gets the value from that bucket. When a new value is dropped in the bucket, compose starts recomposition (which will then read the value from the bucket via the people local val).","title":"Collecting Flows"},{"location":"week-04/4.1-Compose-basics/STEP_20_FULL.html#accessing-flows","text":"Let's dig into that people definition. val people by viewModel . peopleFlow . collectAsState ( initial = emptyList () ) We talked about Kotlin's by before - it delegates the get and set for a property to another object. In this case, we defined people as a val , so it only has a get to delegate. First, what does collectAsState do? @Composable fun < T : R , R > Flow < T > . collectAsState ( initial : R , context : CoroutineContext = EmptyCoroutineContext ): State < R > = produceState ( initial , this , context ) { if ( context == EmptyCoroutineContext ) { collect { value = it } } else withContext ( context ) { collect { value = it } } } It calls produceState to create a Compose MutableState instance, and then sets the value of that state to each emitted item from the Flow . Easy for me to say, but let's see what that really means by looking at produceState : @Composable fun < T > produceState ( initialValue : T , key1 : Any? , key2 : Any? , @BuilderInference producer : suspend ProduceStateScope < T > .() -> Unit ): State < T > { val result = remember { mutableStateOf ( initialValue ) } LaunchedEffect ( key1 , key2 ) { ProduceStateScopeImpl ( result , coroutineContext ). producer () } return result } Jetpack Compose State are objects that Compose can observe. When the value of State changes, Compose will trigger recomposition of any composable functions/lambdas that read the value. State has a read-only value property; MutableState extends that by making the state writable. Think of State as an observable bucket that holds a value. The idea is that we'll launch a coroutine that passes the bucket to a producer function, who will drop new values into it. But we need to store that bucket (the MutableState ) somewhere so it lives across composition/recomposition. Because we're in a composable function, we have access to the composition tree, so we'll store the MutableState inside the tree. The remember function does that for us. So val result = remember { mutableStateOf ( initialValue ) } does Create our bucket by calling mutableStateOf , and store the initial value in it. (We need an initial value so something is available while we're waiting for the producer to send something) Store the bucket in the tree by calling remember Hold the bucket locally in result Next, we need to fill the bucket. LaunchedEffect launches a coroutine, which will be canceled and restarted if its keys change. (In this example, the keys are the initial value and the flow itself.) Note LaunchedEffect is a controlled side effect in Compose. It allows you to specify the data that triggers its cancellation and restart. One of its common uses is to fetch data. Make sure that any fetches like this are done from a LaunchedEffect and not from the body of the composable function. The body of the function declares what will be done, and if you add side-effect code outside of a safe handler such as LaunchedEffect , that code will be run on every composition/recomposition, not just when the related data (like id here) changes. The launched coroutine calls producer passing it a receiver that holds the bucket. The producer can then deposit items in the bucket whenever it likes. That's produceState . Let's go back up a level to collectAsState . @Composable fun < T : R , R > Flow < T > . collectAsState ( initial : R , context : CoroutineContext = EmptyCoroutineContext ): State < R > = produceState ( initial , this , context ) { if ( context == EmptyCoroutineContext ) { collect { value = it } } else withContext ( context ) { collect { value = it } } } The producer is the lambda { if ( context == EmptyCoroutineContext ) { collect { value = it } } else withContext ( context ) { collect { value = it } } } This lambda switches dispatchers if necessary, and calls collect on the Flow , which will suspend until the next value is available. Once it has a value, it drops it in the bucket. Back up one more level, where we have val people by viewModel . peopleFlow . collectAsState ( initial = emptyList () ) collectAsState returns that bucket, which can act as a Kotlin property delegate. We forward all calls to get the people value to the bucket . When anything else in the composable function asks for people , it gets the value from that bucket. When a new value is dropped in the bucket, compose starts recomposition (which will then read the value from the bucket via the people local val).","title":"Accessing Flows"},{"location":"week-04/4.1-Compose-basics/STEP_30_FULL.html","text":"Let's add a Button that deletes the first Person in the list. class PersonViewModel ( application : Application ) : AndroidViewModel ( application ) { ... suspend fun delete ( vararg people : PersonDto ) = repository . delete ( * people ) } @Composable fun PeopleListScreen ( viewModel : PersonViewModel = viewModel () ) { val people by viewModel . peopleFlow . collectAsState ( initial = emptyList () ) Column { ... Button ( onClick = { viewModel . delete ( people [ 0 ] ) } ) { Text ( text = \"Delete First Person\" ) } } } Button doesn't have its own text; it's just a container for another composable. Here we add a Text to it, but we could just have easily added an icon or drawing or a more complex composition. When the user clicks the Button , the function passed for onClick is called. But we have a problem here; PersonViewModel.delete() is a suspend function - it can only be called from a coroutine or other suspend function. We have a choice to make. We can launch a coroutine from the UI, or have the view model launch the coroutine. If we launch from the UI, the coroutine will be canceled when that part of the UI is removed from the composition tree. Not ideal in this case, we'd cancel if the user rotates the screen while the coroutine is running. So we'll modify our view model to launch coroutines that last as long as the view model is alive. class PersonViewModel ( application : Application ) : AndroidViewModel ( application ) { ... fun insert ( vararg people : PersonDto ) = viewModelScope . launch { repository . insert ( * people ) } fun update ( vararg people : PersonDto ) = viewModelScope . launch { repository . update ( * people ) } fun delete ( vararg people : PersonDto ) = viewModelScope . launch { repository . delete ( * people ) } } Note We're only doing this for the \"action\" functions in the view model - requests from the user interface to make a change. Later we'll see how the getPerson function works. Now, our code can delete the first item in the list!","title":"Calling View Model Actions"},{"location":"week-04/4.1-Compose-basics/STEP_40_FULL.html","text":"View models can also have functions that help the user interface access data. Think about \"screens\" in your application, composable functions that define the entire visible user interface that the user sees at one time. We might use a Sealed Interface to describe the available screens. If we wanted to define two screens, a list of people and the details of one person, we might define: sealed interface Screen object PeopleListScreen : Screen data class PersonDisplay ( val id : String ): Screen Subtypes of a sealed interface can only be defined in the same module as the sealed interface . This allows the Kotlin compiler (which compiles all code in a module together), to know all of its possible subtypes, which in turn, allows you to write exhaustive when expressions without an else . We define PeopleListScreen as an object because there's no data needed to know what to display; we always display the entire list of people. PersonDisplay , on the other hand, needs to know which Person we want to display. And now we need to think about how to represent that... We could just drop a Person object into it. When we call a composable function to generate its display, we just read the data from that object. However... the Person could change . Think about an application where the user can traverse from displaying one Person to another. We'd store the Screens on a stack so the user can go back to previous screens. If a Person that happened to be held as data for a previous screen changes, going back would see stale data . So... we choose to store the id of the Person . That won't change. And now we need to enable our composable function to fetch the person by its id . That's where our getPerson function comes in: class PersonViewModel ( application : Application ) : AndroidViewModel ( application ) { ... suspend fun getPerson ( id : String ) = repository . getPerson ( id ) } We need to pass an id to our composable function and have it fetch the Person . To do this, we follow a similar technique we saw when we examined collectAsState : @Composable fun PersonDisplay ( id : String , fetchPerson : suspend ( String ) -> PersonDto , ) { var person by remember { // AAA mutableStateOf < PersonDto?> ( null ) } LaunchedEffect ( key1 = id ) { // BBB person = fetchPerson ( id ) } // if we want to only display fields when we have a person person ?. let { // CCC // display the Person } // if we want to display temporary values when we don't // have a person val name = person ?. name ?: \"(loading)\" // DDD // Elvis operator: left side if non-null, else right side Text ( text = \"Name: $ name \" ) } Line Description AAA Create a bucket to hold a nullable PersonDto . Store it in the composition tree. Delegate get and set of person to the bucket. If Compose sees a new value in the bucket, it'll start a recomposition. BBB Start a coroutine to fetch the person by its id . When received, store it in person . If we see a different id , cancel the coroutine (if still running) and launch again. CCC If you want to omit fields entirely if we don't yet have a person , use let (or another scoping function) to contain the UI only if person is not null. DDD If you want to show fields with temporary values, use the Elvis operator ?: to choose the non-null value or a default. Turn your head 90 degrees to the left to see how it looks like Elvis. If you don't know who Elvis is, you're really making me feel old. But that's ok. I'm not a fan anyway...","title":"Calling View Model Accessors"},{"location":"week-04/4.1-Compose-basics/STEP_50_FULL.html","text":"Sometimes you just want a \"bucket\" to hold a value in the view model. Using State in the view model makes it easy to hold values that you're not persisting in a database, and let Compose know when those values change. For example, if we wanted to keep track of which people in a list are \"selected\" (so we can delete them), we could add state to the view model: class PersonViewModel ( application : Application ) : AndroidViewModel ( application ) { ... var selectedPeople by mutableStateOf ( emptySet < String > ()) } We create our bucket using mutableStateOf , initially holding an empty set of Strings. (We'll add and remove ids from this set). We expose this to the UI as selectedPeople . Whenever the UI wants to get the value, we delegate that get to the bucket and give the current value. But I'm really not keen on allowing the user interface to directly set the value of selectedPeople . Because it's a var , they have access to set it. So I change this to class PersonViewModel ( application : Application ) : AndroidViewModel ( application ) { ... var selectedPeople by mutableStateOf ( emptySet < String > ()) private set fun togglePersonSelection ( id : String ) { selectedPeople = if ( id in selectedPeople ) { selectedPeople - id } else { selectedPeople - id } } } which makes the set accessible only inside the view model, and exposes a togglePersonSelection function we can use in the UI. Info In case you're wondering, the in keyword is an operator that calls contains on the collection. It's one of very few operators I'd recommend overloading. (Take my Kotlin class to hear about the others!) Because we're using Compose State , it'll note the gets and when a new value is dropped in the bucket, it'll trigger recomposition of composables that did those gets . For example: @Composable fun PeopleListScreen ( viewModel : PersonViewModel = viewModel () ) { Column { ... PeopleList ( people = people , selectedPeople = viewModel . selectedPeople , modifier = Modifier . padding ( 8. dp ) ) } } @Composable fun PeopleList ( people : List < PersonDto > , selectedPeople : Set < String > , modifier : Modifier = Modifier , ) { ... } Here we pass the set of ids to PeopleList and can use it to highlight which people have been selected. So how do we handle the togglePersonSelection call? First, we add a function parameter to our PeopleList @Composable fun PeopleList ( people : List < PersonDto > , selectedPeople : Set < String > , onTogglePerson : ( String ) -> Unit , modifier : Modifier = Modifier , ) { ... } We call it onTogglePerson rather than onPersonToggled to represent that calling it is performing the event, not reacting to something that has already happened. We use it inside the function when the user performs an interaction that we consider \"toggling the selection\". Back in PeopleListScreen , we pass a function for onTogglePerson : PeopleList ( people = people , selectedPeople = viewModel . selectedPeople , onTogglePerson = { viewModel . togglePersonSelection ( it ) }, modifier = Modifier . padding ( 8. dp ) ) This lambda takes the parameter passed (called it because we haven't explicitly named it) and calls togglePersonSelection in the view model. Note that the parameter and return types of onTogglePerson and togglePersonSelection are the same: ( String ) -> Unit Both take a String parameter and neither returns a value. Because of this, we can use a Kotlin function reference instead: PeopleList ( people = people , selectedPeople = viewModel . selectedPeople , onTogglePerson = viewModel :: togglePersonSelection , modifier = Modifier . padding ( 8. dp ) ) which eliminates the intermediary lambda. Note that you never have to use a function reference, but they're a wee bit shorter and possibly a weeeeeeeeee bit faster. Note We'll go into the actual select/deselect process in much more detail when we talk about lists in a later module.","title":"View Model Buckets"},{"location":"week-04/4.2-Movie-Ui-1/index.html","text":"Example Source: https://gitlab.com/android-development-2022-refresh/movie-ui-1","title":"Movie UI, part 1"},{"location":"week-04/4.2-Movie-Ui-1/STEP_010_REPO.html","text":"We start with a copy of our Movies app at the end of the database module.","title":"Start with Movies Database"},{"location":"week-04/4.2-Movie-Ui-1/STEP_020_REPO.html","text":"Android Studio Dolphin just came out. We update the version number of the Android Gradle Plugin (AGP) to the latest and greatest.","title":"Update AGP Version"},{"location":"week-04/4.2-Movie-Ui-1/STEP_025_FULL.html","text":"Our movie application has a simple navigation flow. At the bottom of the UI are three navigation tabs: Ratings Movies Actors Clicking one of them jumps to the list for that type of data, and clears the navigation stack. It's like starting the navigation flow over at one of the list screens. Initially, the Movie List is displayed. Each list screen displays a list of all items of that type. When you click on one of the items, you'll be taken to the display screen for that data. Each data display shows a list related data: Rating Display shows a list of Movies with that Rating Movie Display shows a list of actors who appeared in the Movie Actor Display shows a list of movies in which the actor appeared Clicking on the related info will take you to that related item. The user can drill down as deeply as they would like; each item visited is pushed on a stack. Pressing the Android back button will take them to the previously-visited item. If they're on a top-level list screen, pressing back will exit the application. To represent screens, we'll use a Kotlin sealed interface and implementations: sealed interface Screen object RatingList : Screen object MovieList : Screen object ActorList : Screen data class RatingScreen ( val id : String ): Screen data class ActorScreen ( val id : String ): Screen data class MovieScreen ( val id : String ): Screen Android provides a Navigation Component, but, we'll keep things simple for now and just use a stack that we manage.","title":"Application Navigation"},{"location":"week-04/4.2-Movie-Ui-1/STEP_030_REPO.html","text":"I like to add the screen state and its management early on. This allows me to create placeholder screens and navigate between them to ensure my navigation flow feels ok. Screen Objects/Classes To start, we flesh out the Screen objects and classes. I've renamed RatingScreen to RatingDisplay to be more explicit about its purpose, and follow the same convention when defining displays for a movie and actor. The \"List\" screen representations don't need to hold any data; their screens display all of their data. We therefore don't need to ever create more than one instance of these, and can represent these as singletons using Kotlin the object keyword. The \"Display\" screen representations need to know which specific item they're displaying, so we hold the id . This requires separate screen instances for each id we visit, so we'll use a data class when defining them. Screen State Management We'll track which screen we're on inside the view model. We had already added var screen by mutableStateOf < Screen?> ( MovieList ) private set to track the current screen, but we also need a stack to allow the user to return to previously-visited screens. We define private var screenStack : List < Screen > = listOf ( MovieList ) set ( value ) { field = value screen = value . lastOrNull () } This screenStack property holds an immutable list of Screens . The last Screen in the list is the currently-displayed one. If the list is empty, we'll treat that as an \"exit the application\" state, to be handled by the Activity . Note Lists created by listOf can actually be modified by casting them to a MutableList . Unfortunate... But we're managing it internally and never changing it ourselves. Here we take advantage of a custom set function for the property. Whenever the stack changes, we'll automatically update the screen property. Because the screen property is a Compose State , Compose will trigger recomposition (if its value has changed). Next we expose functions that the UI can use to direct our navigation. pushScreen - creates a new screenStack by appending the specified Screen popScreen - creates a new screenStack by removing the last Screen (if any were present) setScreenStack - creates a new, single- Screen stack","title":"Screen State"},{"location":"week-04/4.2-Movie-Ui-1/STEP_030_REPO.html#screen-objectsclasses","text":"To start, we flesh out the Screen objects and classes. I've renamed RatingScreen to RatingDisplay to be more explicit about its purpose, and follow the same convention when defining displays for a movie and actor. The \"List\" screen representations don't need to hold any data; their screens display all of their data. We therefore don't need to ever create more than one instance of these, and can represent these as singletons using Kotlin the object keyword. The \"Display\" screen representations need to know which specific item they're displaying, so we hold the id . This requires separate screen instances for each id we visit, so we'll use a data class when defining them.","title":"Screen Objects/Classes"},{"location":"week-04/4.2-Movie-Ui-1/STEP_030_REPO.html#screen-state-management","text":"We'll track which screen we're on inside the view model. We had already added var screen by mutableStateOf < Screen?> ( MovieList ) private set to track the current screen, but we also need a stack to allow the user to return to previously-visited screens. We define private var screenStack : List < Screen > = listOf ( MovieList ) set ( value ) { field = value screen = value . lastOrNull () } This screenStack property holds an immutable list of Screens . The last Screen in the list is the currently-displayed one. If the list is empty, we'll treat that as an \"exit the application\" state, to be handled by the Activity . Note Lists created by listOf can actually be modified by casting them to a MutableList . Unfortunate... But we're managing it internally and never changing it ourselves. Here we take advantage of a custom set function for the property. Whenever the stack changes, we'll automatically update the screen property. Because the screen property is a Compose State , Compose will trigger recomposition (if its value has changed). Next we expose functions that the UI can use to direct our navigation. pushScreen - creates a new screenStack by appending the specified Screen popScreen - creates a new screenStack by removing the last Screen (if any were present) setScreenStack - creates a new, single- Screen stack","title":"Screen State Management"},{"location":"week-04/4.2-Movie-Ui-1/STEP_040_REPO.html","text":"Let's start setting up the navigation. We define ActorDisplay and MovieDisplay as placeholder screens for now. They only display the id of the actor or movie, as we don't yet have support in the data layer to fetch actors or movies. We modify ActorList and MovieList to pass in onXXXClick functions, and set the SimpleText to call them when the user clicks them. We do similarly in RatingDisplay - when one of its displayed movies is clicked, we'll call onMovieClick . These calls notify the caller that something is being clicked. The caller will deal with the actual navigation. That happens in TestScreen , which is our top-level composable that works with the view model. We define navigation and screen selection inside it. There are several changes in this file: We add a BackHandler . This sets up scoped back-button handling for this composable and each called composable. A called composable (at any depth) can override the BackHandler if needed. Our BackHandler is simple - we tell the view model to pop a screen from the stack. We change the switchTo calls to setScreenStack or pushScreen , depending on the needed navigation flow. (I've also removed switchTo from the view model, as it's no longer needed.) When looking at the viewModel.screen , if it's null , we need to exit the application. To do this, we pass an onExit function to TestScreen , and call it if we see a null screen. We add more clauses to our when expression for the newly-added screens. Inside that when , we define what navigation happens. Each screen tells us when things are clicked; the screens don't know anything about navigation, which makes them more reusable. We call pushScreen when the user is clicking on items in each screen. Finally, our MainActivity needs to deal with exiting. We pass a lambda to TestScreen for its onExit parameter. This lambda just calls finish() , which tells Android that it should close out the MainActivity . Because there are no more Android-tracked Activities, the application ends. Note In case you're confused by TestScreen { finish () // handle \"onExit\" } this is equivalent to TestScreen ( onExit = { finish () // handle \"onExit\" } ) If the last parameter to a Kotlin function is a function, you can move it out of the parentheses. If that parameter is the only parameter to the function, you can also remove the parentheses. If we had another parameter to a function, like fun someFunction ( x : Int , onFoo : () -> Unit , ) { ... } You would call it as someFunction ( 42 ) { ... } At this point, we can walk through the navigation (except for moving between actors and movies - we don't have that support yet in the data layer).","title":"Basic Navigation"},{"location":"week-04/4.2-Movie-Ui-1/STEP_050_REPO.html","text":"The Actor <-> Movie relationship is many-to-many, and we store the mapping in Role entities. At its most basic, we could define an ActorWithMovies as data class ActorWithMovies ( @Embedded val actor : Actor , @Relation ( parentColumn = \"id\" , entityColumn = \"id\" , associateBy = Junction ( Role :: class , parentColumn = \"actorId\" , entityColumn = \"movieId\" , ), ) val movies : List < Movie > , ) This can be used in a DAO function like @Transaction @Query ( \"SELECT * FROM Actor WHERE id = :id\" ) abstract suspend fun getActorWithMovies ( id : String ): ActorWithMovies But there's a problem; we only get a list of Movies . We don't get the associative data , the character name or order in credits, that's stored in Role . To make that work, we need to break up the data class that we use to fetch the data into two data classes (in each direction). From the Actor side, we have data class ActorWithFilmography ( @Embedded val actor : Actor , @Relation ( entity = Role :: class , parentColumn = \"id\" , entityColumn = \"actorId\" , ) val filmography : List < RoleWithMovie > , ) data class RoleWithMovie ( @Embedded val role : Role , @Relation ( parentColumn = \"movieId\" , entityColumn = \"id\" ) val movie : Movie , ) Start looking from RoleWithMovie . Room fills this data class when a Role is fetched. The Role is held as the @Embedded role property, and the @Relation asks Room to fetch exactly one Movie whose id matches the movieId in the Role . We could (but we won't) create a DAO function like @Transaction @Query ( \"SELECT * FROM Role WHERE actorId = :id\" ) abstract suspend fun getRolesWithMoviesForActor ( id : String ): List < RoleWithMovie > This would fetch all Roles with the specified actorId , run a secondary query to fetch the Movies associated with those Roles , then create a RoleWithMovie for each. Keep this in mind for the next step... Now, look at ActorWithFilmography . Note how it pulls in RoleWithMovie . By writing a DAO function: @Transaction @Query ( \"SELECT * FROM Actor WHERE id = :id\" ) abstract suspend fun getActorWithFilmography ( id : String ): ActorWithFilmography We ask Room to Find the Actor with the given id Run another query because of the @Relation in ActorWithFilmography that will fetch all Roles for the Actor (the @Relation specifies the Role as its entity ) and create RoleWithMovie instances for each. To fetch those Roles and RoleWithMovie , Room basically does the same thing it would have done for getRolesWithMoviesForActors (calling a third query in the process) We do similar for MovieWithCast . Note The above starts getting rather complex. Right now, this is the only way to get associative data that's attached to a many-to-many relationship. You may need to do this at some point, but the docs don't cover this scenario, which is why I wanted to feature it. (I need to write a blog post on this...) The rest of these changes are exposing the functionality through the repository and view model, then setting up the screens to display the data and handle navigation. We set up the MovieDisplay and ActorDisplay similar to how we set up RatingDisplay . We now have our navigation and data working. But the screens are very rough...","title":"Actors <-> Movies"},{"location":"week-04/4.2-Movie-Ui-1/STEP_055_FULL.html","text":"A key component of a consistent user interface is management of its overall structure. This includes App Bar (aka Tool Bar) at the top of the UI Navigation Drawer Bottom Navigation Floating Action Button Snackbar Body Content Jetpack Compose defines an elegant and flexible solution in its Scaffold composable function. Scaffold manages sections of the screen that it calls Slots . Each Slot is simply a @Composable lambda function that you pass into Scaffold and it manages their size and visibility. Scaffold acts as a dynamic layout manager, responding to certain user input (such as dragging from the edge to open the navigation drawer) to manage its content. A Slotted API is very flexible; you can emit whatever nodes you would like in those slots. An example of Scaffold in action (with some details elided): Scaffold ( topBar = { TopAppBar ( title = { Text (... My Application ...) }, actions = { IconButton ( onClick = { ... }) { Icon (... add ...) } IconButton ( onClick = { ... }) { Icon (... delete ...) } } ) } ) { paddingValues -> Column ( modifier = Modifier . padding ( paddingValues )) { Text (... Name ...) Text (... Scott ...) Text (... Age ...) Text (... 55. ..) } } Here we use Scaffold's topBar and content slots. ( content is the lambda that's outside its parentheses). In the topBar slot, we use a TopAppBar , which is another slotted function. We fill in its title and actions slots. The TopAppBar positions the title and actions for us. We fill in the content slot with a nice little name-and-address form. This results in a UI that looks like If we have common actions and/or other features such as buttons on a bottom bar, we may want to define our own Scaffold function: @Composable fun MyScaffold ( title : String , content : @Composable ( PaddingValues ) -> Unit , // our content slot ) = Scaffold ( topBar = { TopAppBar ( title = { Text ( text = title ) }, actions = { // common actions } ) } ) { paddingValues -> content ( paddingValues ) } We set up a common, fixed app bar at the top and pass a modifier to our content slot which we can use as follows MyScaffold ( title = \"My Application\" ) { modifier -> Column ( modifier = Modifier . padding ( paddingValues )) { Text (... Name ...) Text (... Scott ...) Text (... Age ...) Text (... 55. ..) } } Creating composable functions like this acts similar to subclassing in other UI frameworks.","title":"Scaffold - A Slotted API"},{"location":"week-04/4.2-Movie-Ui-1/STEP_060_REPO.html","text":"Let's make our screens look nicer and include common functionality. Overall, we'd like something like @Composable fun MovieScaffold ( title : String , onSelectListScreen : ( Screen ) -> Unit , onResetDatabase : () -> Unit , content : @Composable ( PaddingValues ) -> Unit , ) { Scaffold ( topBar = { // title and reset-database action }, content = { paddingValues -> content ( paddingValues ) }, bottomBar = { // buttons for each list screen // if pressed, call onSelectListScreen } ) } We use this as the basis for every screen in the application. Note It's time to talk about externalizing your strings! Any literal string that will appear in the user interface should be externalized. You typically define strings in src/main/res/values/strings.xml inside the module that needs them. (You can access strings from modules you depend upon as well). This allows the strings to be translated for other languages/regions, or changed based on other configurations. For example, if you have a particularly small screen, you may want to use shorter strings. <resources> <string name= \"screen_title_ratings\" > MPAA Ratings </string> <string name= \"screen_title_movies\" > Movies </string> <string name= \"screen_title_actors\" > Actors </string> </resources> You can then reference them in your composable function by calling stringResource : stringResource ( R . string . screen_title_ratings ) Sometimes I'll define helper functions for literal text: @Composable fun Label ( @StringRes textId : Int ) = Text ( text = stringResource ( textId ), style = MaterialTheme . typography . h5 , modifier = Modifier . padding ( 8. dp ) ) Note the @StringRes annotation. The Android lint checker defines a rule that the caller must pass a proper string resource id ( R.string.xxx ) to parameters annotated with @StringRes . Use that annotation if you're creating a function that expects a string resource id. As part of this step, I've externalized all literal strings. Note About those icons... Jetpack Compose comes with a basic set of icons, but sometimes you need more. I added in dependency implementation 'androidx.compose.material:material-icons-extended:1.2.1' This is a huge dependency, and should not be included in release apps. In the next section, we'll see how we can pull out the icons we need.","title":"UI From the Outside"},{"location":"week-04/4.2-Movie-Ui-1/STEP_070_REPO.html","text":"In the last step, we used a few Icons by referencing Icons . Default . Emergency Icons . Default . Movie Icons . Default . Person These are ImageVectors , objects that declare how to show an icon using Scalable Vector Graphics (SVG) paths. Info To explore a list of available icons (many in the extended icon set), see https://fonts.google.com/icons?selected=Material+Icons Jetpack Compose includes a library of basic icons, but they're often not enough. If you can't find the icon you're looking for, add this dependency to your app/build.gradle : implementation 'androidx.compose.material:material-icons-extended:1.2.1' Caution This is a large dependency and can greatly impact debug build time. (If you have proguard minimization turned on, it should remove unused icons in your release build, but debug will be a good bit slower) You should copy the icons you need from it. Once you find and test the icons you need, you can copy them to your project: Find the referenced icon Icon ( imageVector = Icons . Default . Add , // An Icon!!! contentDescription = stringResource ( id = R . string . add ) ) Control-click the icon name ( Add in this example) to see its ImageVector source: Press the \"select opened file\" icon in the Project View. It looks like a target. You can also press Alt + F1 then press 1 to open the file If the file appears under \"material-icons-core\", you don't need to copy it. If it's under \"material-icons-extended\", you should Copy the package name from the package line in the source Right-click app/src/main/java or app/src/main/kotlin and chose \"New->Package\" Paste the package name and press enter Create a new file named IconName.kt Copy and paste the icon source into the new file After you've copied all external icons, you can delete the \"material-icons-extended\" dependency.","title":"Copying Extended Icons"},{"location":"week-04/4.2-Movie-Ui-1/STEP_080_FULL.html","text":"Things are looking and working much better! We've got a common wrapper around the guts of each page, and we're pulling the right data. But there's more to do: Convert our list displays to be more dynamic and efficient Display items in a list as cards Allow the user to select items in a list and delete them Edit data We'll work on this in a later module.","title":"Wrap Up"},{"location":"week-05/5.1-Compose-Lists/index.html","text":"So far, we've displayed lists of data by iterating through all of the data and emitting Text nodes. Seems to work ok, but what happens when that list gets big? When we emit to the composition tree, the Compose UI will render all of the nodes, even if some are offscreen. If there are relatively few offscreen nodes, it's not a big deal, but as the number of nodes increase, the added processing time can contribute to jank in the UI. We need a better approach to manage offscreen parts of our UI. We'll look at this from the point of view of fixed and dynamic UIs. A fixed UI is one that doesn't scale based on the amount of data it's representing. Think about a data-entry form. Perhaps you're editing user shipping information. There are usually a fixed number of fields in the UI. Depending on the device configuration (in this case, the screen size and user-selected font scaling), we might not be able to fit all fields on the screen at once. A dynamic UI is one that scales with the data. This is most apparent when presenting data from a database, such as songs in a playlist. The UI will repeat chunks of controls for each item, and can quickly grow past the screen bounds. Fixed UIs First, let's think about a fixed UI. We're asking the user to enter shipping information, which may or may not all fit on the screen. If the device has a large screen or the user is using a \"small\" font setting, we might get all fields on the screen. But as the screen shrinks or the user chooses \"large\" fonts, it's likely that some parts of the UI won't fit. There are a few things you might do about this: Mark your UI as scrollable. For example, if you use a Column to hold your fields, you can mark the column as scrollable: Column ( modifier = Modifier . padding ( paddingValues ) . verticalScroll ( rememberScrollState ()) ) { This is a good idea whenever using a Column (or other layout) that may need to be scrolled to see all of its content. Keep in mind that devices come in many different form factors, and users will sometimes choose extra-large font sizes to make reading more comfortable. If, on the other hand, you're declaring a UI that has fixed content that always appears on the screen, and scales with the screen size, you would skip the scroll modifier. (This might apply when writing a full-screen game, for example.) Break the UI into more screens, each with fewer fields. If you have a long, scrollable, UI with many fields, double-check that the fields are all related. If grouping fields makes sense, you might consider creating more than one screen. You could Create a \"main\" screen for that part of the UI, with buttons or links that open the grouped detail. For example, a shipping screen might have buttons to open an address-editor screen and present shipping rate choices. Create a series of screens with \"next\"/\"previous\" actions to move between them. For example, a \"purchase\" might be presented as a series of screens: Shopping cart display Shipping address Shipping rate options Credit card entry Confirmation Choosing the right layout can be tricky. If you have some User-Experience (UX) Designers in your company, talk with them about what might make a good user interface. They may help set up an A-B study to test out alternatives with a user (or if you don't have dedicated UX folks, consider such a study yourself, or bounce ideas off other developers to see what might feel the best.) If it feels like the best interface for your application would be a long scrolling list of fields, use a scrollable Column and test its performance. If the list of fields is really long and is causing performance issues, you may want to consider treating the fields as items in a list, and follow the next section. Dynamic UIs The amount of available data is often outside of your control. You might have no idea if your application would typically display a handful of items, or a huge number. Ideally, we would only emit the nodes to the composition tree if they are visible. To do this, we need to track which items are visible and the user scrolls, and properly update them if the data behind them changes. When we emit nodes to the composition tree, Compose typically keeps track of them by position . During recomposition, if the item in a position is stable and equals the last item in that position, recomposition for that item can be skipped. If items are inserted or deleted, Compose may need to recompose items around it, and may not be able to determine how to apply animations on those inserts and deletes. If instead, you assign keys that uniquely identify items in part the composition tree, Compose can determine how a newly-emitted chunk of nodes relates to the previously-emitted nodes, and animate insertions and deletions and possibly moves. @Composable fun PeopleList ( people : List < PersonDto > , ... ) = Scaffold ( ... // title, actions, etc ) { paddingValues -> LazyColumn ( // AAA modifier = Modifier . padding ( paddingValues ) ) { items ( // BBB items = people , key = { it . id }, ) { Card ( // CCC elevation = 4. dp , modifier = Modifier . padding ( 8. dp ) . fillMaxWidth () ) { // DDD Row { Text ( text = it . name , modifier = Modifier . padding ( 8. dp ) . weight ( 1f ), // EEE ) Text ( text = it . age . toString (), modifier = Modifier . padding ( 8. dp ), ) } } } } } Line Description AAA LazyColumn dynamically emits nodes to the composition tree that will be visible (and others if necessary for scrolling and animation). Its content lambda declares which items are in the list, how to uniquely identify them, and what composition should display each item BBB items declares the list of data to display in the LazyColumn and how to get a unique key for each item. The keys allow LazyColumn to determine when items have been inserted, deleted or moved, optimizing recomposition and allowing animation CCC Card is a composable that displays a raised, rounded-corner rectangle around its contents. You'll often see these used in displayed lists, but they're not required. DDD The content composable lambda that declares the presentation of each item in the LazyColumn ] EEE When you use the weight modifier in a Column or Row , Compose assigns a proportion of the remaining space (after determining base sizes of each composable in the Row / Column ) to the node. In this case, only one node in the Row specifies a weight , so it gets all remaining space after the \"age\" Text has been sized. The result is the \"age\" getting pushed to the right (end) edge of the Row . If multiple nodes in a Row / Column specify weight , the weights are summed and each node gets a ratio of remaining space based on its weight divided by the sum. If two nodes have the the same weight, the remaining space is divided equally. If one node has weight 1 and the other weight 2, 1/3 of the remaining space goes to the first node, 2/3 goes to the second node. The above screen might look like Note If you want a horizontal display of items, LazyRow works similar. LazyHorizontalGrid and LazyVerticalGrid arrange more than one item horizontally or vertically in rows/columns. We're only working with LazyColumn in this course. Selection Sometimes you'd like to allow the user to select one or more items in the list and perform an action against them. This requires: A set to track which items are considered \"selected\", A declaration of user interaction that is considered \"selecting an item\", which will add the id of that item to the \"selected\" set. A declaration of user interaction that is considered navigating to that item's details (if applicable) Actions (passed to the topBar in the Scaffold ) that should be available when no items are selected one or more items are selected Colors to use to indicate an item is selected. We'll use the primary color in the theme, but you could choose a different one, such as primaryVariant or secondary colors. Let's look an an example UI: First, we've added an icon at the start of the cards: How does the user interact with the items? Tapping the icon or long-pressing anywhere in the row toggles the selection Tapping in the row anywhere except the icon if any items are selected, toggle this item if no items are selected, trigger navigation When any items are selected, we change the topBar in the Scaffold to display a navigation arrow icon. When pressed, all selections are cleared the number of selected items selection actions - \"delete\" in this case (deletes all selected items when tapped) We also highlight the selected items in the list. Note how the foreground and background colors are swapped We'll see the details of how to implement selection when we walk through the Movies UI, part 2.","title":"Compose Lists"},{"location":"week-05/5.1-Compose-Lists/index.html#fixed-uis","text":"First, let's think about a fixed UI. We're asking the user to enter shipping information, which may or may not all fit on the screen. If the device has a large screen or the user is using a \"small\" font setting, we might get all fields on the screen. But as the screen shrinks or the user chooses \"large\" fonts, it's likely that some parts of the UI won't fit. There are a few things you might do about this: Mark your UI as scrollable. For example, if you use a Column to hold your fields, you can mark the column as scrollable: Column ( modifier = Modifier . padding ( paddingValues ) . verticalScroll ( rememberScrollState ()) ) { This is a good idea whenever using a Column (or other layout) that may need to be scrolled to see all of its content. Keep in mind that devices come in many different form factors, and users will sometimes choose extra-large font sizes to make reading more comfortable. If, on the other hand, you're declaring a UI that has fixed content that always appears on the screen, and scales with the screen size, you would skip the scroll modifier. (This might apply when writing a full-screen game, for example.) Break the UI into more screens, each with fewer fields. If you have a long, scrollable, UI with many fields, double-check that the fields are all related. If grouping fields makes sense, you might consider creating more than one screen. You could Create a \"main\" screen for that part of the UI, with buttons or links that open the grouped detail. For example, a shipping screen might have buttons to open an address-editor screen and present shipping rate choices. Create a series of screens with \"next\"/\"previous\" actions to move between them. For example, a \"purchase\" might be presented as a series of screens: Shopping cart display Shipping address Shipping rate options Credit card entry Confirmation Choosing the right layout can be tricky. If you have some User-Experience (UX) Designers in your company, talk with them about what might make a good user interface. They may help set up an A-B study to test out alternatives with a user (or if you don't have dedicated UX folks, consider such a study yourself, or bounce ideas off other developers to see what might feel the best.) If it feels like the best interface for your application would be a long scrolling list of fields, use a scrollable Column and test its performance. If the list of fields is really long and is causing performance issues, you may want to consider treating the fields as items in a list, and follow the next section.","title":"Fixed UIs"},{"location":"week-05/5.1-Compose-Lists/index.html#dynamic-uis","text":"The amount of available data is often outside of your control. You might have no idea if your application would typically display a handful of items, or a huge number. Ideally, we would only emit the nodes to the composition tree if they are visible. To do this, we need to track which items are visible and the user scrolls, and properly update them if the data behind them changes. When we emit nodes to the composition tree, Compose typically keeps track of them by position . During recomposition, if the item in a position is stable and equals the last item in that position, recomposition for that item can be skipped. If items are inserted or deleted, Compose may need to recompose items around it, and may not be able to determine how to apply animations on those inserts and deletes. If instead, you assign keys that uniquely identify items in part the composition tree, Compose can determine how a newly-emitted chunk of nodes relates to the previously-emitted nodes, and animate insertions and deletions and possibly moves. @Composable fun PeopleList ( people : List < PersonDto > , ... ) = Scaffold ( ... // title, actions, etc ) { paddingValues -> LazyColumn ( // AAA modifier = Modifier . padding ( paddingValues ) ) { items ( // BBB items = people , key = { it . id }, ) { Card ( // CCC elevation = 4. dp , modifier = Modifier . padding ( 8. dp ) . fillMaxWidth () ) { // DDD Row { Text ( text = it . name , modifier = Modifier . padding ( 8. dp ) . weight ( 1f ), // EEE ) Text ( text = it . age . toString (), modifier = Modifier . padding ( 8. dp ), ) } } } } } Line Description AAA LazyColumn dynamically emits nodes to the composition tree that will be visible (and others if necessary for scrolling and animation). Its content lambda declares which items are in the list, how to uniquely identify them, and what composition should display each item BBB items declares the list of data to display in the LazyColumn and how to get a unique key for each item. The keys allow LazyColumn to determine when items have been inserted, deleted or moved, optimizing recomposition and allowing animation CCC Card is a composable that displays a raised, rounded-corner rectangle around its contents. You'll often see these used in displayed lists, but they're not required. DDD The content composable lambda that declares the presentation of each item in the LazyColumn ] EEE When you use the weight modifier in a Column or Row , Compose assigns a proportion of the remaining space (after determining base sizes of each composable in the Row / Column ) to the node. In this case, only one node in the Row specifies a weight , so it gets all remaining space after the \"age\" Text has been sized. The result is the \"age\" getting pushed to the right (end) edge of the Row . If multiple nodes in a Row / Column specify weight , the weights are summed and each node gets a ratio of remaining space based on its weight divided by the sum. If two nodes have the the same weight, the remaining space is divided equally. If one node has weight 1 and the other weight 2, 1/3 of the remaining space goes to the first node, 2/3 goes to the second node. The above screen might look like Note If you want a horizontal display of items, LazyRow works similar. LazyHorizontalGrid and LazyVerticalGrid arrange more than one item horizontally or vertically in rows/columns. We're only working with LazyColumn in this course.","title":"Dynamic UIs"},{"location":"week-05/5.1-Compose-Lists/index.html#selection","text":"Sometimes you'd like to allow the user to select one or more items in the list and perform an action against them. This requires: A set to track which items are considered \"selected\", A declaration of user interaction that is considered \"selecting an item\", which will add the id of that item to the \"selected\" set. A declaration of user interaction that is considered navigating to that item's details (if applicable) Actions (passed to the topBar in the Scaffold ) that should be available when no items are selected one or more items are selected Colors to use to indicate an item is selected. We'll use the primary color in the theme, but you could choose a different one, such as primaryVariant or secondary colors. Let's look an an example UI: First, we've added an icon at the start of the cards: How does the user interact with the items? Tapping the icon or long-pressing anywhere in the row toggles the selection Tapping in the row anywhere except the icon if any items are selected, toggle this item if no items are selected, trigger navigation When any items are selected, we change the topBar in the Scaffold to display a navigation arrow icon. When pressed, all selections are cleared the number of selected items selection actions - \"delete\" in this case (deletes all selected items when tapped) We also highlight the selected items in the list. Note how the foreground and background colors are swapped We'll see the details of how to implement selection when we walk through the Movies UI, part 2.","title":"Selection"},{"location":"week-05/5.2-Movie-Ui-2/index.html","text":"Example Source: https://gitlab.com/android-development-2022-refresh/movie-ui-2","title":"Movie UI, part 2"},{"location":"week-05/5.2-Movie-Ui-2/STEP_010_REPO.html","text":"We start with a copy of our Movies app at the end of the \"Movie UI, part 1\" module.","title":"Start with Movies UI, Part 1"},{"location":"week-05/5.2-Movie-Ui-2/STEP_020_REPO.html","text":"First, we'll add scrolling to all display screens, just in case they have too much to fit on one screen. We do this by adding a verticalScroll modifier to each Column : Column ( modifier = Modifier . padding ( paddingValues ) . verticalScroll ( rememberScrollState ()) ) { The current scroll position is tracked in a ScrollState object. The rememberScrollState saves a ScrollState instance in a slot in the composition tree. It uses rememberSaveable rather than remember - this automatically saves and reloads the state across configuration changes. Note rememberSaveable saves the state outside of the view model, but the data is converted into binary form and then recreated after the new activity instance has been created. This is useful for state that isn't related to data from the data layer, state that only manages the details of a component (such as scroll position). You can use this for your own data; however, you must define a Saver that controls the marshaling to/from binary. We won't go into any more detail on this in this course, but know it's available if you're defining your own composable functions that need some managed data that you don't want to put into a view model. Next, we convert our main lists to use LazyColumn with Cards instead of just a Column of Text : Old code (Actor, for example): Column ( modifier = Modifier . padding ( paddingValues )) { actors . forEach { SimpleText ( text = it . name ) { onActorClick ( it . id ) } } } New Code LazyColumn ( modifier = Modifier . padding ( paddingValues ) ) { items ( items = actors , key = { it . id }, ) { Card ( elevation = 4. dp , modifier = Modifier . padding ( 8. dp ) . fillMaxWidth () ) { SimpleText ( text = it . name ) { onActorClick ( it . id ) } } } } This allows Compose to manage the list of actors/movies/ratings dynamically, only emitting the items that are visible or needed for scrolling/animation. The Cards are only here to make things look a little more interesting; they're never required.","title":"Scrolling Columns and LazyList"},{"location":"week-05/5.2-Movie-Ui-2/STEP_030_REPO.html","text":"Let's make the display screens a little nicer, using LazyColumn . For example, a movie display screen will look like We've added the movie description, a Divider and a LazyList of the cast. Here's the composition code for the movie display screen: MovieScaffold ( ... ) { paddingValues -> Column ( modifier = Modifier . padding ( paddingValues ) . fillMaxHeight () // AAA ) { movieWithCastDto ?. let { movieWithCast -> SimpleText ( // BBB text = movieWithCast . movie . description ) Divider () // CCC SimpleText ( // DDD text = stringResource ( id = R . string . cast ) ) LazyColumn ( // EEE modifier = Modifier . padding ( 8. dp ) . weight ( 1f ) // take up the rest of the screen ) { items ( items = movieWithCast . cast , ) { roleWithActor -> Card (...) } } } } } Line Description AAA Because we're adding in a LazyColumn , which controls its own scrolling, we no longer want the Column to scroll. The Column now fills the entire height that its parent allows. The fixed composables (description, divider and \"cast\") take up as much height as they need. The LazyColumn has a weight modifier which gives it all of the remaining space BBB CCC DDD Added description, a divider line, and a header for the \"cast\" section. EEE Note that our LazyColumn takes up the remainder of the screen and manages scrolling in that section Note If the \"fixed\" content is likely to be too big for the screen, or leave so little space that the cast list wouldn't be usable, you could keep the overall Column as scrollable and add a \"Cast\" button/link in place of the LazyColumn . Pressing it would open a separate screen for the \"Cast\" when it's pressed. (The IMDb app does something like this, as there is a lot of fixed-size data on the main screen for a movie, which requires overall scrolling). If you have User Experience Designers available to your team, talk with them about how to best use your screen space to give the user a great experience. The Rating display screen shows an interesting wrinkle. What do you do when a list is empty? One option is to display alternative composables. This is easy to do; just add an if / else expression! if ( ratingWithMovies . movies . isEmpty ()) { SimpleText ( text = stringResource ( id = R . string . no_movies_found_for_this_rating )) } else { ... // normal display of header and LazyColumn } This is a great usability enhancement over the old \"View\" system. We used to have to either dynamically add/remove views from the UI, or define all possible views that we might need, and show/hide them Using logical expressions inside our composable functions makes changing the UI quite simple.","title":"Cleanup the display screens"},{"location":"week-05/5.2-Movie-Ui-2/STEP_040_REPO.html","text":"Did you notice how much repeated code exists across the main list screens? It's pretty heavy right now, and it's going to get worse when we add selection code. So, we refactor the common code into ListScaffold . The main things we had to do to get this to work: Generify the names to \"item\" rather than \"movie\", \"actor\" and \"rating\" Add a generic type parameter to represent the type of Dto we're using Add a getId function parameter that allows us to pass in an item and get its id . We don't have any idea what the type of the list items are, so we can either Pass in a resolution function like this, or Add an interface HasId and make each type we care about implement it. HasId only contains an id property. We'd also need to change the generic type parameter to <T: HasId> to restrict the caller to only passing in types that implement it and allow the innards of the function to know that they can call .id on the item. Add in item icons/content description and a page title. Because we'll soon be using an icon to help in selection, we're adding it here. The ListScaffold will manage the clickable icon inside a Row , followed by the rest of the content that the caller wants to use to display each item. Note We define the itemContent parameter as itemContent : @Composable RowScope .( T ) -> Unit This is a \"slot\" that we require the caller to pass in. We'll provide it a RowScope receiver, so they can just continue filling in the row after the icon. We pass in the item for that row as a parameter. Now the caller lists are much simpler. For example: @Composable fun ActorList ( actors : List < ActorDto > , onSelectListScreen : ( Screen ) -> Unit , onResetDatabase : () -> Unit , onActorClick : ( String ) -> Unit , ) = ListScaffold ( titleId = R . string . screen_title_actors , items = actors , getId = { it . id }, onSelectListScreen = onSelectListScreen , onResetDatabase = onResetDatabase , onItemClick = onActorClick , itemIcon = Icons . Default . Person , itemIconContentDescriptionId = R . string . tap_to_toggle_selection , ) { actor -> SimpleText ( text = actor . name ) } Most of the parameters are just passed through or hard-wired based on the type of list items. The itemContent parameter is the last declared, so it can be moved outside the (...) to define the item content. It's also fine to keep it inside the (...) - for example: @Composable fun ActorList ( actors : List < ActorDto > , onSelectListScreen : ( Screen ) -> Unit , onResetDatabase : () -> Unit , onActorClick : ( String ) -> Unit , ) = ListScaffold ( titleId = R . string . screen_title_actors , items = actors , getId = { it . id }, onSelectListScreen = onSelectListScreen , onResetDatabase = onResetDatabase , onItemClick = onActorClick , itemIcon = Icons . Default . Person , itemIconContentDescriptionId = R . string . tap_to_toggle_selection , itemContent = { actor -> SimpleText ( text = actor . name ) } ) I tend to prefer to have body \"content\" outside the parens. In this case, the ListScaffold manages the \"body\", so the itemContent can appear outside. Our UI now looks like","title":"Refactor the list screens"},{"location":"week-05/5.2-Movie-Ui-2/STEP_050_REPO.html","text":"Now the real fun begins... Selecting items on the main list screens and deleting them from the database. Let's start in the Data Layer . We're going to have a set of ids of items we want to delete. We can either look up all the items and then pass them to our existing delete functions, or, we can create new DAO functions that will delete by ids. I prefer the latter, as we don't need to do additional lookups. DAO changes In the DAO, we add @Query ( \"DELETE FROM Movie WHERE id IN (:ids)\" ) abstract suspend fun deleteMoviesById ( ids : Set < String > ) @Query ( \"DELETE FROM Actor WHERE id IN (:ids)\" ) abstract suspend fun deleteActorsById ( ids : Set < String > ) @Query ( \"DELETE FROM Rating WHERE id IN (:ids)\" ) abstract suspend fun deleteRatingsById ( ids : Set < String > ) Repository Changes We add simple pass-throughs in the repository, making them available in the view model. View Model Changes Things get a little more interesting here. We need to track what's selected on the screen. We could add the selection information to the Screen objects that allow selection, but then we'd need to be able to update the Screen objects or replace the top Screen on the stack. Instead, we decide that because only one list Screen is visible at a time, and we cannot navigate when items are selected, we'll just keep a single selection set in the view model: var selectedItemIds by mutableStateOf < Set < String >> ( emptySet ()) private set Using Compose State means that whenever we update the value, Compose will trigger recomposition on users of that data, if needed. However , to keep the view model consistent, we must make sure we clear the selected items whenever we navigate: Note If the selected items were stored in the Screen we wouldn't need this clear step. private var screenStack : List < Screen > = listOf ( MovieList ) set ( value ) { field = value screen = value . lastOrNull () clearSelections () } fun clearSelections () { selectedItemIds = emptySet () } We've defined a clearSelections function that does what it says, and call it whenever the screenStack changes. We'll finish out the functions we need to manage the selections and delete entities: fun toggleSelection ( id : String ) { selectedItemIds = if ( id in selectedItemIds ) { selectedItemIds - id } else { selectedItemIds + id } } fun deleteSelectedActors () { viewModelScope . launch { repository . deleteActorsById ( selectedItemIds ) clearSelections () } } fun deleteSelectedMovies () { viewModelScope . launch { repository . deleteMoviesById ( selectedItemIds ) clearSelections () } } fun deleteSelectedRatings () { viewModelScope . launch { repository . deleteRatingsById ( selectedItemIds ) clearSelections () } } The toggleSelection function will be called when the user interacts with an item: If they click its icon, we call toggleSelection If they long-press anywhere on a row, call toggleSelection If the click anywhere else in the row If there are no selections, navigate to the item detail If there are selections, treat it as a toggle The delete functions kick off a coroutine to do the deletions and then clear the selection set. List and Movie Scaffold Changes Here's where the interesting work happens. We pass in some new parameters @Composable fun < T > ListScaffold ( ... selectedItemIds : Set < String > , // the current selections onClearSelections : () -> Unit , // tell the caller to clear onToggleSelection : ( String ) -> Unit , // toggle an item's id onDeleteSelectedItems : () -> Unit , // delete all selected items ... ) Any screen that wants to display a top-level list must tell us what's selected, how to update selections and delete the selected items. Some of this info gets passed to MovieScaffold : @Composable fun < T > ListScaffold ( ... ) = MovieScaffold ( ... selectedItemCount = selectedItemIds . size , ... onDeleteSelectedItems = onDeleteSelectedItems , onClearSelections = onClearSelections , ) MovieScaffold is pretty straightforward: If selectedItemCount is zero, display normal top app bar If selectedItemCount is non-zero, display contextual top app bar Has \"back\" arrow icon - calls onClearSelections when pressed Shows selectedItemCount Has \"delete\" action - calls onDeleteSelectedItems when pressed The rest of ListScaffold has some interesting parts: We select a backgroundColor and contentColor based on whether or not an item is selected. (An item is considered selected if its id is in selectedItemIds ) We define a pointerInput modifier to process user taps and long-presses, calling the appropriate functions that were passed into ListScaffold . We set the backgroundColor on the Card (and remove it from the Row ), based on the selection status. We set the colors for the Icon background and foreground, again based on the selection status, and make the icon clickable. Note The contentColorFor function is a great helper that automates the selection of a color on top of a background color Caution The lambda that defines the gesture handler only runs once, and then again whenever the key passed to pointerInput changes. The gesture handler would capture the value of selectedItemIds - if the selections change, the gesture handler would never know of it. We could either pass selectedItemIds as a key to pointerInput , forcing it to redefine the gesture handler every time the selections change, or, we can create an updateable bucket in the composition tree for the selections. We'll use the latter to avoid redefining the gesture handlers. Top-Level Ui Changes Finally, we wire the screens to the view model, passing in the selected ids and the new view model functions to clear/toggle selections and delete selected items. But there's a problem... When we run the code from this step, we can select and delete items. But we run into trouble when we try to look at roles that reference deleted data. For example, if we delete \"The Transporter\", then try to view \"Jason Statham\", we get E/AndroidRuntime: FATAL EXCEPTION: main Process: com.javadude.movies, PID: 17550 java.lang.NullPointerException: Parameter specified as non-null is null: method kotlin.jvm.internal.Intrinsics.checkNotNullParameter, parameter movie The problem is that The Transporter is still referenced by Role entities. When we try to load Jason Statham's filmography, Room cannot resolve the reference and throws an exception. Our database is now inconsistent!","title":"Selection and Deletion"},{"location":"week-05/5.2-Movie-Ui-2/STEP_050_REPO.html#dao-changes","text":"In the DAO, we add @Query ( \"DELETE FROM Movie WHERE id IN (:ids)\" ) abstract suspend fun deleteMoviesById ( ids : Set < String > ) @Query ( \"DELETE FROM Actor WHERE id IN (:ids)\" ) abstract suspend fun deleteActorsById ( ids : Set < String > ) @Query ( \"DELETE FROM Rating WHERE id IN (:ids)\" ) abstract suspend fun deleteRatingsById ( ids : Set < String > )","title":"DAO changes"},{"location":"week-05/5.2-Movie-Ui-2/STEP_050_REPO.html#repository-changes","text":"We add simple pass-throughs in the repository, making them available in the view model.","title":"Repository Changes"},{"location":"week-05/5.2-Movie-Ui-2/STEP_050_REPO.html#view-model-changes","text":"Things get a little more interesting here. We need to track what's selected on the screen. We could add the selection information to the Screen objects that allow selection, but then we'd need to be able to update the Screen objects or replace the top Screen on the stack. Instead, we decide that because only one list Screen is visible at a time, and we cannot navigate when items are selected, we'll just keep a single selection set in the view model: var selectedItemIds by mutableStateOf < Set < String >> ( emptySet ()) private set Using Compose State means that whenever we update the value, Compose will trigger recomposition on users of that data, if needed. However , to keep the view model consistent, we must make sure we clear the selected items whenever we navigate: Note If the selected items were stored in the Screen we wouldn't need this clear step. private var screenStack : List < Screen > = listOf ( MovieList ) set ( value ) { field = value screen = value . lastOrNull () clearSelections () } fun clearSelections () { selectedItemIds = emptySet () } We've defined a clearSelections function that does what it says, and call it whenever the screenStack changes. We'll finish out the functions we need to manage the selections and delete entities: fun toggleSelection ( id : String ) { selectedItemIds = if ( id in selectedItemIds ) { selectedItemIds - id } else { selectedItemIds + id } } fun deleteSelectedActors () { viewModelScope . launch { repository . deleteActorsById ( selectedItemIds ) clearSelections () } } fun deleteSelectedMovies () { viewModelScope . launch { repository . deleteMoviesById ( selectedItemIds ) clearSelections () } } fun deleteSelectedRatings () { viewModelScope . launch { repository . deleteRatingsById ( selectedItemIds ) clearSelections () } } The toggleSelection function will be called when the user interacts with an item: If they click its icon, we call toggleSelection If they long-press anywhere on a row, call toggleSelection If the click anywhere else in the row If there are no selections, navigate to the item detail If there are selections, treat it as a toggle The delete functions kick off a coroutine to do the deletions and then clear the selection set.","title":"View Model Changes"},{"location":"week-05/5.2-Movie-Ui-2/STEP_050_REPO.html#list-and-movie-scaffold-changes","text":"Here's where the interesting work happens. We pass in some new parameters @Composable fun < T > ListScaffold ( ... selectedItemIds : Set < String > , // the current selections onClearSelections : () -> Unit , // tell the caller to clear onToggleSelection : ( String ) -> Unit , // toggle an item's id onDeleteSelectedItems : () -> Unit , // delete all selected items ... ) Any screen that wants to display a top-level list must tell us what's selected, how to update selections and delete the selected items. Some of this info gets passed to MovieScaffold : @Composable fun < T > ListScaffold ( ... ) = MovieScaffold ( ... selectedItemCount = selectedItemIds . size , ... onDeleteSelectedItems = onDeleteSelectedItems , onClearSelections = onClearSelections , ) MovieScaffold is pretty straightforward: If selectedItemCount is zero, display normal top app bar If selectedItemCount is non-zero, display contextual top app bar Has \"back\" arrow icon - calls onClearSelections when pressed Shows selectedItemCount Has \"delete\" action - calls onDeleteSelectedItems when pressed The rest of ListScaffold has some interesting parts: We select a backgroundColor and contentColor based on whether or not an item is selected. (An item is considered selected if its id is in selectedItemIds ) We define a pointerInput modifier to process user taps and long-presses, calling the appropriate functions that were passed into ListScaffold . We set the backgroundColor on the Card (and remove it from the Row ), based on the selection status. We set the colors for the Icon background and foreground, again based on the selection status, and make the icon clickable. Note The contentColorFor function is a great helper that automates the selection of a color on top of a background color Caution The lambda that defines the gesture handler only runs once, and then again whenever the key passed to pointerInput changes. The gesture handler would capture the value of selectedItemIds - if the selections change, the gesture handler would never know of it. We could either pass selectedItemIds as a key to pointerInput , forcing it to redefine the gesture handler every time the selections change, or, we can create an updateable bucket in the composition tree for the selections. We'll use the latter to avoid redefining the gesture handlers.","title":"List and Movie Scaffold Changes"},{"location":"week-05/5.2-Movie-Ui-2/STEP_050_REPO.html#top-level-ui-changes","text":"Finally, we wire the screens to the view model, passing in the selected ids and the new view model functions to clear/toggle selections and delete selected items.","title":"Top-Level Ui Changes"},{"location":"week-05/5.2-Movie-Ui-2/STEP_050_REPO.html#but-theres-a-problem","text":"When we run the code from this step, we can select and delete items. But we run into trouble when we try to look at roles that reference deleted data. For example, if we delete \"The Transporter\", then try to view \"Jason Statham\", we get E/AndroidRuntime: FATAL EXCEPTION: main Process: com.javadude.movies, PID: 17550 java.lang.NullPointerException: Parameter specified as non-null is null: method kotlin.jvm.internal.Intrinsics.checkNotNullParameter, parameter movie The problem is that The Transporter is still referenced by Role entities. When we try to load Jason Statham's filmography, Room cannot resolve the reference and throws an exception. Our database is now inconsistent!","title":"But there's a problem..."},{"location":"week-05/5.2-Movie-Ui-2/STEP_060_REPO.html","text":"One solution would be to explicitly delete any Roles that reference Movies or Actors that we're deleting. A good bit of work... Fortunately, there's another solution that Room (and the database behind it) support: Referential Integrity. We can define some rules to either automatically delete entities that reference deleted data, or disallow deleting the referenced items until the references are deleted. We'll go the first route. A Role doesn't make sense if either the Movie or Actor has been deleted. We will set up a \"cascading deletion\" - when the referenced Movie or Actor is deleted, we ask Room to delete the Role : @Entity ( primaryKeys = [ \"actorId\" , \"movieId\" ] , indices = [ Index ( value = [ \"movieId\" ] ), Index ( value = [ \"actorId\" ] ), ] , foreignKeys = [ ForeignKey ( entity = Actor :: class , parentColumns = [ \"id\" ] , childColumns = [ \"actorId\" ] , onUpdate = ForeignKey . CASCADE , onDelete = ForeignKey . CASCADE , ), ForeignKey ( entity = Movie :: class , parentColumns = [ \"id\" ] , childColumns = [ \"movieId\" ] , onUpdate = ForeignKey . CASCADE , onDelete = ForeignKey . CASCADE , ), ] ) data class Role ( var movieId : String , var actorId : String , var character : String , var orderInCredits : Int , ) This updated @Entity annotation does the following: We add indexes to improve lookup performance We define explicit ForeignKeys to declare how our actorId and movieId are associated with the Actor and Movie entities. The entity states a parent entity. In this case, we treat it as an owner , an entity that must exist for our Role to make sense. onUpdate says \"if the id of the parent changes, update my corresponding reference id \". For example, if the referenced movie's id changes, change my movieId . onDelete says \"if the referenced parent is deleted, delete me\". This works for either the Movie or Actor being referenced. This fixes our problem! Note When you change the entity definition like this, the database on disk no longer matches the definition. You'll see something like the following when you run the updated application: java.lang.IllegalStateException: Room cannot verify the data integrity. Looks like you've changed schema but forgot to update the version number. You can simply fix this by increasing the version number. You'll either need to increment the database version (in MovieDatabase.kt ), or uninstall and reinstall the application (which will delete the database file and recreate it). If you haven't published the application, I'd recommend just uninstalling and reinstalling the app while you're testing. If you've deployed, you'll need to increase the database version and likely set up migration rules (which is beyond the scope of this course, but easily found online).","title":"Referential Integrity"},{"location":"week-05/5.2-Movie-Ui-2/STEP_070_REPO.html","text":"What if our user wants to edit the data? Let's take a look at editing a Movie . We define a MovieEdit function (we'll talk about it in detail later) that takes a movieId and lets you edit its title and description . We won't be changing any roles. Because of this, we only need to fetch the Movie itself, and not the MovieWithCast . The Data Layer We've already got an update function for our Movie , but we're going to need a way to fetch a Movie by itself... This is trivial using Room (in the MovieDAO ) @Query ( \"SELECT * FROM Movie WHERE id = :id\" ) abstract suspend fun getMovie ( id : String ): Movie We propagate it up through the repository to make it accessible to the UI layer. Updating DTOs The DTO objects that we work with are immutable data classes. We must create a new instance when we want to change it. Kotlin data classes generate a copy function that looks like (for MovieDto ) fun copy ( id : String = this . id , name : String = this . name , age : Int = this . age , ) = MovieDto ( id = id , name = name , age = age ) This wonderful little function allows you to pass only the properties that you want to change; everything else gets the current value. You use it like: val newMovie = movie . copy ( name = newName ) We'll use this to create new DTOs that we pass to the update function in the repository. Auto update vs User-Triggered There are two main approaches to updating the data in the data layer. Wait for the user to indicate they're done, then save the data. This could be an explicit \"done\" button. Pressing \"done\" calls update once and exits the edit screen Pressing \"cancel\" or \"back\" just exits (but typically presents a dialog asking \"are you sure you want to lose your changes?\") This could be done by listening for \"back\", and then save Might have a cancel button as well that backs out without saving data This is simpler to code, as you have an explicit spot to perform updates and don't need to worry too much about how long the save takes and if it competes with other saves Update the data as the user is typing it This is especially useful if the data appears in multiple parts of the UI. For example, a screen that has a \"list\" of items next to a \"detail\" pane that's letting you edit the data. As you type, you'd see the values change in the list as well as the fields you're typing. The concern is that this would cause many updates, which could cause performance issues or excessive network data use. It's possible for multiple fast updates to run at the same time, out of order. For the class examples, we'll be using the \"update as the user types\" approach, with some \"debouncing\" to help ordering, performance and network data use. View Model Changes First - note that we've added a new Screen type named MovieEdit . We'll use this as a navigation target. The basic update that we want to make looks like fun updateMovie ( movieDto : MovieDto ) { viewModelScope . launch { repository . update ( movieDto ) } } We start a new coroutine to pass our new DTO to update in the repository. But this can cause some nasty issues... If the updates are sent quickly (and/or the updates take a while behind the scenes, such as a slow web service call), we could have multiple coroutines in play at the same time. When that happens, they can run in any order. Think about what happens if you type \"abc\" in a field and want to update the object on the fly. We could get three updates running at the same time for values \"a\" \"ab\" \"abc\" If they run in that order, all is well. But if they run in another order, we could end up with data stored in the database that doesn't match what the user wanted. And if they did run in the correct order, we could have more database or network updates than were really needed. To fix this, we can \"debounce\" the updates. The idea here is that we won't actually call update in the repository unless the user has been idle for a period of time. If they're typing, we would get an update request to the view model for each letter, but wait until the user pauses before sending the current update to the repository. An easy way to do this is to track the last-run job and cancel if a new job comes in before it's finished. Adding a delay at the start of the coroutine allows the cancel to take effect if a second coroutine is launched before the delay completes. This looks like private var movieUpdateJob : Job? = null fun updateMovie ( movieDto : MovieDto ) { movieUpdateJob ?. cancel () movieUpdateJob = viewModelScope . launch { delay ( 500 ) repository . update ( movieDto ) movieUpdateJob = null } } The movieUpdayteJob variable keeps track of the last-launched job. If another update is requested, it cancels the previous coroutine before starting a new coroutine. The coroutine delays for 500ms. If more updates come in, with less than 500ms between them, the current job will keep getting canceled. Once the user pauses for at least 500ms, the update will be sent to the repository. MovieScaffold/MovieDisplay Changes We need some way for the user to enter the MovieEdit screen. I'm placing an edit icon (looks like a pencil) on the top app bar when the MovieDisplay screen is displayed. To do this, I've updated the MovieScaffold by adding an onEdit parameter: @Composable fun MovieScaffold ( ... onEdit : (() -> Unit ) ? = null , ... ) { ... } This parameter is a nullable function that takes no parameters and doesn't return anything. We default it to null; if the caller (one of the screen composable functions) doesn't specify it, it'll be null. Inside the function we set up an edit on the top app bar if onEdit isn't null: TopAppBar ( ... actions = { onEdit ?. let { onEdit -> IconButton ( onClick = onEdit , modifier = Modifier . padding ( 8. dp ), ) { Icon ( imageVector = Icons . Default . Edit , contentDescription = stringResource ( id = R . string . edit ), ) } } ... } ... } Then we call MovieScaffold from MovieDisplay : @Composable fun MovieDisplay ( ... onEdit : ( String ) -> Unit , ) { var movieWithCastDto by remember { mutableStateOf < MovieWithCastDto?> ( null ) } LaunchedEffect ( key1 = movieId ) { // starts a coroutine to fetch the rating movieWithCastDto = fetchMovieWithCast ( movieId ) } MovieScaffold ( ... onEdit = movieWithCastDto ?. let { movieWithCast -> { onEdit ( movieWithCast . movie . id ) } } ) { ... } } Once the movie has been loaded, we create a lambda with the onEdit call inside, and pass that to onEdit in the MovieScaffold . The Ui composable manages the navigation and adds the call to the new MovieEdit screen: when ( val screen = viewModel . screen ) { ... is MovieDisplay -> MovieDisplay ( ... onEdit = { id -> viewModel . pushScreen ( MovieEdit ( id )) } ) is MovieEdit -> MovieEdit ( ... ) } MovieEdit Now comes the tricky part. At least it's a little tricky to describe... Jetpack Compose's TextField is the composable function that declares your text input field. We'll be using OutlinedTextField, which gives a border with a nice label for the input. Using OutlinedTextField , our MovieEdit screen will look like Compose's TextField (and OutlinedTextField ) take two main parameters value - the current value to display onValueChange - the event function that's called when TextField sees the user change the value. The TextField itself will not automatically update the displayed value. Rather, it calls onValueChange , and you'll pass in a new value. This gives you a chance to format or validate the value. But it also means you'll need to store that value somewhere. You could just pass in movie.title for value , and a lambda that updates the Movie in the database. However, if we debounce, we won't actually see that value in the text field until the user stops typing. If we didn't debounce, the user's typing might outpace the data updates. Sometimes the updates get out of order, which can cause the wrong values to be displayed. And sometimes this causes a race between the caret position in the text field and the value being updated. I've seen some interesting situations where I'm typing quickly (using a physical keyboard) and suddenly the caret is in the middle of the text and my typing continues there. Not good. What do we do? Create a MutableState (I like to call them a \"bucket\" for data) and store it in the composition tree via remember Key the remember on the DTO that was looked up by id Initialize the value from the DTO Get the value for the text field from the bucket Whenever we get onValueChange from the text field Update the value in the bucket - this makes it quickly available for display Ask to update the movie value The relevant parts of MovieEdit look like @Composable fun MovieEdit ( movieId : String , fetchMovie : suspend ( String ) -> MovieDto , ... onMovieUpdate : ( MovieDto ) -> Unit , ) { var movieDto by remember { mutableStateOf < MovieDto?> ( null ) } LaunchedEffect ( key1 = movieId ) { // starts a coroutine to fetch the rating movieDto = fetchMovie ( movieId ) } var title by remember ( movieDto ) { mutableStateOf ( movieDto ?. title ) } var description by remember ( movieDto ) { mutableStateOf ( movieDto ?. description ) } MovieScaffold (...) { paddingValues -> Column (...) { TextEntry ( labelId = R . string . title , placeholderId = R . string . movie_title_placeholder , value = title , onValueChange = { title = it movieDto ?. let { movie -> onMovieUpdate ( movie . copy ( title = it )) } }, ) ... } } }","title":"Editing Entities"},{"location":"week-05/5.2-Movie-Ui-2/STEP_070_REPO.html#the-data-layer","text":"We've already got an update function for our Movie , but we're going to need a way to fetch a Movie by itself... This is trivial using Room (in the MovieDAO ) @Query ( \"SELECT * FROM Movie WHERE id = :id\" ) abstract suspend fun getMovie ( id : String ): Movie We propagate it up through the repository to make it accessible to the UI layer.","title":"The Data Layer"},{"location":"week-05/5.2-Movie-Ui-2/STEP_070_REPO.html#updating-dtos","text":"The DTO objects that we work with are immutable data classes. We must create a new instance when we want to change it. Kotlin data classes generate a copy function that looks like (for MovieDto ) fun copy ( id : String = this . id , name : String = this . name , age : Int = this . age , ) = MovieDto ( id = id , name = name , age = age ) This wonderful little function allows you to pass only the properties that you want to change; everything else gets the current value. You use it like: val newMovie = movie . copy ( name = newName ) We'll use this to create new DTOs that we pass to the update function in the repository.","title":"Updating DTOs"},{"location":"week-05/5.2-Movie-Ui-2/STEP_070_REPO.html#auto-update-vs-user-triggered","text":"There are two main approaches to updating the data in the data layer. Wait for the user to indicate they're done, then save the data. This could be an explicit \"done\" button. Pressing \"done\" calls update once and exits the edit screen Pressing \"cancel\" or \"back\" just exits (but typically presents a dialog asking \"are you sure you want to lose your changes?\") This could be done by listening for \"back\", and then save Might have a cancel button as well that backs out without saving data This is simpler to code, as you have an explicit spot to perform updates and don't need to worry too much about how long the save takes and if it competes with other saves Update the data as the user is typing it This is especially useful if the data appears in multiple parts of the UI. For example, a screen that has a \"list\" of items next to a \"detail\" pane that's letting you edit the data. As you type, you'd see the values change in the list as well as the fields you're typing. The concern is that this would cause many updates, which could cause performance issues or excessive network data use. It's possible for multiple fast updates to run at the same time, out of order. For the class examples, we'll be using the \"update as the user types\" approach, with some \"debouncing\" to help ordering, performance and network data use.","title":"Auto update vs User-Triggered"},{"location":"week-05/5.2-Movie-Ui-2/STEP_070_REPO.html#view-model-changes","text":"First - note that we've added a new Screen type named MovieEdit . We'll use this as a navigation target. The basic update that we want to make looks like fun updateMovie ( movieDto : MovieDto ) { viewModelScope . launch { repository . update ( movieDto ) } } We start a new coroutine to pass our new DTO to update in the repository. But this can cause some nasty issues... If the updates are sent quickly (and/or the updates take a while behind the scenes, such as a slow web service call), we could have multiple coroutines in play at the same time. When that happens, they can run in any order. Think about what happens if you type \"abc\" in a field and want to update the object on the fly. We could get three updates running at the same time for values \"a\" \"ab\" \"abc\" If they run in that order, all is well. But if they run in another order, we could end up with data stored in the database that doesn't match what the user wanted. And if they did run in the correct order, we could have more database or network updates than were really needed. To fix this, we can \"debounce\" the updates. The idea here is that we won't actually call update in the repository unless the user has been idle for a period of time. If they're typing, we would get an update request to the view model for each letter, but wait until the user pauses before sending the current update to the repository. An easy way to do this is to track the last-run job and cancel if a new job comes in before it's finished. Adding a delay at the start of the coroutine allows the cancel to take effect if a second coroutine is launched before the delay completes. This looks like private var movieUpdateJob : Job? = null fun updateMovie ( movieDto : MovieDto ) { movieUpdateJob ?. cancel () movieUpdateJob = viewModelScope . launch { delay ( 500 ) repository . update ( movieDto ) movieUpdateJob = null } } The movieUpdayteJob variable keeps track of the last-launched job. If another update is requested, it cancels the previous coroutine before starting a new coroutine. The coroutine delays for 500ms. If more updates come in, with less than 500ms between them, the current job will keep getting canceled. Once the user pauses for at least 500ms, the update will be sent to the repository.","title":"View Model Changes"},{"location":"week-05/5.2-Movie-Ui-2/STEP_070_REPO.html#moviescaffoldmoviedisplay-changes","text":"We need some way for the user to enter the MovieEdit screen. I'm placing an edit icon (looks like a pencil) on the top app bar when the MovieDisplay screen is displayed. To do this, I've updated the MovieScaffold by adding an onEdit parameter: @Composable fun MovieScaffold ( ... onEdit : (() -> Unit ) ? = null , ... ) { ... } This parameter is a nullable function that takes no parameters and doesn't return anything. We default it to null; if the caller (one of the screen composable functions) doesn't specify it, it'll be null. Inside the function we set up an edit on the top app bar if onEdit isn't null: TopAppBar ( ... actions = { onEdit ?. let { onEdit -> IconButton ( onClick = onEdit , modifier = Modifier . padding ( 8. dp ), ) { Icon ( imageVector = Icons . Default . Edit , contentDescription = stringResource ( id = R . string . edit ), ) } } ... } ... } Then we call MovieScaffold from MovieDisplay : @Composable fun MovieDisplay ( ... onEdit : ( String ) -> Unit , ) { var movieWithCastDto by remember { mutableStateOf < MovieWithCastDto?> ( null ) } LaunchedEffect ( key1 = movieId ) { // starts a coroutine to fetch the rating movieWithCastDto = fetchMovieWithCast ( movieId ) } MovieScaffold ( ... onEdit = movieWithCastDto ?. let { movieWithCast -> { onEdit ( movieWithCast . movie . id ) } } ) { ... } } Once the movie has been loaded, we create a lambda with the onEdit call inside, and pass that to onEdit in the MovieScaffold . The Ui composable manages the navigation and adds the call to the new MovieEdit screen: when ( val screen = viewModel . screen ) { ... is MovieDisplay -> MovieDisplay ( ... onEdit = { id -> viewModel . pushScreen ( MovieEdit ( id )) } ) is MovieEdit -> MovieEdit ( ... ) }","title":"MovieScaffold/MovieDisplay Changes"},{"location":"week-05/5.2-Movie-Ui-2/STEP_070_REPO.html#movieedit","text":"Now comes the tricky part. At least it's a little tricky to describe... Jetpack Compose's TextField is the composable function that declares your text input field. We'll be using OutlinedTextField, which gives a border with a nice label for the input. Using OutlinedTextField , our MovieEdit screen will look like Compose's TextField (and OutlinedTextField ) take two main parameters value - the current value to display onValueChange - the event function that's called when TextField sees the user change the value. The TextField itself will not automatically update the displayed value. Rather, it calls onValueChange , and you'll pass in a new value. This gives you a chance to format or validate the value. But it also means you'll need to store that value somewhere. You could just pass in movie.title for value , and a lambda that updates the Movie in the database. However, if we debounce, we won't actually see that value in the text field until the user stops typing. If we didn't debounce, the user's typing might outpace the data updates. Sometimes the updates get out of order, which can cause the wrong values to be displayed. And sometimes this causes a race between the caret position in the text field and the value being updated. I've seen some interesting situations where I'm typing quickly (using a physical keyboard) and suddenly the caret is in the middle of the text and my typing continues there. Not good. What do we do? Create a MutableState (I like to call them a \"bucket\" for data) and store it in the composition tree via remember Key the remember on the DTO that was looked up by id Initialize the value from the DTO Get the value for the text field from the bucket Whenever we get onValueChange from the text field Update the value in the bucket - this makes it quickly available for display Ask to update the movie value The relevant parts of MovieEdit look like @Composable fun MovieEdit ( movieId : String , fetchMovie : suspend ( String ) -> MovieDto , ... onMovieUpdate : ( MovieDto ) -> Unit , ) { var movieDto by remember { mutableStateOf < MovieDto?> ( null ) } LaunchedEffect ( key1 = movieId ) { // starts a coroutine to fetch the rating movieDto = fetchMovie ( movieId ) } var title by remember ( movieDto ) { mutableStateOf ( movieDto ?. title ) } var description by remember ( movieDto ) { mutableStateOf ( movieDto ?. description ) } MovieScaffold (...) { paddingValues -> Column (...) { TextEntry ( labelId = R . string . title , placeholderId = R . string . movie_title_placeholder , value = title , onValueChange = { title = it movieDto ?. let { movie -> onMovieUpdate ( movie . copy ( title = it )) } }, ) ... } } }","title":"MovieEdit"},{"location":"week-06/6.1-Compose-graphics-1/index.html","text":"Introduction Building custom components with Jetpack Compose is significantly easier than it used to be with the old View approach! In this module, we'll take a quick look at the old way and compare it to Compose, then dive in for some progressively more complex custom components, drawing everything ourselves to create exactly the UI we would like. Video Total video time for this module: 1:47:55 Note You can change the quality and playback speed by clicking the icon when the video is playing. If you would like to search the captions for this video, click Watch on YouTube , press \"...\" and choose Show Transcript . Jetpack Compose Graphics: Introduction (Fall 2021) (06:50) Jetpack Compose Graphics: A Simple Gauge (Fall 2021) (24:32) Jetpack Compose Graphics: An Analog Clock (Fall 2021) (20:00) Jetpack Compose Graphics: Graph Editor, Part 1 (Fall 2021) (56:33) Example Source See: https://gitlab.com/android-development-2022-refresh/compose-graphics-1","title":"Compose Graphics 1"},{"location":"week-06/6.1-Compose-graphics-1/index.html#introduction","text":"Building custom components with Jetpack Compose is significantly easier than it used to be with the old View approach! In this module, we'll take a quick look at the old way and compare it to Compose, then dive in for some progressively more complex custom components, drawing everything ourselves to create exactly the UI we would like.","title":"Introduction"},{"location":"week-06/6.1-Compose-graphics-1/index.html#video","text":"Total video time for this module: 1:47:55 Note You can change the quality and playback speed by clicking the icon when the video is playing. If you would like to search the captions for this video, click Watch on YouTube , press \"...\" and choose Show Transcript .","title":"Video"},{"location":"week-06/6.1-Compose-graphics-1/index.html#jetpack-compose-graphics-introduction-fall-2021-0650","text":"","title":"Jetpack Compose Graphics: Introduction (Fall 2021) (06:50)"},{"location":"week-06/6.1-Compose-graphics-1/index.html#jetpack-compose-graphics-a-simple-gauge-fall-2021-2432","text":"","title":"Jetpack Compose Graphics: A Simple Gauge (Fall 2021) (24:32)"},{"location":"week-06/6.1-Compose-graphics-1/index.html#jetpack-compose-graphics-an-analog-clock-fall-2021-2000","text":"","title":"Jetpack Compose Graphics: An Analog Clock (Fall 2021) (20:00)"},{"location":"week-06/6.1-Compose-graphics-1/index.html#jetpack-compose-graphics-graph-editor-part-1-fall-2021-5633","text":"","title":"Jetpack Compose Graphics: Graph Editor, Part 1 (Fall 2021) (56:33)"},{"location":"week-06/6.1-Compose-graphics-1/index.html#example-source","text":"See: https://gitlab.com/android-development-2022-refresh/compose-graphics-1","title":"Example Source"},{"location":"week-07/7.1-Compose-graphics-2/index.html","text":"Introduction We continue our Graph editor application, adding support for * Blinking like-typed shapes when clicked * Dragging shapes * Drawing lines between objects (that stay connected when the shapes are moved) Note that I walk through several intentional errors during these videos and explain why they occur/how to fix them. The user tap/drag interaction can be trickier to get right than it seems, so I wanted to highlight common problems and show that sometimes an \"obvious\" design may not be correct... Videos Total video time for this module: 1:57:28 Jetpack Compose Graphics: Blinking and Internal Compiler Errors (Fall 2021) (52:55) Jetpack Compose Graphics: Dragging and Connecting (Fall 2021) (1:04:33) Example Source See: https://gitlab.com/android-development-2022-refresh/compose-graphics-2","title":"Compose Graphics 2"},{"location":"week-07/7.1-Compose-graphics-2/index.html#introduction","text":"We continue our Graph editor application, adding support for * Blinking like-typed shapes when clicked * Dragging shapes * Drawing lines between objects (that stay connected when the shapes are moved) Note that I walk through several intentional errors during these videos and explain why they occur/how to fix them. The user tap/drag interaction can be trickier to get right than it seems, so I wanted to highlight common problems and show that sometimes an \"obvious\" design may not be correct...","title":"Introduction"},{"location":"week-07/7.1-Compose-graphics-2/index.html#videos","text":"Total video time for this module: 1:57:28","title":"Videos"},{"location":"week-07/7.1-Compose-graphics-2/index.html#jetpack-compose-graphics-blinking-and-internal-compiler-errors-fall-2021-5255","text":"","title":"Jetpack Compose Graphics: Blinking and Internal Compiler Errors (Fall 2021) (52:55)"},{"location":"week-07/7.1-Compose-graphics-2/index.html#jetpack-compose-graphics-dragging-and-connecting-fall-2021-10433","text":"","title":"Jetpack Compose Graphics: Dragging and Connecting (Fall 2021) (1:04:33)"},{"location":"week-07/7.1-Compose-graphics-2/index.html#example-source","text":"See: https://gitlab.com/android-development-2022-refresh/compose-graphics-2","title":"Example Source"},{"location":"week-08/8.1-Rest/index.html","text":"Introduction Android applications often communicate with servers to manage common data. In this module, we'll look at RESTful Web Services and see how your application can communicate with them to manage remote data. Videos Total video time for this module: 25:48 REST: Lecture (Fall 2021) (07:04) REST: Example (Fall 2021) (18:44) Example Source See: https://gitlab.com/android-development-2022-refresh/rest","title":"Rest"},{"location":"week-08/8.1-Rest/index.html#introduction","text":"Android applications often communicate with servers to manage common data. In this module, we'll look at RESTful Web Services and see how your application can communicate with them to manage remote data.","title":"Introduction"},{"location":"week-08/8.1-Rest/index.html#videos","text":"Total video time for this module: 25:48","title":"Videos"},{"location":"week-08/8.1-Rest/index.html#rest-lecture-fall-2021-0704","text":"","title":"REST: Lecture (Fall 2021) (07:04)"},{"location":"week-08/8.1-Rest/index.html#rest-example-fall-2021-1844","text":"","title":"REST: Example (Fall 2021) (18:44)"},{"location":"week-08/8.1-Rest/index.html#example-source","text":"See: https://gitlab.com/android-development-2022-refresh/rest","title":"Example Source"},{"location":"week-08/8.2-Compose-Layouts/index.html","text":"Introduction Arranging your Composables can be tricky to get right. Jetpack Compose's included layouts give you the basic support you need for most layouts, but you can gain more control and simpler specification with a custom layout. We'll also see how a \"slotted\" layout allows you to define a common overall structure where you can plug in each section of the layout. In this module, we'll explore different ways to create a simple \"Forms\" interface, starting with basic Rows and Columns, trying out ConstraintLayout, then creating our own layout manager that will adapt to show a form differently based on available space. Videos Total video time for this module: 2:17:34 Example: Basic and Custom Layouts (Fall 2021) (1:11:20) Lecture: Slot APIs (Fall 2021) (16:47) Example: Slot APIs (Fall 2021) (10:27) (Bonus, Not Required) More detail on Template Method, Strategy and Null Object Patterns (Fall 2021) (39:00) Example Source See: https://gitlab.com/android-development-2022-refresh/compose-layouts","title":"Compose Layouts"},{"location":"week-08/8.2-Compose-Layouts/index.html#introduction","text":"Arranging your Composables can be tricky to get right. Jetpack Compose's included layouts give you the basic support you need for most layouts, but you can gain more control and simpler specification with a custom layout. We'll also see how a \"slotted\" layout allows you to define a common overall structure where you can plug in each section of the layout. In this module, we'll explore different ways to create a simple \"Forms\" interface, starting with basic Rows and Columns, trying out ConstraintLayout, then creating our own layout manager that will adapt to show a form differently based on available space.","title":"Introduction"},{"location":"week-08/8.2-Compose-Layouts/index.html#videos","text":"Total video time for this module: 2:17:34","title":"Videos"},{"location":"week-08/8.2-Compose-Layouts/index.html#example-basic-and-custom-layouts-fall-2021-11120","text":"","title":"Example: Basic and Custom Layouts (Fall 2021) (1:11:20)"},{"location":"week-08/8.2-Compose-Layouts/index.html#lecture-slot-apis-fall-2021-1647","text":"","title":"Lecture: Slot APIs (Fall 2021) (16:47)"},{"location":"week-08/8.2-Compose-Layouts/index.html#example-slot-apis-fall-2021-1027","text":"","title":"Example: Slot APIs (Fall 2021) (10:27)"},{"location":"week-08/8.2-Compose-Layouts/index.html#bonus-not-required-more-detail-on-template-method-strategy-and-null-object-patterns-fall-2021-3900","text":"","title":"(Bonus, Not Required) More detail on Template Method, Strategy and Null Object Patterns (Fall 2021) (39:00)"},{"location":"week-08/8.2-Compose-Layouts/index.html#example-source","text":"See: https://gitlab.com/android-development-2022-refresh/compose-layouts","title":"Example Source"},{"location":"week-08/8.3-Compose-Toast-Snackbar-Dialog/index.html","text":"Introduction You'll often want to inform the user of the status of the application, or ask if the action they're taking is really what they want to do. In this module, we'll look at three tehniques of giving feedback to the user: Toast, Snackbar and Dialog. Note This video lecture is based on an earlier version of the Movies example, and the code has some different structure to it. (I'll eventually be replacing this module, but wanted to get a feel if the new text format was effective before creating the updated material.) Let me know if you have questions about the differences. The Toast/Snackbar/Dialog concepts will stay about the same in the newer version, and isn't used in an assignment. Videos Total video time for this module: 1:59:27 Jetpack Compose: Toast, Snackbar and Dialog Lecture (Fall 2021) (16:25) Jetpack Compose: Toast, Snackbar and Dialog Example (Fall 2021) (1:43:02) Example Source See: https://gitlab.com/android-development-2022-refresh/compose-toast-snackbar-dialog","title":"Compose Toast Snackbar Dialog"},{"location":"week-08/8.3-Compose-Toast-Snackbar-Dialog/index.html#introduction","text":"You'll often want to inform the user of the status of the application, or ask if the action they're taking is really what they want to do. In this module, we'll look at three tehniques of giving feedback to the user: Toast, Snackbar and Dialog. Note This video lecture is based on an earlier version of the Movies example, and the code has some different structure to it. (I'll eventually be replacing this module, but wanted to get a feel if the new text format was effective before creating the updated material.) Let me know if you have questions about the differences. The Toast/Snackbar/Dialog concepts will stay about the same in the newer version, and isn't used in an assignment.","title":"Introduction"},{"location":"week-08/8.3-Compose-Toast-Snackbar-Dialog/index.html#videos","text":"Total video time for this module: 1:59:27","title":"Videos"},{"location":"week-08/8.3-Compose-Toast-Snackbar-Dialog/index.html#jetpack-compose-toast-snackbar-and-dialog-lecture-fall-2021-1625","text":"","title":"Jetpack Compose: Toast, Snackbar and Dialog Lecture (Fall 2021) (16:25)"},{"location":"week-08/8.3-Compose-Toast-Snackbar-Dialog/index.html#jetpack-compose-toast-snackbar-and-dialog-example-fall-2021-14302","text":"","title":"Jetpack Compose: Toast, Snackbar and Dialog Example (Fall 2021) (1:43:02)"},{"location":"week-08/8.3-Compose-Toast-Snackbar-Dialog/index.html#example-source","text":"See: https://gitlab.com/android-development-2022-refresh/compose-toast-snackbar-dialog","title":"Example Source"},{"location":"week-09/9.1-Google-map/index.html","text":"(Under Development) Example Source: https://gitlab.com/android-development-2022-refresh/google-map","title":"Google Map"},{"location":"week-09/9.2-Speech/index.html","text":"Introduction Android applications can speak to you, and allow you to speak with them! In this module, we'll look at the Android text-to-speech and speech-to-text APIs, and build a simple text-adventure game that can be played without typing! Videos Total video time for this module: 51:23 Speech: Overview (Fall 2021) (15:35) Speech: Example (Fall 2021) (35:48) Example Source See: https://gitlab.com/android-development-2022-refresh/speech","title":"Speech"},{"location":"week-09/9.2-Speech/index.html#introduction","text":"Android applications can speak to you, and allow you to speak with them! In this module, we'll look at the Android text-to-speech and speech-to-text APIs, and build a simple text-adventure game that can be played without typing!","title":"Introduction"},{"location":"week-09/9.2-Speech/index.html#videos","text":"Total video time for this module: 51:23","title":"Videos"},{"location":"week-09/9.2-Speech/index.html#speech-overview-fall-2021-1535","text":"","title":"Speech: Overview (Fall 2021) (15:35)"},{"location":"week-09/9.2-Speech/index.html#speech-example-fall-2021-3548","text":"","title":"Speech: Example (Fall 2021) (35:48)"},{"location":"week-09/9.2-Speech/index.html#example-source","text":"See: https://gitlab.com/android-development-2022-refresh/speech","title":"Example Source"},{"location":"week-10/10.1-Reading-writing-files/index.html","text":"Introduction Many programs need to save or load data to/from files. Android file I/O is similar to Java I/O (using the same APIs), but depending on where you want to save/load files, you may need to jump through a few hoops in the name of user privacy and protection. In this module, we'll look at simple file I/O in private directories on a device or SD card, and more complex Storage-Access Framework file I/O. Note: Due to out-of-town trips, I decided to edit a recording of a live lecture that I gave Summer 2021. Videos Total video time for this module: 1:59:57 Files: Lecture (Summer 2021) (27:29) Files: Example 1 - Private Files (Summer 2021) (35:04) Files: Example 2 - SD Card Private Files and MediaStore (Summer 2021) (35:52) Files: Example 3 - Storage Access Framework (Summer 2021) (21:32) Example Source See: https://gitlab.com/android-development-2022-refresh/reading-writing-files","title":"Reading Writing Files"},{"location":"week-10/10.1-Reading-writing-files/index.html#introduction","text":"Many programs need to save or load data to/from files. Android file I/O is similar to Java I/O (using the same APIs), but depending on where you want to save/load files, you may need to jump through a few hoops in the name of user privacy and protection. In this module, we'll look at simple file I/O in private directories on a device or SD card, and more complex Storage-Access Framework file I/O. Note: Due to out-of-town trips, I decided to edit a recording of a live lecture that I gave Summer 2021.","title":"Introduction"},{"location":"week-10/10.1-Reading-writing-files/index.html#videos","text":"Total video time for this module: 1:59:57","title":"Videos"},{"location":"week-10/10.1-Reading-writing-files/index.html#files-lecture-summer-2021-2729","text":"","title":"Files: Lecture (Summer 2021) (27:29)"},{"location":"week-10/10.1-Reading-writing-files/index.html#files-example-1-private-files-summer-2021-3504","text":"","title":"Files: Example 1 - Private Files (Summer 2021) (35:04)"},{"location":"week-10/10.1-Reading-writing-files/index.html#files-example-2-sd-card-private-files-and-mediastore-summer-2021-3552","text":"","title":"Files: Example 2 - SD Card Private Files and MediaStore (Summer 2021) (35:52)"},{"location":"week-10/10.1-Reading-writing-files/index.html#files-example-3-storage-access-framework-summer-2021-2132","text":"","title":"Files: Example 3 - Storage Access Framework (Summer 2021) (21:32)"},{"location":"week-10/10.1-Reading-writing-files/index.html#example-source","text":"See: https://gitlab.com/android-development-2022-refresh/reading-writing-files","title":"Example Source"},{"location":"week-10/10.2-Dependency-injection/index.html","text":"(Under Development) Example Source: https://gitlab.com/android-development-2022-refresh/dependency-injection","title":"Dependency Injection"},{"location":"week-10/10.3-Clean-architecture/index.html","text":"(Under Development) Example Source: https://gitlab.com/android-development-2022-refresh/clean-architecture","title":"Clean Architecture"},{"location":"week-11/11.1-Services/index.html","text":"Introduction You're creating a music player and would like the music to continue even if the user is looking at a different application. Or your application manages data or an external sensor that other applications need to access. Android Services can help! In this module, we'll create Android services that bridge the gap between applications and can keep running even if the current application is not visible. The sample applications included in this directory are: Service - general service examples - all in same application AndroidService - separate application only hosting a remote service AndroidClient - separate application that talks with the remote service Note Music in example downloaded from https://www.free-stock-music.com/alexander-nakarada-one-bard-band.html LICENSE One Bard Band by Alexander Nakarada | https://www.serpentsoundstudios.com Music promoted by https://www.free-stock-music.com Attribution 4.0 International (CC BY 4.0): https://creativecommons.org/licenses/by/4.0/ Videos Total video time for this module: 1:08:48 Services: Lecture (Fall 2021) (28:14) Services: Example (Fall 2021) (35:42) Services: Remote Example (Fall 2021) (04:52) Example Source See: https://gitlab.com/android-development-2022-refresh/services","title":"Services"},{"location":"week-11/11.1-Services/index.html#introduction","text":"You're creating a music player and would like the music to continue even if the user is looking at a different application. Or your application manages data or an external sensor that other applications need to access. Android Services can help! In this module, we'll create Android services that bridge the gap between applications and can keep running even if the current application is not visible. The sample applications included in this directory are: Service - general service examples - all in same application AndroidService - separate application only hosting a remote service AndroidClient - separate application that talks with the remote service Note Music in example downloaded from https://www.free-stock-music.com/alexander-nakarada-one-bard-band.html LICENSE One Bard Band by Alexander Nakarada | https://www.serpentsoundstudios.com Music promoted by https://www.free-stock-music.com Attribution 4.0 International (CC BY 4.0): https://creativecommons.org/licenses/by/4.0/","title":"Introduction"},{"location":"week-11/11.1-Services/index.html#videos","text":"Total video time for this module: 1:08:48","title":"Videos"},{"location":"week-11/11.1-Services/index.html#services-lecture-fall-2021-2814","text":"","title":"Services: Lecture (Fall 2021) (28:14)"},{"location":"week-11/11.1-Services/index.html#services-example-fall-2021-3542","text":"","title":"Services: Example (Fall 2021) (35:42)"},{"location":"week-11/11.1-Services/index.html#services-remote-example-fall-2021-0452","text":"","title":"Services: Remote Example (Fall 2021) (04:52)"},{"location":"week-11/11.1-Services/index.html#example-source","text":"See: https://gitlab.com/android-development-2022-refresh/services","title":"Example Source"},{"location":"week-11/11.2-Widgets/index.html","text":"Introduction Users can personalize their home screens by adding \"widgets\", small user interfaces that interact with installed applications. In this module, we'll create a simple application that manages a list of names and displays those names on a homescreen widget. Note Note that the videos for this module use the old Android Views approach for the activity's user interface. I have updated the example code to use Jetpack compose for this (and Flows rather than LiveData), but unfortunately, Compose cannot yet be used to create homescreen widgets. When creating a widget user interface, you'll still need to use xml-defined layouts as described in the video and communicate with them using the \"remote views\" API. The new support for Jetpack Compose widgets is called \"Glance\" and is currently in Alpha. If you're interested, take a look here: https://developer.android.com/jetpack/androidx/releases/glance As an interesting aside... Note how much simpler the list of names UI is to implement in Jetpack Compose than the old RecyclerView! Videos Total video time for this module: 42:32 Widgets: Lecture (Spring 2016) (10:32) Widgets: Example (Spring 2016) (32:00) Example Source See: https://gitlab.com/android-development-2022-refresh/widgets","title":"Widgets"},{"location":"week-11/11.2-Widgets/index.html#introduction","text":"Users can personalize their home screens by adding \"widgets\", small user interfaces that interact with installed applications. In this module, we'll create a simple application that manages a list of names and displays those names on a homescreen widget. Note Note that the videos for this module use the old Android Views approach for the activity's user interface. I have updated the example code to use Jetpack compose for this (and Flows rather than LiveData), but unfortunately, Compose cannot yet be used to create homescreen widgets. When creating a widget user interface, you'll still need to use xml-defined layouts as described in the video and communicate with them using the \"remote views\" API. The new support for Jetpack Compose widgets is called \"Glance\" and is currently in Alpha. If you're interested, take a look here: https://developer.android.com/jetpack/androidx/releases/glance As an interesting aside... Note how much simpler the list of names UI is to implement in Jetpack Compose than the old RecyclerView!","title":"Introduction"},{"location":"week-11/11.2-Widgets/index.html#videos","text":"Total video time for this module: 42:32","title":"Videos"},{"location":"week-11/11.2-Widgets/index.html#widgets-lecture-spring-2016-1032","text":"","title":"Widgets: Lecture (Spring 2016) (10:32)"},{"location":"week-11/11.2-Widgets/index.html#widgets-example-spring-2016-3200","text":"","title":"Widgets: Example (Spring 2016) (32:00)"},{"location":"week-11/11.2-Widgets/index.html#example-source","text":"See: https://gitlab.com/android-development-2022-refresh/widgets","title":"Example Source"},{"location":"week-12/12.1-Legacy-views/index.html","text":"(Under Development) Example Source: https://gitlab.com/android-development-2022-refresh/legacy-views","title":"Legacy Views"},{"location":"week-12/12.2-Legacy-fragments/index.html","text":"(Under Development) Example Source: https://gitlab.com/android-development-2022-refresh/legacy-fragments","title":"Legacy Fragments"},{"location":"week-13/13.1-Testing/index.html","text":"(Under Development) Example Source: https://gitlab.com/android-development-2022-refresh/testing","title":"Testing"},{"location":"week-13/13.2-Nfc/index.html","text":"Introduction Note Note that these videos are from 2016 and were based in Java using Android Views for the UI. I have updated the example to Kotlin using Jetpack Compose for the UI. The concepts in the lecture and example videos still apply. (It also might be interesting to watch these older videos to see how Android development looks in Java compared to Kotlin). Also note that these examples will not run on the emulator; you can only use NFC on a device that supports it. I would have loved to include an assignment on NFC, but not all students will have Android devices, or Android devices with NFC. Near-Field Communication (NFC) allows your application to read and write hardware tags with a small chunk of data. This data can be plain text, a URI, contact information, or any other data format you would like. This can be useful, for example, to read data from a poster or business card or write data to a bag describing its contents. Videos Total video time for this module: 50:53 Near-Field Communication: Lecture (Spring 2016) (19:11) Near-Field Communication: Reading Example (Spring 2016) (16:16) Near-Field Communication: Writing Example (Spring 2016) (15:26) Example Source See: https://gitlab.com/android-development-2022-refresh/nfc","title":"NFC"},{"location":"week-13/13.2-Nfc/index.html#introduction","text":"Note Note that these videos are from 2016 and were based in Java using Android Views for the UI. I have updated the example to Kotlin using Jetpack Compose for the UI. The concepts in the lecture and example videos still apply. (It also might be interesting to watch these older videos to see how Android development looks in Java compared to Kotlin). Also note that these examples will not run on the emulator; you can only use NFC on a device that supports it. I would have loved to include an assignment on NFC, but not all students will have Android devices, or Android devices with NFC. Near-Field Communication (NFC) allows your application to read and write hardware tags with a small chunk of data. This data can be plain text, a URI, contact information, or any other data format you would like. This can be useful, for example, to read data from a poster or business card or write data to a bag describing its contents.","title":"Introduction"},{"location":"week-13/13.2-Nfc/index.html#videos","text":"Total video time for this module: 50:53","title":"Videos"},{"location":"week-13/13.2-Nfc/index.html#near-field-communication-lecture-spring-2016-1911","text":"","title":"Near-Field Communication: Lecture (Spring 2016) (19:11)"},{"location":"week-13/13.2-Nfc/index.html#near-field-communication-reading-example-spring-2016-1616","text":"","title":"Near-Field Communication: Reading Example (Spring 2016) (16:16)"},{"location":"week-13/13.2-Nfc/index.html#near-field-communication-writing-example-spring-2016-1526","text":"","title":"Near-Field Communication: Writing Example (Spring 2016) (15:26)"},{"location":"week-13/13.2-Nfc/index.html#example-source","text":"See: https://gitlab.com/android-development-2022-refresh/nfc","title":"Example Source"},{"location":"week-14/14.1-Sensors/index.html","text":"Introduction Most Android devices come with sensors for reporting movement, temperature, direction, location, etc. In this module, we'll talk about some sensor concepts and implement a simple moving puck on the screen using accelerometer input that translates tilt of the phone into movement of the puck. Videos Total video time for this module: 23:03 Sensors: Lecture and Examples (Summer 2021) (23:03) Example Source See: https://gitlab.com/android-development-2022-refresh/sensors","title":"Sensors"},{"location":"week-14/14.1-Sensors/index.html#introduction","text":"Most Android devices come with sensors for reporting movement, temperature, direction, location, etc. In this module, we'll talk about some sensor concepts and implement a simple moving puck on the screen using accelerometer input that translates tilt of the phone into movement of the puck.","title":"Introduction"},{"location":"week-14/14.1-Sensors/index.html#videos","text":"Total video time for this module: 23:03","title":"Videos"},{"location":"week-14/14.1-Sensors/index.html#sensors-lecture-and-examples-summer-2021-2303","text":"","title":"Sensors: Lecture and Examples (Summer 2021) (23:03)"},{"location":"week-14/14.1-Sensors/index.html#example-source","text":"See: https://gitlab.com/android-development-2022-refresh/sensors","title":"Example Source"},{"location":"week-14/14.2-Version-catalogs/index.html","text":"(Under Development) Example Source: https://gitlab.com/android-development-2022-refresh/version-catalogs","title":"Version Catalogs"},{"location":"week-14/14.3-Publishing/index.html","text":"Introduction What good is an application if you keep it all to yourself? You can use the Google Play Store to distribute your application to others! In this module, we'll work on uploading a release of an application on the play store and talk about some of the necessary setup and application details you may want to consider when publishing an application. Note that you do not need to use the Google Play Store for distribution. You can publish an app on a web site for download, send it via email or on a USB drive. However, users must grant permission on their device to be able to install from non-Google-Play-Store locations. Videos Total video time for this module: 28:00 Publishing: Lecture (Summer 2021) (28:00)","title":"Publishing"},{"location":"week-14/14.3-Publishing/index.html#introduction","text":"What good is an application if you keep it all to yourself? You can use the Google Play Store to distribute your application to others! In this module, we'll work on uploading a release of an application on the play store and talk about some of the necessary setup and application details you may want to consider when publishing an application. Note that you do not need to use the Google Play Store for distribution. You can publish an app on a web site for download, send it via email or on a USB drive. However, users must grant permission on their device to be able to install from non-Google-Play-Store locations.","title":"Introduction"},{"location":"week-14/14.3-Publishing/index.html#videos","text":"Total video time for this module: 28:00","title":"Videos"},{"location":"week-14/14.3-Publishing/index.html#publishing-lecture-summer-2021-2800","text":"","title":"Publishing: Lecture (Summer 2021) (28:00)"},{"location":"week-14/14.4-Resources/index.html","text":"Introduction You've reached the end of the course! Congratulations! In this module, I'll point you to a few other resources that may be helpful and you work with Android in the future. Videos Total video time for this module: 03:25 Further Resources: Lecture (Summer 2021) (03:25)","title":"Resources"},{"location":"week-14/14.4-Resources/index.html#introduction","text":"You've reached the end of the course! Congratulations! In this module, I'll point you to a few other resources that may be helpful and you work with Android in the future.","title":"Introduction"},{"location":"week-14/14.4-Resources/index.html#videos","text":"Total video time for this module: 03:25","title":"Videos"},{"location":"week-14/14.4-Resources/index.html#further-resources-lecture-summer-2021-0325","text":"","title":"Further Resources: Lecture (Summer 2021) (03:25)"}]}